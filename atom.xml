<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>国家一级保护废物</title>
  <icon>https://www.gravatar.com/avatar/894b1b494f1ec89a63bf9d550e8d2f09</icon>
  <subtitle>You only care about kindness, and God has its own measure</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://schnappi618.github.io/"/>
  <updated>2022-07-28T13:20:27.181Z</updated>
  <id>https://schnappi618.github.io/</id>
  
  <author>
    <name>schnappi618</name>
    <email>chunliang_li0514@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>公务员备考之判断推理第三节——类比推理</title>
    <link href="https://schnappi618.github.io/2022/07/28/shangan/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/%E5%85%AC%E5%8A%A1%E5%91%98%E5%A4%87%E8%80%83%E4%B9%8B%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86%E7%AC%AC%E4%B8%89%E8%8A%82%E2%80%94%E2%80%94%E7%B1%BB%E6%AF%94%E6%8E%A8%E7%90%86/"/>
    <id>https://schnappi618.github.io/2022/07/28/shangan/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/%E5%85%AC%E5%8A%A1%E5%91%98%E5%A4%87%E8%80%83%E4%B9%8B%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86%E7%AC%AC%E4%B8%89%E8%8A%82%E2%80%94%E2%80%94%E7%B1%BB%E6%AF%94%E6%8E%A8%E7%90%86/</id>
    <published>2022-07-27T17:08:44.000Z</published>
    <updated>2022-07-28T13:20:27.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><blockquote><p>类比推理是给一组相关词，通过观察分析，找出一组与之在<strong>逻辑关系</strong>上<strong>最</strong>为贴近或相似的词</p></blockquote><h3 id="1、解题原则"><a href="#1、解题原则" class="headerlink" title="1、解题原则"></a>1、解题原则</h3><ul><li>二元关系：逻辑关系</li><li>二级辨析：找到<strong>最贴近/相似</strong>的词</li></ul><h3 id="2、题型分类"><a href="#2、题型分类" class="headerlink" title="2、题型分类"></a>2、题型分类</h3><ul><li>两元型：两个词(X : Y)</li><li>多元型：一般为三个词(X : Y : Z)</li><li>填空型：( ) 对于 X 相当于 Y 对于( )</li></ul><blockquote><p>填空型需要逐一代入，验证前后关系</p></blockquote><h2 id="二、外延关系"><a href="#二、外延关系" class="headerlink" title="二、外延关系"></a>二、外延关系</h2><h3 id="1、全同关系"><a href="#1、全同关系" class="headerlink" title="1、全同关系"></a>1、全同关系</h3><blockquote><p>两个词概念意思完全相同</p></blockquote><ul><li>土豆 ：马铃薯</li><li>芙蕖(菡萏) ：荷花</li><li>杜鹃花 ：映山红</li><li>春夏秋冬 ：四季</li></ul><h3 id="2、交叉关系"><a href="#2、交叉关系" class="headerlink" title="2、交叉关系"></a>2、交叉关系</h3><blockquote><p>两个词有部分相交，但不能完全相交</p></blockquote><p><strong>推理方法</strong>：</p><ul><li>分类标准不同</li><li>造句(下面4句都需符合)<ul><li>有的 A 是 B，有的 A 不是 B</li><li>有的 B 是 A，有的 B 不是 A</li></ul></li><li>例如：水桶 ：木桶<ul><li>水桶是功能分类；木桶是材料分类</li><li>四句造句都通顺合理</li></ul></li></ul><h3 id="3、并列关系"><a href="#3、并列关系" class="headerlink" title="3、并列关系"></a>3、并列关系</h3><blockquote><p><strong>相同的分类标准下</strong>对概念分类，可分为矛盾关系和反对关系</p></blockquote><h4 id="3-1-矛盾关系"><a href="#3-1-矛盾关系" class="headerlink" title="3.1 矛盾关系"></a>3.1 矛盾关系</h4><p>矛盾关系指概念分类后，有且只有两个子集</p><p>例如：生：死； 南：女； 转基因：非转基因</p><h4 id="3-2-反对关系"><a href="#3-2-反对关系" class="headerlink" title="3.2 反对关系"></a>3.2 反对关系</h4><p>反对关系指分类后，还有其他子集</p><p>例如：苹果：香蕉；黑：白；鼠标：键盘</p><h3 id="4、包含关系"><a href="#4、包含关系" class="headerlink" title="4、包含关系"></a>4、包含关系</h3><blockquote><p>一个完全包含另外一个，<strong>需注意前后顺序</strong>，可分为种属关系和组成关系</p></blockquote><h4 id="4-1-种属关系"><a href="#4-1-种属关系" class="headerlink" title="4.1 种属关系"></a>4.1 种属关系</h4><p>种属关系为类与类的对应，可造句为：xx是xx</p><p>例如：树：杨树 (杨树是树)</p><h4 id="4-2-组成关系"><a href="#4-2-组成关系" class="headerlink" title="4.2 组成关系"></a>4.2 组成关系</h4><p>组成关系是整体和部分的对应，可造句为：xx是xx的一部分</p><p>例如：树：树根(树根是树的一部分)</p><h2 id="三、语义关系"><a href="#三、语义关系" class="headerlink" title="三、语义关系"></a>三、语义关系</h2><blockquote><ol><li>语义关系靠积累</li><li>利用会的去排除</li><li>实在不会可以猜</li></ol></blockquote><h3 id="1、近义-amp-反义关系"><a href="#1、近义-amp-反义关系" class="headerlink" title="1、近义&amp;反义关系"></a>1、近义&amp;反义关系</h3><p>两个词互为近义或反义词关系</p><p>例如：知难而退：百折不挠(反义)；</p><h5 id="二级辨析-褒-贬-前后顺序"><a href="#二级辨析-褒-贬-前后顺序" class="headerlink" title="二级辨析(褒/贬+前后顺序)"></a>二级辨析(褒/贬+前后顺序)</h5><ul><li>近义关系程度有区别：例如尊重：崇敬(程度强)；承受：忍受(程度强)</li><li>语义关系情感色彩区别 (褒义/贬义)</li></ul><h3 id="2、象征关系"><a href="#2、象征关系" class="headerlink" title="2、象征关系"></a>2、象征关系</h3><p>象征关系分为传统象征和比喻象征。</p><ul><li>传统象征<ul><li>巾帼：女子； 须眉：男子</li><li>没话：坚强； 桑梓：家乡</li></ul></li><li>比喻象征<ul><li>心灵的窗户：眼睛</li><li>踢皮球：推诿</li><li>纸老虎：外强中干</li><li>白鸽：和平</li></ul></li></ul><h2 id="四、内涵关系"><a href="#四、内涵关系" class="headerlink" title="四、内涵关系"></a>四、内涵关系</h2><h3 id="1、条件关系"><a href="#1、条件关系" class="headerlink" title="1、条件关系"></a>1、条件关系</h3><blockquote><p>条件关系主要观察词语之间的必然性</p></blockquote><ul><li>充分条件：有了就一定行<ul><li>例如：燃烧：放热</li></ul></li><li>必要条件：没有一定不行<ul><li>例如：18周岁：选举权</li></ul></li></ul><h3 id="2、因果关系"><a href="#2、因果关系" class="headerlink" title="2、因果关系"></a>2、因果关系</h3><blockquote><p>因果关系主要考察事件之间的因果联系，大部分因果关系是非必然的</p><p>因果关系为必然的称之为条件关系</p></blockquote><h5 id="二级辨析"><a href="#二级辨析" class="headerlink" title="二级辨析"></a>二级辨析</h5><ul><li>结果：结果为消极还是积极<ul><li>竞争：淘汰(消极)</li><li>创业：成功(积极)</li></ul></li><li>原因：原因是人造还是自然(‼️)<ul><li>玻璃幕墙(人造)：光污染</li><li>火山喷发(自然)：地震</li></ul></li></ul><h3 id="3、顺承关系"><a href="#3、顺承关系" class="headerlink" title="3、顺承关系"></a>3、顺承关系</h3><blockquote><p>顺承关系需重点观察时间上的先后顺序</p><p>需尊重普遍逻辑和常规规律</p></blockquote><h5 id="二级辨析-1"><a href="#二级辨析-1" class="headerlink" title="二级辨析"></a>二级辨析</h5><ul><li>主体是否相同<ul><li>恋爱：结婚(主体一致)</li><li>请假：批准(主体不一致)</li></ul></li></ul><h3 id="4、属性关系"><a href="#4、属性关系" class="headerlink" title="4、属性关系"></a>4、属性关系</h3><blockquote><p>属性关系指概念具备的性质。分为必然属性和或然属性</p></blockquote><ul><li>必然属性：醋：酸</li><li>或然属性：花：红</li></ul><h3 id="5、对应关系"><a href="#5、对应关系" class="headerlink" title="5、对应关系"></a>5、对应关系</h3><blockquote><p>对应关系主要看搭配关系，重点看四种搭配</p></blockquote><ul><li><p>与“物”相关：</p><ul><li>物[物品/人物/事件]：场所<ul><li>火车：铁轨</li><li>病人：医院</li><li>炒菜：厨房</li></ul></li><li>物：功能（<strong>二级辨析：功能为主要还是次要</strong>）<ul><li>电灯：照明(主要功能)</li><li>钢笔：书写(主要功能)</li><li>白醋：消毒(次要功能)</li></ul></li><li>物：工艺（<strong>二级辨析：为物理还是化学变化</strong>）<ul><li>陶瓷：煅烧(化学变化)</li><li>白酒：发酵(化学变化)</li><li>玉器：磨制(物理变化)</li></ul></li><li>物：材料<ul><li>书桌：木材</li><li>面粉：小麦</li><li>斗笠：竹子</li></ul></li></ul></li><li><p>与“职业”相关</p><blockquote><p>有一些常见的假职业：</p><p>学生、病人、志愿者、网民、经理…</p></blockquote><ul><li>职业：工作<ul><li>护士：输液</li><li>清洁工：保洁</li></ul></li><li>职业：工具<ul><li>医生：听诊器</li><li>裁缝：剪刀</li></ul></li><li>职业：对象<ul><li>医生：病人</li><li>教师：学生</li></ul></li><li>职业：产出<ul><li>厨师：菜品</li><li>摄影师：照片</li></ul></li></ul></li><li><p>与“逻辑”相关</p><ul><li>方式：目的<ul><li>凿壁：偷光</li><li>种树：绿化</li></ul></li></ul></li><li><p>与”常识“相关</p><ul><li>成语：主人公：出处<ul><li>负荆请罪：廉颇/蔺相如：史记</li></ul></li><li>诗词：作者：名称：意象</li><li>其他常识<ul><li>周：东周：西周</li></ul></li></ul></li></ul><h3 id="6、语法关系"><a href="#6、语法关系" class="headerlink" title="6、语法关系"></a>6、语法关系</h3><ul><li>主谓宾关系<ul><li>主语：动作的发起者</li><li>谓语：谓语动词</li><li>宾语：动作的承受者</li><li>例如：记者：采访(主谓关系)；记者：新闻(主宾关系)</li></ul></li><li>偏正关系(修饰词+中心语)<ul><li>形容词(的) + 名词<ul><li>漂亮：女孩</li></ul></li><li>副词(地) + 动词<ul><li>认真：学习</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、基础概念&quot;&gt;&lt;a href=&quot;#一、基础概念&quot; class=&quot;headerlink&quot; title=&quot;一、基础概念&quot;&gt;&lt;/a&gt;一、基础概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;类比推理是给一组相关词，通过观察分析，找出一组与之在&lt;strong&gt;逻辑关系&lt;/s
      
    
    </summary>
    
    
      <category term="判断推理" scheme="https://schnappi618.github.io/categories/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/"/>
    
    
      <category term="考公" scheme="https://schnappi618.github.io/tags/%E8%80%83%E5%85%AC/"/>
    
      <category term="判断推理" scheme="https://schnappi618.github.io/tags/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>公务员备考之判断推理第二节——加强及削弱论证</title>
    <link href="https://schnappi618.github.io/2022/07/27/shangan/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/%E5%85%AC%E5%8A%A1%E5%91%98%E5%A4%87%E8%80%83%E4%B9%8B%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86%E7%AC%AC%E4%BA%8C%E8%8A%82%E2%80%94%E2%80%94%E5%8A%A0%E5%BC%BA%E5%8F%8A%E5%89%8A%E5%BC%B1%E8%AE%BA%E8%AF%81/"/>
    <id>https://schnappi618.github.io/2022/07/27/shangan/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/%E5%85%AC%E5%8A%A1%E5%91%98%E5%A4%87%E8%80%83%E4%B9%8B%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86%E7%AC%AC%E4%BA%8C%E8%8A%82%E2%80%94%E2%80%94%E5%8A%A0%E5%BC%BA%E5%8F%8A%E5%89%8A%E5%BC%B1%E8%AE%BA%E8%AF%81/</id>
    <published>2022-07-27T14:47:32.000Z</published>
    <updated>2022-07-27T17:07:58.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、论证概述"><a href="#一、论证概述" class="headerlink" title="一、论证概述"></a>一、论证概述</h2><h3 id="1、题型识别"><a href="#1、题型识别" class="headerlink" title="1、题型识别"></a>1、题型识别</h3><ul><li><strong>提问方式</strong>：最能 <strong>支持/削弱</strong> 论点的是</li></ul><h3 id="2、知识点"><a href="#2、知识点" class="headerlink" title="2、知识点"></a>2、知识点</h3><h4 id="2-1-论证结构及原则"><a href="#2-1-论证结构及原则" class="headerlink" title="2.1 论证结构及原则"></a>2.1 论证结构及原则</h4><blockquote><p>论证则是<strong>通过论据证明论点</strong></p><p>只有论点是必须存在的，所以 <strong>优先找论点</strong></p></blockquote><h5 id="论证结构"><a href="#论证结构" class="headerlink" title="论证结构"></a>论证结构</h5><p>论据 =&gt; 论证过程 =&gt; 论点</p><ul><li>论据：得到论点的根据/依据 (可有可无)</li><li>论证过程：论据和论点之间的(隐含)联系 (可有可无)</li><li>论点：被证明的结论/观点 (一定有)</li></ul><p><strong>原则</strong>：话题保持一致</p><h4 id="2-2-解题思路"><a href="#2-2-解题思路" class="headerlink" title="2.2 解题思路"></a>2.2 解题思路</h4><blockquote><p>根据论证题目的原则， <strong>话题不一致的选项可以直接排除</strong></p><p>对比择优</p></blockquote><ol><li>找论点：<ul><li>引导词：认为/以为/观点是/表明/说明/结果是/因此/所以/建议</li><li>首尾句：题目一般为总分或分总结构</li><li>主旨概括：少量题目需要自己概括论点</li></ul></li><li>找论据<ul><li>证明论点的根据/依据；举例子等</li></ul></li><li>看要求<ul><li>加强 = 赞同</li><li>削弱 = 反对</li></ul></li><li>选答案<ul><li><strong>对比择优，按照强度排序</strong></li><li>与题目的关联性 (一般关联越密切强度越强；若都无关，尊重客观事实)</li><li>方法强度排序</li></ul></li></ol><h2 id="二、加强论证"><a href="#二、加强论证" class="headerlink" title="二、加强论证"></a>二、加强论证</h2><h3 id="1、题型识别-1"><a href="#1、题型识别-1" class="headerlink" title="1、题型识别"></a>1、题型识别</h3><ul><li><strong>提问方式</strong>：加强、支持、肯定、前提、假设</li></ul><h3 id="2、知识点-1"><a href="#2、知识点-1" class="headerlink" title="2、知识点"></a>2、知识点</h3><h4 id="2-1-加强论据-🌟"><a href="#2-1-加强论据-🌟" class="headerlink" title="2.1 加强论据 (🌟)"></a>2.1 加强论据 (🌟)</h4><h5 id="排除他因"><a href="#排除他因" class="headerlink" title="排除他因"></a>排除他因</h5><blockquote><p>加强论点为真的可能性</p></blockquote><p>排除其他选项，加强唯一原因的可能性</p><h5 id="补充论据"><a href="#补充论据" class="headerlink" title="补充论据"></a>补充论据</h5><ul><li>讲道理：说明原因/原理</li><li>增加新证据、事实、例子、数据、实验等</li><li>和论点方向一致</li></ul><h5 id="对比实验"><a href="#对比实验" class="headerlink" title="对比实验"></a>对比实验</h5><blockquote><p>需注意控制变量一致等</p></blockquote><p>有A有B，无A无B</p><h4 id="2-2-建立联系【搭桥】-🌟🌟"><a href="#2-2-建立联系【搭桥】-🌟🌟" class="headerlink" title="2.2 建立联系【搭桥】(🌟🌟)"></a>2.2 建立联系【搭桥】(🌟🌟)</h4><blockquote><p>建立论据和论点之间的联系 <strong>将隐藏联系明确化</strong></p></blockquote><ul><li>题干论据论点关系不紧密(话题不完全一致)</li><li>正确选项同时具备论据和论点的关键信息</li><li>前提、假设文法中考察搭桥比重偏高</li></ul><h4 id="2-3-加强论点-🌟"><a href="#2-3-加强论点-🌟" class="headerlink" title="2.3 加强论点(🌟)"></a>2.3 加强论点(🌟)</h4><p>加强论点即为<strong>重复论点</strong></p><h4 id="2-4-不能加强"><a href="#2-4-不能加强" class="headerlink" title="2.4 不能加强"></a>2.4 不能加强</h4><p><strong>提问方式</strong>：不能加强/不能支持/不能肯定</p><blockquote><p>⚠️注意：</p><p>不能加强 不等于 削弱；</p><p>无关项、削弱项均不能加强 (如果选项中二者都有，优先选削弱)</p></blockquote><h2 id="三、削弱论证"><a href="#三、削弱论证" class="headerlink" title="三、削弱论证"></a>三、削弱论证</h2><h3 id="1、题型识别-2"><a href="#1、题型识别-2" class="headerlink" title="1、题型识别"></a>1、题型识别</h3><ul><li><strong>提问方式</strong>：质疑、削弱、否定、反驳、反对</li></ul><h3 id="2、知识点-2"><a href="#2、知识点-2" class="headerlink" title="2、知识点"></a>2、知识点</h3><h4 id="2-1-否论据"><a href="#2-1-否论据" class="headerlink" title="2.1 否论据"></a>2.1 否论据</h4><h5 id="另有他因-🌟"><a href="#另有他因-🌟" class="headerlink" title="另有他因(🌟)"></a>另有他因(🌟)</h5><blockquote><p>他因和无关项的区别： <strong>是否和论点有联系</strong>，有联系的为他因</p></blockquote><p>引入新的可能性，削弱了本身原因的可能性</p><h5 id="反向论据-🌟"><a href="#反向论据-🌟" class="headerlink" title="反向论据(🌟)"></a>反向论据(🌟)</h5><p>与论点相反的证据、道理、事实、例子、数据、实验等</p><h5 id="对比实验-🌟🌟"><a href="#对比实验-🌟🌟" class="headerlink" title="对比实验(🌟🌟)"></a>对比实验(🌟🌟)</h5><blockquote><p>打断A、B同时存在、同时增强的关联</p></blockquote><p>有A有B，有A无B；</p><p>有A有B，无A有B；</p><h4 id="2-2-打断联系【拆桥】-🌟🌟"><a href="#2-2-打断联系【拆桥】-🌟🌟" class="headerlink" title="2.2 打断联系【拆桥】(🌟🌟)"></a>2.2 打断联系【拆桥】(🌟🌟)</h4><p>打断据和论点之间的联系</p><h4 id="2-3-否论点"><a href="#2-3-否论点" class="headerlink" title="2.3 否论点"></a>2.3 否论点</h4><h5 id="直接否论点-🌟🌟🌟"><a href="#直接否论点-🌟🌟🌟" class="headerlink" title="直接否论点(🌟🌟🌟)"></a>直接否论点(🌟🌟🌟)</h5><ul><li>题目中只有论点，可直接否定论点</li><li>题目中有论据，需要<strong>有理由的否论点</strong></li></ul><h5 id="否前提-🌟🌟🌟"><a href="#否前提-🌟🌟🌟" class="headerlink" title="否前提(🌟🌟🌟)"></a>否前提(🌟🌟🌟)</h5><p>否定论点成立必不可少的条件。例如：小明活着，否前提则可以为：小明处于无氧环境中</p><h5 id="因果倒置-🌟🌟🌟"><a href="#因果倒置-🌟🌟🌟" class="headerlink" title="因果倒置(🌟🌟🌟)"></a>因果倒置(🌟🌟🌟)</h5><p>论点：A导致B (因为A，所以B)</p><p>倒置：B导致A (因为B，所以A)</p><h4 id="2-4-不能削弱"><a href="#2-4-不能削弱" class="headerlink" title="2.4 不能削弱"></a>2.4 不能削弱</h4><p><strong>提问方式</strong>：不能削弱/不能质疑/不能否定/不能反驳</p><blockquote><p>⚠️注意：</p><p>不能削弱 不等于 加强；</p><p>无关项、加强项均不能削弱 (如果选项中二者都有，优先选加强    )</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、论证概述&quot;&gt;&lt;a href=&quot;#一、论证概述&quot; class=&quot;headerlink&quot; title=&quot;一、论证概述&quot;&gt;&lt;/a&gt;一、论证概述&lt;/h2&gt;&lt;h3 id=&quot;1、题型识别&quot;&gt;&lt;a href=&quot;#1、题型识别&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="判断推理" scheme="https://schnappi618.github.io/categories/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/"/>
    
    
      <category term="考公" scheme="https://schnappi618.github.io/tags/%E8%80%83%E5%85%AC/"/>
    
      <category term="判断推理" scheme="https://schnappi618.github.io/tags/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>公务员备考之判断推理第一节——翻译推理及分析推理</title>
    <link href="https://schnappi618.github.io/2022/07/25/shangan/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/%E5%85%AC%E5%8A%A1%E5%91%98%E5%A4%87%E8%80%83%E4%B9%8B%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86%E7%AC%AC%E4%B8%80%E8%8A%82%E2%80%94%E2%80%94%E7%BF%BB%E8%AF%91%E6%8E%A8%E7%90%86%E5%8F%8A%E5%88%86%E6%9E%90%E6%8E%A8%E7%90%86/"/>
    <id>https://schnappi618.github.io/2022/07/25/shangan/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/%E5%85%AC%E5%8A%A1%E5%91%98%E5%A4%87%E8%80%83%E4%B9%8B%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86%E7%AC%AC%E4%B8%80%E8%8A%82%E2%80%94%E2%80%94%E7%BF%BB%E8%AF%91%E6%8E%A8%E7%90%86%E5%8F%8A%E5%88%86%E6%9E%90%E6%8E%A8%E7%90%86/</id>
    <published>2022-07-25T14:38:38.000Z</published>
    <updated>2022-07-25T16:04:52.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、翻译推理"><a href="#一、翻译推理" class="headerlink" title="一、翻译推理"></a>一、翻译推理</h2><h3 id="1、题型识别"><a href="#1、题型识别" class="headerlink" title="1、题型识别"></a>1、题型识别</h3><ol><li>题干有<strong>关联词</strong></li><li>题目为<strong>“推出类”提问</strong></li></ol><p>满足以上两个要求的则为翻译推理类题目。</p><blockquote><p>例如：题干说明：<em>如果</em>坚持锻炼，阿尔茨海默症等神经退行性疾病的发病风险<em>就</em>会降低。（包含关联词：如果…就…）</p><p>题目问：由此可以推出（为推出类提问）</p></blockquote><h3 id="2、知识点"><a href="#2、知识点" class="headerlink" title="2、知识点"></a>2、知识点</h3><h4 id="2-1-假言命题"><a href="#2-1-假言命题" class="headerlink" title="2.1 假言命题"></a>2.1 假言命题</h4><p>在假设条件下推出的命题，一般包含以下两种表达式</p><h5 id="1-如果P，则Q-前推后"><a href="#1-如果P，则Q-前推后" class="headerlink" title="1. 如果P，则Q(前推后)"></a>1. 如果P，则Q(前推后)</h5><p><strong>翻译规则：</strong> P -&gt; Q</p><p><strong>推理规则：</strong>肯前必肯后，否后必否前，否前肯后不必然</p><blockquote><p>所有的翻译推理中，<strong>推理规则只针对翻译表达式</strong></p></blockquote><h5 id="2-只有Q，才P-后推前"><a href="#2-只有Q，才P-后推前" class="headerlink" title="2. 只有Q，才P(后推前)"></a>2. 只有Q，才P(后推前)</h5><p><strong>翻译规则：</strong> P -&gt; Q</p><p><strong>推理规则：</strong>肯前必肯后，否后必否前，否前肯后不必然</p><blockquote><p>后推前示例：只有尊重自然，才能有效防止在开发利用自然上走弯路</p><p>以上翻译规则为：防止走弯路 推出 尊重自然</p></blockquote><h4 id="2-2-关联词替换表达"><a href="#2-2-关联词替换表达" class="headerlink" title="2.2 关联词替换表达"></a>2.2 关联词替换表达</h4><p>除了上述 <strong>如果…则…</strong> 和 <strong>只有…才…</strong> 这两个最基础的关联词之外，还有一些同义的替换词</p><h5 id="1-前推后"><a href="#1-前推后" class="headerlink" title="1. 前推后"></a>1. 前推后</h5><ul><li>如果(假如/若)…就(那么/则…)：如果考第一，就出去玩(考第一 推出 出去玩)</li><li>只要…就(那么/则)…：需要和只有才区分开</li><li>…是…的充分条件</li><li>不…不(就)…：不到长城非好汉(不到长城 推出 不是好汉)</li><li>要(是/想)…就(那么/则)…：要想考高分，就得多做题(考高分 推出 多做题)</li><li>没有…(就)没有…：(如果)没有共产党就没有新中国(非共产党 推出 非新中国)</li></ul><blockquote><p>可能会出现省略如果的情况，例如：穷则独善其身，可以理解为如果穷，则独善其身。所以穷 推出 独善其身</p></blockquote><h5 id="2-后推前"><a href="#2-后推前" class="headerlink" title="2. 后推前"></a>2. 后推前</h5><ul><li>只有…才…</li><li>除非…否则不…：除非成绩合格，否则不予毕业(毕业 推出 成绩合格)</li><li>除非A否则B：非B 推出 A，除非早出门，否则会迟到(没迟到 推出 早出门)</li></ul><h5 id="3-找必要"><a href="#3-找必要" class="headerlink" title="3. 找必要"></a>3. 找必要</h5><blockquote><p>找必要的相关替换：必要的/必须的放在“箭头”后面。</p><p>例如：补钙，是长高个所必须的。  长高个 推出 补钙</p></blockquote><ul><li>前提、基础、关键</li><li>必须、必要</li><li>必不可少、不可或缺</li><li>不能没有、离不开</li></ul><h4 id="2-3-联言命题"><a href="#2-3-联言命题" class="headerlink" title="2.3 联言命题"></a>2.3 联言命题</h4><blockquote><p>联言命题为且关系</p></blockquote><p><strong>表达式：</strong> A 且 B</p><p><strong>关联词：</strong> 且、和、都、既…又…、但(但在推理中表示且的意思。例如：我很丑但很温柔)</p><p><strong>推理规则：</strong> 同真才真，一假则假</p><h4 id="2-4-选言命题"><a href="#2-4-选言命题" class="headerlink" title="2.4 选言命题"></a>2.4 选言命题</h4><blockquote><p>选言命题为或关系</p><p>需注意 A或B 和 要么A，要么B的区别：前者是至少一个，后者是只能有一个</p></blockquote><p><strong>表达式：</strong> A 或 B </p><p><strong>关联词：</strong> 或、或者、至少一个</p><p><strong>推理规则：</strong> 同假才假，一真则真</p><p><strong>否一肯一：</strong> 否定一个，推出另一个为真。已知A或B为真，则 非A 可以推出 B</p><h4 id="2-5-德摩根定律"><a href="#2-5-德摩根定律" class="headerlink" title="2.5 德摩根定律"></a>2.5 德摩根定律</h4><p><strong>表达式：</strong> 非(A或B) = 非A 且 非B；</p><p>​                 非(A且B) = 非A 或 非B</p><h2 id="二、分析推理"><a href="#二、分析推理" class="headerlink" title="二、分析推理"></a>二、分析推理</h2><h3 id="1、题型识别-1"><a href="#1、题型识别-1" class="headerlink" title="1、题型识别"></a>1、题型识别</h3><p>分析推理的题型识别主要在于<strong>对象和特征匹配。</strong></p><p>例如，题干包含三个人和三个项目，题目让将人和项目对应起来。</p><h3 id="2、知识点-1"><a href="#2、知识点-1" class="headerlink" title="2、知识点"></a>2、知识点</h3><h4 id="2-1-排除法"><a href="#2-1-排除法" class="headerlink" title="2.1 排除法"></a>2.1 排除法</h4><p><strong>使用前提：</strong>选项信息充分全面，则对象和特征数量完全一致</p><p><strong>直接排除：</strong>当题干信息确定，即题干信息完全确定为真时，直接用选项进行排除</p><p><strong>代入排除：</strong>当题干信息不确定全部为真，可以假设选项正确，代入题干，验证是否符合题目要求</p><h4 id="2-2-确定信息法"><a href="#2-2-确定信息法" class="headerlink" title="2.2 确定信息法"></a>2.2 确定信息法</h4><p><strong>使用前提：</strong>选项信息不充分(不完成、不全面)</p><p><strong>使用方法：</strong>确认匹配/不匹配信息，整理标注(列表)</p><h4 id="2-3-最大信息法"><a href="#2-3-最大信息法" class="headerlink" title="2.3 最大信息法"></a>2.3 最大信息法</h4><p><strong>使用方法：</strong>将题目中出现次数最多的信息作为解题“突破口”</p><h4 id="2-4-假设法"><a href="#2-4-假设法" class="headerlink" title="2.4 假设法"></a>2.4 假设法</h4><p><strong>使用方法：</strong>当没有唯一推导路径时，假设某一种情况为真进行推导</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、翻译推理&quot;&gt;&lt;a href=&quot;#一、翻译推理&quot; class=&quot;headerlink&quot; title=&quot;一、翻译推理&quot;&gt;&lt;/a&gt;一、翻译推理&lt;/h2&gt;&lt;h3 id=&quot;1、题型识别&quot;&gt;&lt;a href=&quot;#1、题型识别&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="判断推理" scheme="https://schnappi618.github.io/categories/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/"/>
    
    
      <category term="考公" scheme="https://schnappi618.github.io/tags/%E8%80%83%E5%85%AC/"/>
    
      <category term="判断推理" scheme="https://schnappi618.github.io/tags/%E5%88%A4%E6%96%AD%E6%8E%A8%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Golang+VUE不定结构显示</title>
    <link href="https://schnappi618.github.io/2022/03/02/code/Golang-VUE%E4%B8%8D%E5%AE%9A%E7%BB%93%E6%9E%84%E6%98%BE%E7%A4%BA/"/>
    <id>https://schnappi618.github.io/2022/03/02/code/Golang-VUE%E4%B8%8D%E5%AE%9A%E7%BB%93%E6%9E%84%E6%98%BE%E7%A4%BA/</id>
    <published>2022-03-02T09:29:59.000Z</published>
    <updated>2022-03-03T06:12:32.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、需求背景"><a href="#一、需求背景" class="headerlink" title="一、需求背景"></a>一、需求背景</h2><p>需要实现一个在Web页面对数据库进行查询的功能，但由于查询语句不确定，查询结果字段也不确定。后端为Golang开发，前端使用VUE，Golang为强类型语言，并且会对数据库查出的结果进行二次数据结构类型调整，导致最终结果展示和数据库内部实际存储结果不同。</p><h2 id="二、问题"><a href="#二、问题" class="headerlink" title="二、问题"></a>二、问题</h2><ul><li>数据库类型：MySQL</li><li>Go版本：1.13.8</li><li>Go操作数据库包：Gorm</li><li>前端ui：element ui</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认根据获得到的类型，直接返回结果</span></span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">        values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line">object := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, column := <span class="keyword">range</span> columns &#123;</span><br><span class="line">object[column.Name()] = reflect.New(column.ScanType()).Interface()</span><br><span class="line">values[i] = object[column.Name()]</span><br><span class="line">&#125;</span><br><span class="line">    err = rows.Scan(values...)</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">append</span>(result, object)</span><br></pre></td></tr></table></figure><p>返回结果会出现时间类型、甚至int、varchar类型和数据库存储信息不一致情况，例如：</p><ul><li><p>数据库实际存储为：</p><p><img src="/2022/03/02/code/Golang-VUE%E4%B8%8D%E5%AE%9A%E7%BB%93%E6%9E%84%E6%98%BE%E7%A4%BA/1.jpg"></p></li><li><p>但调用显示结果为：</p></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">"data": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"col"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col100"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col2"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col27"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col3"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"col5"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col6"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"emp_no"</span>: <span class="number">10101</span>,</span><br><span class="line">        <span class="attr">"from_date"</span>: &#123;</span><br><span class="line">            <span class="attr">"Time"</span>: <span class="string">"1998-10-14T00:00:00+08:00"</span>,</span><br><span class="line">            <span class="attr">"Valid"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"iState"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">"salary"</span>: <span class="number">66591</span>,</span><br><span class="line">        <span class="attr">"to_date"</span>: &#123;</span><br><span class="line">            <span class="attr">"Time"</span>: <span class="string">"1999-10-14T00:00:00+08:00"</span>,</span><br><span class="line">            <span class="attr">"Valid"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"col"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col100"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col2"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col27"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col3"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"col5"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col6"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"emp_no"</span>: <span class="number">10101</span>,</span><br><span class="line">        <span class="attr">"from_date"</span>: &#123;</span><br><span class="line">            <span class="attr">"Time"</span>: <span class="string">"1999-10-14T00:00:00+08:00"</span>,</span><br><span class="line">            <span class="attr">"Valid"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"iState"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1001</span>,</span><br><span class="line">        <span class="attr">"salary"</span>: <span class="number">66715</span>,</span><br><span class="line">        <span class="attr">"to_date"</span>: &#123;</span><br><span class="line">            <span class="attr">"Time"</span>: <span class="string">"2000-09-23T00:00:00+08:00"</span>,</span><br><span class="line">            <span class="attr">"Valid"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><h4 id="1、后端"><a href="#1、后端" class="headerlink" title="1、后端"></a>1、后端</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">dsn := <span class="string">"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&amp;parseTime=True&amp;loc=Local"</span></span><br><span class="line">db, err := gorm.Open(mysql.Open(dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ExecuteSelectSQL</span><span class="params">(sql <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, []<span class="keyword">string</span>, []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> total <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> header []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> result []<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">rows, err := db.Raw(sql).Rows()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, errors.New(<span class="string">"select error"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> rows.Close()</span><br><span class="line">cols, err := rows.Columns()</span><br><span class="line">header = cols</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">columns, err := rows.ColumnTypes()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, header, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dbtypes := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">values := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="built_in">len</span>(columns))</span><br><span class="line">object := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, column := <span class="keyword">range</span> columns &#123;</span><br><span class="line">v := reflect.New(column.ScanType()).Interface()</span><br><span class="line"><span class="keyword">switch</span> v.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> *[]<span class="keyword">uint8</span>:</span><br><span class="line">v = <span class="built_in">new</span>(<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">case</span> *sql.RawBytes:</span><br><span class="line">v = <span class="built_in">new</span>(*<span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">case</span> *mysql.NullTime:</span><br><span class="line">v = <span class="built_in">new</span>(time.Time)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">// fmt.Printf("%v: %T", column.Name(), v)</span></span><br><span class="line">&#125;</span><br><span class="line">object[column.Name()] = v</span><br><span class="line"></span><br><span class="line">values[i] = object[column.Name()]</span><br><span class="line">dbtypes[column.Name()] = column.DatabaseTypeName()</span><br><span class="line">&#125;</span><br><span class="line">err = rows.Scan(values...)</span><br><span class="line"><span class="comment">//fmt.Println(dbtypes)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> cols &#123;</span><br><span class="line">vs, ok := values[i].(*time.Time)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> dbtypes[v] == <span class="string">"DATE"</span> &#123;</span><br><span class="line">object[v] = vs.Format(<span class="string">"2006-01-02"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">object[v] = vs.Format(<span class="string">"2006-01-02 15:04:05"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, header, <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">result = <span class="built_in">append</span>(result, object)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">total = <span class="built_in">len</span>(result)</span><br><span class="line"><span class="keyword">return</span> total, header, result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端返回结果示例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">"result": [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"col"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col100"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col2"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col27"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col3"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"col5"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col6"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"emp_no"</span>: <span class="number">10101</span>,</span><br><span class="line">        <span class="attr">"from_date"</span>: <span class="string">"1998-10-14"</span>,</span><br><span class="line">        <span class="attr">"iState"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">"salary"</span>: <span class="number">66591</span>,</span><br><span class="line">        <span class="attr">"to_date"</span>: <span class="string">"1999-10-14"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"col"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col100"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col2"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col27"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col3"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"col5"</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">"col6"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"emp_no"</span>: <span class="number">10101</span>,</span><br><span class="line">        <span class="attr">"from_date"</span>: <span class="string">"1999-10-14"</span>,</span><br><span class="line">        <span class="attr">"iState"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">1001</span>,</span><br><span class="line">        <span class="attr">"salary"</span>: <span class="number">66715</span>,</span><br><span class="line">        <span class="attr">"to_date"</span>: <span class="string">"2000-09-23"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">"header": [</span><br><span class="line">    "emp_no",</span><br><span class="line">    "salary",</span><br><span class="line">    "from_date",</span><br><span class="line">    "to_date",</span><br><span class="line">    "id",</span><br><span class="line">    "type",</span><br><span class="line">    "iState",</span><br><span class="line">    "col",</span><br><span class="line">    "col2",</span><br><span class="line">    "col27",</span><br><span class="line">    "col100",</span><br><span class="line">    "col3",</span><br><span class="line">    "col5",</span><br><span class="line">    <span class="string">"col6"</span></span><br><span class="line">],</span><br><span class="line">"total": 5</span><br></pre></td></tr></table></figure><h4 id="2、前端"><a href="#2、前端" class="headerlink" title="2、前端"></a>2、前端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&#x2F;&#x2F; 结果展示：header为字段信息，selectResult为查询结果列表</span><br><span class="line">          &lt;el-form-item label&#x3D;&quot;查询结果:&quot; prop&#x3D;&quot;sqlSelect&quot; :style&#x3D;this.sqlSelectResult&gt;</span><br><span class="line">            &lt;template&gt;</span><br><span class="line">              &lt;el-table :data&#x3D;&quot;selectResult&quot; style&#x3D;&quot;width: 100%&quot; &gt;</span><br><span class="line">                &lt;el-table-column v-for&#x3D;&quot;(date, index) in header&quot; :key&#x3D;&quot;index&quot;  :label&#x3D;&quot;date&quot; :prop&#x3D;&quot;date&quot; :width&#x3D;&quot;setColumnWidth(date)&quot;&gt;</span><br><span class="line">                  &lt;template slot-scope&#x3D;&quot;scope&quot;&gt;</span><br><span class="line">                    &#123;&#123;selectResult[scope.$index][date]&#125;&#125;</span><br><span class="line">                  &lt;&#x2F;template&gt;</span><br><span class="line">                &lt;&#x2F;el-table-column&gt;</span><br><span class="line">              &lt;&#x2F;el-table&gt;</span><br><span class="line">            &lt;&#x2F;template&gt;</span><br><span class="line">          &lt;&#x2F;el-form-item&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; methods中可以添加setColumnWidth，让显示更友好一些，字段名不会折行</span><br><span class="line"></span><br><span class="line">    setColumnWidth(str) &#123;</span><br><span class="line">      let columnWidth &#x3D; 0;</span><br><span class="line">      for (let char of str) &#123;</span><br><span class="line">        if ((char &gt;&#x3D; &#39;A&#39; &amp;&amp; char &lt;&#x3D; &#39;Z&#39;) || (char &gt;&#x3D; &#39;a&#39; &amp;&amp; char &lt;&#x3D; &#39;z&#39;)) &#123;</span><br><span class="line">          &#x2F;&#x2F; 如果是英文字符，为字符分配10个单位宽度，单位宽度可根据字体大小调整</span><br><span class="line">          columnWidth +&#x3D; 10</span><br><span class="line">        &#125; else if (char &gt;&#x3D; &#39;\u4e00&#39; &amp;&amp; char &lt;&#x3D; &#39;\u9fa5&#39;) &#123;</span><br><span class="line">          &#x2F;&#x2F; 如果是中文字符，为字符分配14个单位宽度，单位宽度可根据字体大小调整</span><br><span class="line">          columnWidth +&#x3D; 14</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; 其他种类字符，为字符分配10个单位宽度，单位宽度可根据字体大小调整</span><br><span class="line">          columnWidth +&#x3D; 10</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (columnWidth &lt; 120) &#123;</span><br><span class="line">        &#x2F;&#x2F; 设置最小宽度</span><br><span class="line">        columnWidth &#x3D; 160</span><br><span class="line">      &#125;</span><br><span class="line">      return columnWidth + &#39;px&#39;</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h4 id="3、最终页面显示效果"><a href="#3、最终页面显示效果" class="headerlink" title="3、最终页面显示效果"></a>3、最终页面显示效果</h4><p><img src="/2022/03/02/code/Golang-VUE%E4%B8%8D%E5%AE%9A%E7%BB%93%E6%9E%84%E6%98%BE%E7%A4%BA/2.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、需求背景&quot;&gt;&lt;a href=&quot;#一、需求背景&quot; class=&quot;headerlink&quot; title=&quot;一、需求背景&quot;&gt;&lt;/a&gt;一、需求背景&lt;/h2&gt;&lt;p&gt;需要实现一个在Web页面对数据库进行查询的功能，但由于查询语句不确定，查询结果字段也不确定。后端为Golan
      
    
    </summary>
    
    
    
      <category term="golang" scheme="https://schnappi618.github.io/tags/golang/"/>
    
      <category term="vue" scheme="https://schnappi618.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化之理解查询计划</title>
    <link href="https://schnappi618.github.io/2021/07/27/DB/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/"/>
    <id>https://schnappi618.github.io/2021/07/27/DB/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/</id>
    <published>2021-07-27T02:47:00.000Z</published>
    <updated>2021-08-09T02:52:48.684Z</updated>
    
    <content type="html"><![CDATA[<p>要进行数据库 SQL 优化必须先理解一条 SQL 具体是怎么执行的。MySQL 提供了 EXPLAIN 来描述优化器处理 SQL 的规则以及流程。本文会详细解释 EXPLAIN 各字段的含义以及不同结果所代表的意义，从而帮助理解查询计划，为 SQL 优化做基础。</p><h3 id="一、总览图"><a href="#一、总览图" class="headerlink" title="一、总览图"></a>一、总览图</h3><p><img src="/2021/07/27/DB/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/MySQL%20EXPLAIN.svg"></p><h3 id="二、EXPLAIN-概述"><a href="#二、EXPLAIN-概述" class="headerlink" title="二、EXPLAIN 概述"></a>二、EXPLAIN 概述</h3><p>EXPLAIN 中会解释 MySQL 是如何处理语句，包括表的连接方式以及处理顺序等信息。从 MySQL 5.6.3版本开始，EXPLAIN 可以分析SELECT、DELETE、INSERT、REPLACE 和 UPDATE 语句，在这之前，仅可以分析 SELECT 语句。</p><p>EXPLAIN 通常会跟具体语句来进行解析查看，也可以直接查看连接执行 SQL 情况。eg：<code>EXPLAIN for connection 403326;</code></p><p><code>Note: EXPLAIN tb_name;也可用来查看对应表中列信息，等同于SHOW COLUMNS FROM tb_name;</code></p><h3 id="三、EXPLAIN-输出格式"><a href="#三、EXPLAIN-输出格式" class="headerlink" title="三、EXPLAIN 输出格式"></a>三、EXPLAIN 输出格式</h3><h4 id="1、EXPLAIN-输出列"><a href="#1、EXPLAIN-输出列" class="headerlink" title="1、EXPLAIN 输出列"></a>1、EXPLAIN 输出列</h4><table><thead><tr><th><strong>列名</strong></th><th><strong>json 名称</strong></th><th><strong>意义</strong></th></tr></thead><tbody><tr><td>id</td><td>select_id</td><td>表 id 号</td></tr><tr><td>select_type</td><td>None</td><td>select 查询类型</td></tr><tr><td>table</td><td>table_name</td><td>表名</td></tr><tr><td>partitions</td><td>partitions</td><td>匹配的分区</td></tr><tr><td>type</td><td>access_type</td><td>连接类型</td></tr><tr><td>possible_keys</td><td>possible_keys</td><td>可能的索引选择</td></tr><tr><td>key</td><td>key</td><td>实际选择的索引</td></tr><tr><td>key_len</td><td>key_length</td><td>所选key的长度</td></tr><tr><td>ref</td><td>ref</td><td>与索引比较的列</td></tr><tr><td>rows</td><td>rows</td><td>估计需要扫描的行数</td></tr><tr><td>filtered</td><td>filtered</td><td>按表条件过滤的行的百分比</td></tr><tr><td>Extra</td><td>None</td><td>附加信息</td></tr></tbody></table><h4 id="2、各列详解"><a href="#2、各列详解" class="headerlink" title="2、各列详解"></a>2、各列详解</h4><p>以下 SQL 示范数据均来自于官方提供的 employees 库，可<a href="https://dev.mysql.com/doc/employee/en/employees-installation.html" target="_blank" rel="noopener">点击</a>下载测试数据</p><h5 id="2-1-id-JSON-name-select-id"><a href="#2-1-id-JSON-name-select-id" class="headerlink" title="2.1 id(JSON name: select_id)"></a>2.1 id(JSON name: select_id)</h5><p>一般查询语句都以 SELECT 关键字开头，查询中每出现一个 SELECT 关键字，MySQL就会为其分配一个唯一的 id 值。这个值就是 EXPLAIN 结果的第一列。例如下面的简单查询只有一个 SELECT 关键字，所以 EXPLAIN 的结果就只有 id 为 1 的一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from departments where dept_no = 'd009';</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table       | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | departments | NULL       | const | PRIMARY       | PRIMARY | 12      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>对于连接查询来说，一个 SELECT 语句之后的 FROM 可能会有多个表，在执行计划中，每张表都会有一条记录，但这些记录的 id 号是相同的。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from dept_manager inner join departments using(dept_no);</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+-----------+---------+-------------------------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys | key       | key_len | ref                           | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+-----------+---------+-------------------------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | departments  | NULL       | index | PRIMARY       | dept_name | 122     | NULL                          |    9 |   100.00 | Using index |</span><br><span class="line">|  1 | SIMPLE      | dept_manager | NULL       | ref   | dept_no       | dept_no   | 12      | employees.departments.dept_no |    2 |   100.00 | NULL        |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+-----------+---------+-------------------------------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>在上述<code> id 相同的情况下，出现在前面的表会先被执行</code>，这张表被称为驱动表，后面的表叫做被驱动表。所以从上面的结果来看，优化器打算让 departments 表做为驱动表，让 dept_manager 表做为被驱动表。</p><p>对于包含子查询的语句可能会涉及到多个 SELECT 关键字，所以在包含子查询的查询执行计划中，每个 SELECT 关键字都会对应一个独立的 id 号。<code>在多个 id 值的情况下，id 值越大的会先执行</code>。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from dept_manager where dept_no in (select dept_no from departments where dept_no &lt; 'd015') or from_date &lt; '2000-01-01';</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">|  1 | PRIMARY     | dept_manager | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |   24 |   100.00 | Using where              |</span><br><span class="line">|  2 | SUBQUERY    | departments  | NULL       | range | PRIMARY       | PRIMARY | 12      | NULL |    9 |   100.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>但有时 MySQL 会将 in 子查询重写为连接查询，可通过 EXPLAIN 的 id 是否相同以及 show warnings 的结果来了解是否进行了重写。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from dept_manager where dept_no in (select dept_no from departments where dept_no &lt; 'd015');</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+-------------------------------+------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys | key     | key_len | ref                           | rows | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+-------------------------------+------+----------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | departments  | NULL       | range | PRIMARY       | PRIMARY | 12      | NULL                          |    9 |   100.00 | Using where; Using index |</span><br><span class="line">|  1 | SIMPLE      | dept_manager | NULL       | ref   | dept_no       | dept_no | 12      | employees.departments.dept_no |    2 |   100.00 | NULL                     |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+-------------------------------+------+----------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`emp_no`</span> <span class="keyword">AS</span> <span class="string">`emp_no`</span>,<span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`dept_no`</span> <span class="keyword">AS</span> <span class="string">`dept_no`</span>,<span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`from_date`</span> <span class="keyword">AS</span> <span class="string">`from_date`</span>,<span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`to_date`</span> <span class="keyword">AS</span> <span class="string">`to_date`</span> <span class="keyword">from</span> <span class="string">`employees`</span>.<span class="string">`departments`</span> <span class="keyword">join</span> <span class="string">`employees`</span>.<span class="string">`dept_manager`</span> <span class="keyword">where</span> ((<span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`dept_no`</span> = <span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_no`</span>) <span class="keyword">and</span> (<span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_no`</span> &lt; <span class="string">'d015'</span>))</span><br></pre></td></tr></table></figure><p>可以看到，上述虽然 SQL 中包含了子查询，但两条记录 id 都为1，并且可以看到 SQL 被写为了连接查询。</p><h5 id="2-2-select-type"><a href="#2-2-select-type" class="headerlink" title="2.2 select_type"></a>2.2 select_type</h5><p>MySQL 为每个 SELECT 子查询都定义了 select_type 的属性，根据这个属性就可以快速知道该子查询在整体查询中扮演的角色。</p><p>常见的类型如下：</p><ul><li>SIMPLE<ul><li>查询中不包含子查询或者 UNION 查询的都属于 SIMPLE 类型。单表查询和连接查询都属于该类型</li></ul></li><li>PRIMARY<ul><li>对于包含 UNION、子查询等 SQL 来说，它是由小查询组成。其中最左边或最外层的查询会被标记为 PRIMARY 类型</li></ul></li><li>UNION<ul><li>对于包含 UNION、UNION ALL 的查询，除了最左边的查询，其余的小查询均被标记为 UNION 类型</li></ul></li><li>UNION RESULT<ul><li>对于 UNION 查询来说，MySQL 会在内部创建一个临时表并对结果进行去重操作。针对该临时表的查询操作会被标记为 UNION RESULT类型</li></ul></li><li>SUBQUERY<ul><li>包含子查询的查询语句不能转换为半连接(semi-join)的形式，并且该查询是不相关子查询，查询优化器会将该子查询物化。此时子查询对应的第一个 SELECT 关键字的查询则被标记为 SUBQUERY</li><li>非相关子查询是独立于外部查询的子查询，子查询总共执行一次，执行完毕后将值传递给外部查询</li><li>相关子查询的执行依赖于外部查询的数据，外部查询执行一行，子查询就执行一次</li><li>非相关子查询比相关子查询效率高</li></ul></li><li>DEPENDENT SUBQUERY<ul><li>包含子查询的查询语句不能转换为半连接(semi-join)的形式，并且该查询是相关子查询。该子查询的第一个 SELECT 关键字对应的类型则为 DENENDENT SUBQUERY。该子查询可能会被执行多次</li></ul></li><li>DERIVED<ul><li>采用物化子查询的方式执行的包含派生表的查询。该派生表对应子查询的类型为 DERIVED</li></ul></li><li>MATERIALIZED<ul><li>对于包含子查询的 SQL，优化器选择将子查询物化之后和外层查询进行连接查询时，该子查询对应的类型为 MATERIALIZED</li></ul></li></ul><h5 id="2-3-table-JSON-name-table-name"><a href="#2-3-table-JSON-name-table-name" class="headerlink" title="2.3 table(JSON name: table_name)"></a>2.3 table(JSON name: table_name)</h5><p>每行所涉及的表的名称。有以下一些特殊的值：</p><ul><li>&lt;unionM, N&gt;：EXPLAIN 结果中 id 为 M 和 N 的两条记录结果并集的临时表，一般用于 UNION 去重</li><li>&lt;derivedN&gt;：EXPLAIN 结果中 id 为 N 的行的派生表结果。派生表一般指 FROM 子句中的子查询</li><li>&lt;subqueryN&gt;：EXPLAIN 结果中对 id 为 N 的行的物化子查询的结果</li></ul><h5 id="2-4-partitions-JSON-name-partitions"><a href="#2-4-partitions-JSON-name-partitions" class="headerlink" title="2.4 partitions(JSON name: partitions)"></a>2.4 partitions(JSON name: partitions)</h5><p>分区表中查询匹配记录的分区。未使用分区表该值为 NULL</p><h5 id="2-5-type-JSON-name-access-type"><a href="#2-5-type-JSON-name-access-type" class="headerlink" title="2.5 type(JSON name: access_type)"></a>2.5 type(JSON name: access_type)</h5><p>表示 MySQL 对某个表的访问方法。完整的访问方法包含：NULL、system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、index_subquery、range、index、ALL。常见访问方式如下：</p><ul><li><p>NULL</p><p>MySQL 不用访问索引或表就可以获得结果。例如：<code>SELECT sysdate();</code></p></li><li><p>system</p><p>表中只有一条记录并且存储引擎的统计信息是准确的。例如使用了 MyISAM 引擎的表的统计信息是准确的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一张测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_aoe`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'name'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'aoe'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入一条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_aoe(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'aaa'</span>);</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t_aoe;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | t_aoe | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">`employees`</span>.<span class="string">`t_aoe`</span>.<span class="string">`id`</span> <span class="keyword">AS</span> <span class="string">`id`</span>,<span class="string">`employees`</span>.<span class="string">`t_aoe`</span>.<span class="string">`name`</span> <span class="keyword">AS</span> <span class="string">`name`</span> <span class="keyword">from</span> <span class="string">`employees`</span>.<span class="string">`t_aoe`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 引擎改为 MyISAM 引擎</span></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">alter</span> <span class="keyword">table</span> t_aoe <span class="keyword">engine</span> = MyISAM;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t_aoe;      </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | t_aoe | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">'1'</span> <span class="keyword">AS</span> <span class="string">`id`</span>,<span class="string">'aaa'</span> <span class="keyword">AS</span> <span class="string">`name`</span> <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure><p>可以看到当存储引擎是 MyISAM 统计信息准确并且表中只有一条记录时，type 为 system，而为 InnoDB 这类估算的统计信息时，type 为 ALL。</p></li><li><p>const</p><p>根据主键或唯一索引与常量进行等值比较时，会使用 const 访问方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;explain select * from departments where dept_no = 'd009';</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table       | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | departments | NULL       | const | PRIMARY       | PRIMARY | 12      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">'d009'</span> <span class="keyword">AS</span> <span class="string">`dept_no`</span>,<span class="string">'Customer Service'</span> <span class="keyword">AS</span> <span class="string">`dept_name`</span> <span class="keyword">from</span> <span class="string">`employees`</span>.<span class="string">`departments`</span> <span class="keyword">where</span> (<span class="string">'d009'</span> = <span class="string">'d009'</span>)</span><br></pre></td></tr></table></figure></li><li><p>eq_ref</p><p>进行连表查询时，被驱动表是通过主键或折唯一索引的方式来进行访问，则会使用 eq_ref 这种访问方式。如果主键或唯一索引是联合索引，则所有字段都必须是等值比较。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from departments inner join dept_emp on departments.dept_no = dept_emp.dept_no and dept_emp.emp_no = 1; </span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+--------+-----------------+---------+---------+----------------------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table       | partitions | type   | possible_keys   | key     | key_len | ref                        | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+--------+-----------------+---------+---------+----------------------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | dept_emp    | NULL       | ref    | PRIMARY,dept_no | PRIMARY | 4       | const                      |    1 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | departments | NULL       | eq_ref | PRIMARY         | PRIMARY | 12      | employees.dept_emp.dept_no |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+--------+-----------------+---------+---------+----------------------------+------+----------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_no`</span> <span class="keyword">AS</span> <span class="string">`dept_no`</span>,<span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_name`</span> <span class="keyword">AS</span> <span class="string">`dept_name`</span>,<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`emp_no`</span> <span class="keyword">AS</span> <span class="string">`emp_no`</span>,<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`dept_no`</span> <span class="keyword">AS</span> <span class="string">`dept_no`</span>,<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`from_date`</span> <span class="keyword">AS</span> <span class="string">`from_date`</span>,<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`to_date`</span> <span class="keyword">AS</span> <span class="string">`to_date`</span> <span class="keyword">from</span> <span class="string">`employees`</span>.<span class="string">`departments`</span> <span class="keyword">join</span> <span class="string">`employees`</span>.<span class="string">`dept_emp`</span> <span class="keyword">where</span> ((<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`emp_no`</span> = <span class="number">1</span>) <span class="keyword">and</span> (<span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_no`</span> = <span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`dept_no`</span>))</span><br></pre></td></tr></table></figure></li><li><p>ref</p><p>通过普通的二级索引与常量进行等值匹配时来访问某个表。</p></li><li><p>ref_or_null</p><p>和 ref 类似，只不过索引列的值可以为 NULL，则可能使用 ref_or_null 访问方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t1 表结构如下，并且已经写入部分数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`salary`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`iState`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`col`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'col'</span>,</span><br><span class="line">  <span class="string">`col2`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'col2'</span>,</span><br><span class="line">  <span class="string">`col27`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'col4'</span>,</span><br><span class="line">  <span class="string">`col100`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'这里是该列的注释内容'</span>,</span><br><span class="line">  <span class="string">`col3`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'col3'</span>,</span><br><span class="line">  <span class="string">`col5`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'col5'</span>,</span><br><span class="line">  <span class="string">`col6`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'col6'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_emp_no`</span> (<span class="string">`emp_no`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_salary`</span> (<span class="string">`salary`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_col2`</span> (<span class="string">`col2`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">11376198</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where col2 = 'lcl' or col2 is null;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+---------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows    | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+---------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref_or_null | idx_col2      | idx_col2 | 99      | const | 5523271 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+---------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>index_merge</p><p>在有些 SQL 中，一个查询可能会使用到多个二级索引，这种优化的方式被称为索引合并，但索引合并有时不一定比全表查询快。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from t1 where emp_no = 10000 or salary = 2000;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+-------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                           |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+-------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index_merge | idx_emp_no,idx_salary | idx_emp_no,idx_salary | 4,4     | NULL |    2 |   100.00 | Using union(idx_emp_no,idx_salary); Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+-------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>unique_subquery</p><p>这是针对一些包含 IN 的子查询的 SQL 语句，如果优化器将 IN 改写为 EXISTS 子查询，而且子查询可以用到主键或唯一索引进行匹配，该子查询会为 unique_subquery 类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 子句中类似于以下格式</span></span><br><span class="line">  value IN (<span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> emp_no <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> t1.id &gt; <span class="number">10000</span>) <span class="keyword">or</span> birth_date &gt; <span class="string">'1990-01-01'</span>;           </span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+-----------------+---------------+---------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">| id | select_type        | table     | partitions | type            | possible_keys | key     | key_len | ref  | rows   | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+-----------------+---------------+---------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">|  1 | PRIMARY            | employees | NULL       | ALL             | NULL          | NULL    | NULL    | NULL | 299478 |   100.00 | Using where              |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | t1        | NULL       | unique_subquery | PRIMARY       | PRIMARY | 8       | func |      1 |   100.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+-----------------+---------------+---------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>index_subquery</p><p>和unique_subquery类似，只不过子查询使用的是普通索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">value IN (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> emp_no <span class="keyword">in</span> (<span class="keyword">select</span> emp_no <span class="keyword">from</span> t1 <span class="keyword">where</span> t1.emp_no &gt; <span class="number">10000</span>) <span class="keyword">or</span> birth_date &gt; <span class="string">'1990-01-01'</span>; </span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+----------------+---------------+------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">| id | select_type        | table     | partitions | type           | possible_keys | key        | key_len | ref  | rows   | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+----------------+---------------+------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">|  1 | PRIMARY            | employees | NULL       | ALL            | NULL          | NULL       | NULL    | NULL | 299478 |   100.00 | Using where              |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | t1        | NULL       | index_subquery | idx_emp_no    | idx_emp_no | 4       | func |     29 |   100.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+----------------+---------------+------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>range</p><p>使用索引查询记录，并且返回在给定范围内的结果。key 字段会表明使用的索引，key_len 表示用的的索引中最长字段的长度。</p><p>range 在一个索引列和常量进行一些比较操作时比较常见。例如：=、&lt;&gt;、&gt;、≥、&lt;、≤、IS NULL、&lt;=&gt;、BETWEEN、IN() 等</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一般为以下格式有可能为range类型</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 = <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子：</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where emp_no between 10000 and 20000;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+--------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows   | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+--------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_emp_no    | idx_emp_no | 4       | NULL | 792594 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+--------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> emp_no <span class="keyword">in</span> (<span class="number">10000</span>,<span class="number">10010</span>,<span class="number">10020</span>); </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_emp_no    | idx_emp_no | 4       | NULL |   34 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> titles <span class="keyword">where</span> emp_no = <span class="number">10000</span> <span class="keyword">and</span> title <span class="keyword">in</span> (<span class="string">'Senior Engineer'</span>, <span class="string">'Staff'</span>, <span class="string">'Engineer'</span>);</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 156     | NULL |    3 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>index</p><p>可以使用覆盖索引，但需要扫描全部的索引记录。一般用于以下两种情况：</p><ul><li>如果是覆盖索引，可以满足所有需要的数据，也就是说查询列都为索引中的字段。这种情况下只需要扫描索引树即可，Extra 列会显示 Using index. 索引扫描一般比 ALL 全表扫描快一些，因为索引大小通常都小于表数据。</li><li>全表扫描是使用从索引中读取的记录(以索引的顺序)查找数据记录。Extra 列不显示 Using index。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select col2 from t1 where col2 = 2000; </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+----------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows     | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+----------+----------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | idx_col2      | idx_col2 | 99      | NULL | 11046540 |    10.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+----------+----------+--------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">3</span> <span class="keyword">warnings</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>ALL</p><p>全表扫描。对前表中的每个行组合进行全表扫描。如果该表是驱动表并且未标记为 const，那么性能通常会很慢。一般可以通过添加索引避免全表扫描。</p></li></ul><h5 id="2-6-possible-keys-JSON-name-possible-keys"><a href="#2-6-possible-keys-JSON-name-possible-keys" class="headerlink" title="2.6 possible_keys(JSON name: possible_keys)"></a>2.6 possible_keys(JSON name: possible_keys)</h5><p>possible_keys 列显示了 MySQL 在查找记录时可能使用到的索引，这个值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本就需要花费更多的时间，可以尽量删除那些不使用的索引。</p><p>如果这列为 NULL (JSON 格式中为 undefined)，说明这个查询没有可用的索引。这种情况可以检查 where 子句中使用的列，查看是否可以创建合适的索引，改进查询性能。</p><h5 id="2-7-key-JSON-name-key"><a href="#2-7-key-JSON-name-key" class="headerlink" title="2.7 key(JSON name: key)"></a>2.7 key(JSON name: key)</h5><p>key 列显示了 MySQL 在查询过程中实际使用到的索引。如果 MySQL 决定使用 possible_keys 中列出的索引，则会在 key 中显示。当使用到了覆盖索引，则只会在 key 列中显示。如果为 NULL 的话则表示没有找到合适的索引。想要强制使用或忽略在 possible_keys 中列出的某个索引，可以使用 FORCE INDEX、USE INDEX 或者 IGNORE INDEX。</p><h5 id="2-8-key-len-JSON-name-key-length"><a href="#2-8-key-len-JSON-name-key-length" class="headerlink" title="2.8 key_len(JSON name: key_length)"></a>2.8 key_len(JSON name: key_length)</h5><p>key_len 表示了当优化器决定使用哪个索引执行查询时，索引记录的最大长度。它由以下三部分组成：</p><ul><li>对于使用固定长度的索引来说，实际占用的存储空间最大长度就是一个固定值。但对于指定了字符集的变长类型的索引列来说，为该变长类型的最大长度。例如：某个索引列的类型是 varchar(100)，使用了 utf8 字符集，那么该列实际占用的最大存储空间是 <code>100 * 3 = 300</code>个字节</li><li>如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值是多 1 个字节</li><li>对于变长字段来说，都会提供 2 个字节的空间来存储变长列的实际长度</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id为bigint类型，且为 NOT NULL不允许存储NULL值，可看到 key_len 为 8</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where id = 1000;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- col2 为 varchar(32)，默认值为NULL，字符集为 utf8，key_len = 32 * 3 + 1 + 2 = 99</span></span><br><span class="line">(dba:<span class="number">5011</span>)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> col2 = <span class="string">'test'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_col2      | idx_col2 | 99      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>在 InnoDB 中，存储变长字段的长度为 1～2 个字节，EXPLAIN 直接使用了 2 字节来表示，是由于 MySQL EXPLAIN 并不会真实去引擎层执行查询，而是属于 Server 层的功能，更主要是让人们可以<strong>准确的知道联合索引情况下实际到底是用了几个索引字段</strong>。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以官方提供的 employees 测试库中的 titles 表为例</span></span><br><span class="line"><span class="comment">-- 在 titles 表中，存在一个联合主键：PRIMARY KEY (`emp_no`,`title`,`from_date`)，表结构如下：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`titles`</span> (</span><br><span class="line">  <span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`title`</span>,<span class="string">`from_date`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`titles_ibfk_1`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>) <span class="keyword">REFERENCES</span> <span class="string">`_employees_old`</span> (<span class="string">`emp_no`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- emp_no 为 int 类型，且不可以为 NULL，所以只使用 emp_no 索引列，此时 key_len = 4</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from titles where emp_no = 10000;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 emp_no 和 title 列联合进行查询，emp_no 占用 4 字节，对应 key_len1 = 4</span></span><br><span class="line"><span class="comment">-- title 为 varchar(50)，是变长字段，字符集为 utf8，不可以为 NULL，所以对应 key_len2 = 50 * 3 + 2 = 152</span></span><br><span class="line"><span class="comment">-- 最终的 key_len = key_len1 + key_len2 = 156</span></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> titles <span class="keyword">where</span> emp_no = <span class="number">10000</span> <span class="keyword">and</span> title = <span class="string">'engines'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 156     | const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="2-9-ref-JSON-name-ref"><a href="#2-9-ref-JSON-name-ref" class="headerlink" title="2.9 ref(JSON name: ref)"></a>2.9 ref(JSON name: ref)</h5><p>当 type 为 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery ，使用索引列等值匹配的条件来进行查询时，ref 列表示和索引字段进行匹配的内容类型。一般为一个常数或某个字段列。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ref 为 const，表示和索引列 emp_no 进行比较的是一个常数</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from titles where emp_no = 10000;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ref 为 employees.employees.emp_no，说明和 t1 表 idx_emp_no 索引字段匹配查找的条件是 employees 库 employees 表的 emp_no 字段列</span></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">inner</span> <span class="keyword">join</span> t1 <span class="keyword">using</span> (emp_no);</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------------+---------+----------------------------+--------+----------+-------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key        | key_len | ref                        | rows   | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------------+---------+----------------------------+--------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | ALL  | PRIMARY       | NULL       | NULL    | NULL                       | 299478 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ref  | idx_emp_no    | idx_emp_no | 4       | employees.employees.emp_no |     29 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------------+---------+----------------------------+--------+----------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="2-10-rows-JSON-name-rows"><a href="#2-10-rows-JSON-name-rows" class="headerlink" title="2.10 rows(JSON name: rows)"></a>2.10 rows(JSON name: rows)</h5><p>优化器认为的预计使用的行数。对于 InnoDB 索引来说，这是个预估值。如果使用索引来执行查询，仅表示预计扫描的索引记录行数。</p><h5 id="2-11-filtered-JSON-name-filtered"><a href="#2-11-filtered-JSON-name-filtered" class="headerlink" title="2.11 filtered(JSON name: filtered)"></a>2.11 filtered(JSON name: filtered)</h5><p>预估被表条件过滤的记录比例。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from t1 where emp_no &lt; 8000 and from_date &gt; '1990-01-01'; </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_emp_no    | idx_emp_no | 4       | NULL |    9 |    33.33 | Using index condition; Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>从上面示例可以看出，该条 SQL 使用了 idx_emp_no 索引，MySQL 预计满足 emp_no &lt; 8000 的条数为 9 条，filtered 就表示在这 9 条记录中，有多少记录满足剩余的匹配条件，也就是说优化器预测在这 9 条记录中满足 from_date &gt; ‘1990-01-01’ 这个条件的百分比为 33.33%。</p><p>这个参数主要是针对于连表查询，可以大概知道对被驱动表的查询次数。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from employees inner join t1 on employees.emp_no = t1.id where t1.col2 = 'test'; </span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+------------------+----------+---------+-----------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type   | possible_keys    | key      | key_len | ref             | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+------------------+----------+---------+-----------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ref    | PRIMARY,idx_col2 | idx_col2 | 99      | const           |   90 |   100.00 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | eq_ref | PRIMARY          | PRIMARY  | 4       | employees.t1.id |    1 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+------------------+----------+---------+-----------------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>从上述执行计划可以看到，MySQL 是准备将 t1 表做为驱动表，employees 表做为被驱动表，驱动表 t1 的 rows 为 99，filtered 列为 100%，这表明我们大概需要对被驱动表 employees 执行大约 <code>99 * 100% = 99</code>次查询。</p><h5 id="2-12-Extra"><a href="#2-12-Extra" class="headerlink" title="2.12 Extra"></a>2.12 Extra</h5><p>Extra 用来描述一些其余的额外补充信息。完整信息可查看<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">官方文档</a>，常见的如下：</p><ul><li><p>Impossible Where</p><p>查询条件永远为 false，会提示该信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from t1 where 1 = 2;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>Using index</p><p>表示可以使用覆盖索引的情况</p></li><li><p>Index Condition Pushdown</p><p>在同个索引中，多个索引字段都使用了范围查询时，后面的范围查询无法使用到索引优化查询。早期 MySQL 需要回表找到完整记录后再进行条件判断，再将符合条件的记录加入到结果集中。InnoDB 后面通过在索引中判断符合记录是否符合查询条件，如果这个条件不满足，就不会进入回表流程。由于回表操作是随机 I/O，比较耗时，这样改进省略了一些回表操作，这个优化被称为 Index Condition Pushdown(索引条件下推)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于 col2条件均为范围查询，第一个条件之后本身第二个条件无法使用索引，但使用索引条件下推优化，省去了部分回表操作</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where col2 &gt; 'a' and col2 like '%test%';  </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_col2      | idx_col2 | 99      | NULL |   97 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>Using where</p><p>当 SQL 中包含 Where 条件无法使用到索引的情况，Extra 列中会出现 Using where 信息。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- col 列无索引，需要进行全表扫描</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where col = 'test';                     </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 11046540 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- col2 列有索引，并且会走对应索引，col 列无索引</span></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">col</span> = <span class="string">'test'</span> <span class="keyword">and</span> col2 = <span class="string">'test'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_col2      | idx_col2 | 99      | const |   90 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>Using join buffer(Block Nested Loop)</p><p>Join 的原理相当于先筛选出驱动表符合条件的记录，再通过连接条件逐条对被驱动表进行筛选，当表数据量比较大并且无法使用到有效索引时，需要不断地对被驱动表进行重复匹配。MySQL 针对这种情况提供了一个 join buffer 的内存空间来提高查询效率。将若干条驱动表的记录装在 join buffer 中，每条被驱动表的记录一次性和 join buffer 中的所有结果做匹配。这种算法也叫做<code>基于块的嵌套循环算法</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from employees inner join t1 on employees.birth_date = t1.from_date;    </span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   299478 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 11046540 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>从上面示例可以看出，使用 employees 表做为驱动表，t1 表做为被驱动表，由于无法使用到索引，使用了 join buffer 减少对 t1 表的访问次数，提高查询效率。在访问 t1 表时，满足驱动表 employees 条件的记录已经确定，所以每次对 t1 表的判断其实是 <code>t1.from_date = 常量</code>，在 Extra 中还会显示 Using where 信息。</p></li><li><p>Not exists</p><p>当使用外连接时，条件中包含被驱动表为 NULL 值的搜索条件，但字段禁止为 NULL 时，会提示 Not exists 附加信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t1 表的 id 字段为自增主键，不能为 NULL</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from employees left join t1 on employees.birth_date = t1.from_date where t1.id is NULL;  </span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra                                                          |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   299478 |   100.00 | NULL                                                           |</span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 11046540 |    10.00 | Using where; Not exists; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li><li><p>Using filesort</p><p>排序操作无法使用到索引时，只能在内存或磁盘中进行排序，在内存或磁盘上进行排序的操作统称为 filesort。如果查询数据量比较大，并且需要使用 filesort 排序，一般性能是比较低的，需要尽量为排序字段添加索引避免 filesort。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from employees inner join t1 on employees.emp_no = t1.emp_no order by t1.from_date limit 5;</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+---------------+---------+---------+---------------------+----------+----------+----------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type   | possible_keys | key     | key_len | ref                 | rows     | filtered | Extra          |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+---------------+---------+---------+---------------------+----------+----------+----------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ALL    | idx_emp_no    | NULL    | NULL    | NULL                | 11046540 |   100.00 | Using filesort |</span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | employees.t1.emp_no |        1 |   100.00 | NULL           |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+---------------+---------+---------+---------------------+----------+----------+----------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><img src="/2021/07/27/DB/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/filesort_1.jpg"></p><p><img src="/2021/07/27/DB/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/filesort_2.jpg"></p><p>可以看出，通过索引字段排序和使用 filesort 排序查询效率差异非常大。</p></li><li><p>Using temporary</p><p>对于一些包含 distinct、group by、union 等子句的查询，如果不能使用索引来进行查询，MySQL 会借助临时表来完成查询、去重、排序等功能。如果查询过程中使用到了临时表，则会提示 Using temporary 信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- col列不是 t1 表的索引字段</span></span><br><span class="line">(mysql)@[employees]&gt;explain select col from t1 group by col;  </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+---------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra                           |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+---------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 11046540 |   100.00 | Using temporary; Using filesort |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+---------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>可以看出，上述 Extra 列不仅出现了 Using temporary，还出现了 Using filesort。这是由于在 MySQL 中，group by 查询会默认添加上 order by 子句，如果不想进行排序，需要我们显式添加 <code>order by NULL</code>子句，避免查询时排序产生的成本。建立和维护临时表的成本非常大，对 SQL 执行效率有比较大的影响，尽量通过索引来替换掉临时表的使用。</p></li></ul><hr><p><strong>参考 《MySQL 是怎样运行的：从根儿上理解 MySQL》 作者:小孩子4919</strong></p><p><strong>参考 《MySQL 官方文档</strong>》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要进行数据库 SQL 优化必须先理解一条 SQL 具体是怎么执行的。MySQL 提供了 EXPLAIN 来描述优化器处理 SQL 的规则以及流程。本文会详细解释 EXPLAIN 各字段的含义以及不同结果所代表的意义，从而帮助理解查询计划，为 SQL 优化做基础。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://schnappi618.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://schnappi618.github.io/tags/MySQL/"/>
    
      <category term="Optimization" scheme="https://schnappi618.github.io/tags/Optimization/"/>
    
      <category term="EXPLAIN" scheme="https://schnappi618.github.io/tags/EXPLAIN/"/>
    
  </entry>
  
  <entry>
    <title>MySQL备份恢复</title>
    <link href="https://schnappi618.github.io/2021/04/08/DB/MySQL%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"/>
    <id>https://schnappi618.github.io/2021/04/08/DB/MySQL%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/</id>
    <published>2021-04-08T03:16:30.000Z</published>
    <updated>2021-07-27T07:11:19.845Z</updated>
    
    <content type="html"><![CDATA[<p>对个人乃至企业来说，数据都是至关重要的。不小心丢失或误操作都会造成不可估量的损失，但对数据的操作是无法避免的。数据损坏之后如何补救则成为了数据运维中非常重要的一部分。本文通过常用的 MySQL 数据库介绍数据的备份恢复基础概念及具体操作。</p><p><strong>本文主要分为以下三部分：</strong></p><ol><li><p>数据备份</p></li><li><p>数据恢复</p></li><li><p>总结</p></li></ol><h3 id="一、数据备份"><a href="#一、数据备份" class="headerlink" title="一、数据备份"></a>一、数据备份</h3><h4 id="1-1-数据备份的意义"><a href="#1-1-数据备份的意义" class="headerlink" title="1.1 数据备份的意义"></a>1.1 数据备份的意义</h4><p>对数据的威胁通常很难提前预知防范。数据备份的作用就在于灾难发生后，可通过备份数据完整、快速、简单、可靠的恢复原有数据。</p><p>完整的备份系统包含备份数据的管理以及数据的全面恢复，专业的备份系统不仅保证了数据的正确性、有效性、安全性，也是防止主动型信息攻击的一道防线。</p><h4 id="1-2-数据备份的分类"><a href="#1-2-数据备份的分类" class="headerlink" title="1.2 数据备份的分类"></a>1.2 数据备份的分类</h4><p>数据备份从不同的维度可区分为以下内容：</p><ol><li><p>根据<strong>备份类型</strong>区分：</p><ul><li>热备：在数据库运行过程中直接备份，不会影响正在运行的数据库。MySQL 官方手册中称之为 Online Backup (在线备份)</li><li>冷备：在数据库停止的状态下备份，一般只需要拷贝相关的数据物理文件即可。MySQL 官方手册中称之为 Offline Backup (离线备份)</li><li>温备：在数据库运行过程中备份，但会对当前数据库的操作产生影响，例如添加一个全局读锁保证备份数据的一致性</li></ul></li><li><p>根据<strong>备份方式</strong>区分：</p><ul><li>逻辑备份：备份表内具体数据，一般备份为可读的 SQL 文件。例如：mysqldump、into outfile 等方式</li><li>物理备份：基于数据文件进行备份。例如：cp、xtrabackup 等方式</li></ul></li><li><p>根据<strong>备份策略</strong>区分：</p><ul><li>全量备份：备份整个数据库数据</li><li>增量备份：备份上一次备份(全量或增量备份)以后的变化数据</li><li>差异备份：备份上一次全量备份以后的变化数据</li></ul></li></ol><p><img src="/2021/04/08/DB/MySQL%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/1.png" alt="不同备份策略优缺点"></p><h4 id="1-3-数据备份的方式"><a href="#1-3-数据备份的方式" class="headerlink" title="1.3 数据备份的方式"></a>1.3 数据备份的方式</h4><p>MySQL 官方及第三方都提供了不同的备份方法，常见的备份方式主要为以下几种：</p><p><img src="/2021/04/08/DB/MySQL%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/2.png" alt="img"></p><p>Percona xtrabackup 以其备份快速可靠、数据压缩节省磁盘空间、更短的恢复时间等优势获得了人们的青睐。xtrabackup 可通过下面命令进行数据库的全量备份：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">./bin/innobackupex \</span><br><span class="line">--defaults-file=/path/to/dbconfig/my.cnf \</span><br><span class="line">--user=db_user \</span><br><span class="line">--password=db_pass \</span><br><span class="line">--socket=/path/to/socket/mysql.sock \</span><br><span class="line">--compress \</span><br><span class="line">--compress-threads=4 \</span><br><span class="line">--parallel=4 \</span><br><span class="line">/MySQL_BACKUP/</span><br></pre></td></tr></table></figure><p>其余备份命令参数可参考 <a href="https://www.percona.com/software/mysql-database/percona-xtrabackup" target="_blank" rel="noopener">Percona-xtrabackup 官网</a></p><h3 id="二、数据恢复"><a href="#二、数据恢复" class="headerlink" title="二、数据恢复"></a>二、数据恢复</h3><h4 id="2-1数据恢复的方法"><a href="#2-1数据恢复的方法" class="headerlink" title="2.1数据恢复的方法"></a>2.1数据恢复的方法</h4><p>在 MySQL 中一般基于全量备份 + binlog 日志的方式恢复出一份有效可靠的数据，但不同的故障场景下需要恢复出的数据需求则可能不同。例如：机器故障后需要全量恢复数据库实例；针对某些表发生了误操作则恢复对应表即可，使业务尽快获得一份完整的正确数据，减少故障时间。</p><p>下面以 Percona xtrabackup 备份工具为例描述如何进行数据的恢复操作。</p><h4 id="2-2-全量恢复和单表恢复"><a href="#2-2-全量恢复和单表恢复" class="headerlink" title="2.2 全量恢复和单表恢复"></a>2.2 全量恢复和单表恢复</h4><p>使用 Percona 工具备份会得到下图中所列的数据文件。</p><ul><li>基于某张表的数据文件 ( t1.frm 和 t1.ibd )恢复，新建实例中仅有 t1 表的数据，称为单表恢复</li><li>基于实例中所有库表数据文件恢复则称为全量恢复。</li></ul><p><img src="/2021/04/08/DB/MySQL%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/3.png" alt="img"></p><h4 id="2-3-单表恢复"><a href="#2-3-单表恢复" class="headerlink" title="2.3 单表恢复"></a>2.3 单表恢复</h4><ol><li>确认还原库表信息及时间点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 例如：这里要还原至 192.168.1.1:3306 库的 2021-03-01 17:10:00 时间点</span></span><br><span class="line">需还原信息：</span><br><span class="line">主库IP：192.168.1.1</span><br><span class="line">端口：3306</span><br><span class="line">库名：db_test</span><br><span class="line">表名：restore_test</span><br><span class="line">时间：2021-03-01 17:10:00</span><br></pre></td></tr></table></figure><ol start="2"><li>创建临时实例</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 临时实例目录如下：</span></span><br><span class="line">[root@localhost mysql]$ tree .  </span><br><span class="line">.├── etc</span><br><span class="line"> │   ├── my.cnf</span><br><span class="line"> ├── <span class="built_in">log</span></span><br><span class="line"> ├── tmp</span><br><span class="line"> └── var</span><br></pre></td></tr></table></figure><p>基础数据库架构包含 etc 配置目录，里面包含了数据库的配置文件；log 日志目录、tmp 临时目录以及var 数据目录</p><ol start="3"><li>获取备份文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 新建一个恢复目录，防止进行整库恢复</span></span><br><span class="line">mkdir /tmp/restore3306</span><br><span class="line"><span class="comment">## 假设备份路径为 /path/to/backup</span></span><br><span class="line"><span class="comment">### 1. 获取公共文件</span></span><br><span class="line">cp -r /path/to/backup/data/&#123;mysql,performance_schema,ibdata1.qp&#125; /tmp/restore3306</span><br><span class="line"><span class="comment">### 2. 获取点位文件</span></span><br><span class="line">cp -r /path/to/backup/data/&#123;xtrabackup_binlog_info,xtrabackup_checkpoints,xtrabackup_info,xtrabackup_logfile.qp,xtrabackup_slave_info,backup-my.cnf&#125; /tmp/restore3306</span><br><span class="line"><span class="comment">### 3. 获取恢复表文件</span></span><br><span class="line">mkdir /tmp/restore3306/db_test</span><br><span class="line">cp -r /path/to/backup/data/db_test/restore_test* /tmp/restore3306/db_test/</span><br><span class="line"><span class="comment">## 最终恢复路径 /tmp/restore3306 的目录结构如下：</span></span><br><span class="line">ls -l</span><br><span class="line">total 4550652</span><br><span class="line">-rw-r--r-- 1 root root        263 Dec  9 16:55 backup-my.cnf</span><br><span class="line">drwxr-xr-x 2 root root         77 Dec  9 17:04 db_test</span><br><span class="line">-rw-r----- 1 root root 1173915128 Dec  9 16:55 ibdata1.qp</span><br><span class="line">drwxr-xr-x 2 root root       4096 Dec  9 16:54 mysql</span><br><span class="line">drwxr-xr-x 2 root root       4096 Dec  9 16:54 performance_schema</span><br><span class="line">-rw-r--r-- 1 root root         27 Dec  9 16:55 xtrabackup_binlog_info</span><br><span class="line">-rw-r----- 1 root root        103 Dec  9 16:55 xtrabackup_checkpoints</span><br><span class="line">-rw-r--r-- 1 root root       1038 Dec  9 16:55 xtrabackup_info</span><br><span class="line">-rw-r----- 1 root root 3485918050 Dec  9 16:55 xtrabackup_logfile.qp</span><br><span class="line">-rw-r--r-- 1 root root         78 Dec  9 16:55 xtrabackup_slave_info</span><br></pre></td></tr></table></figure><ol start="4"><li>解压缩(备份时未压缩需省略该步骤)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 使用16个线程进行解压，可根据服务器压力以及恢复需求紧急情况调整</span></span><br><span class="line">innobackupex --decompress --parallel=16 /tmp/restore3306/</span><br></pre></td></tr></table></figure><ol start="5"><li>应用redo日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 使用16G内存进行 apply log，如果数据量较大，且需要快速恢复，可酌情况调整</span></span><br><span class="line">innobackupex --use-memory=4G --apply-log /tmp/restore3306/</span><br></pre></td></tr></table></figure><ol start="6"><li>设置数据库配置(全量恢复需省略)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 在配置文件 [mysqld] 中添加这一行，需指定为对应表的库名.表名格式</span></span><br><span class="line">vim /path/to/mysql/etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">replicate-wild-do-table = db_test.restore_test</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="7"><li>拷贝备份数据启动临时实例</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 根据 MySQL 配置文件将对应的备份文件恢复到数据目录下</span></span><br><span class="line">innobackupex --defaults-file=/path/to/mysql/etc/my.cnf --move-back /tmp/restore3306</span><br><span class="line"><span class="comment">## 恢复后数据目录下的文件为系统操作用户权限，有可能不是 mysql 用户权限</span></span><br><span class="line">chown -R mysql.mysql /path/to/mysql/var</span><br><span class="line"><span class="comment">## 启动 MySQL 实例</span></span><br><span class="line">mysqld_safe --defaults-file=/path/to/mysql/etc/my.cnf &amp;</span><br></pre></td></tr></table></figure><ol start="8"><li>获取恢复初始点位</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 若在从库备份，则查看 /tmp/restore3306/xtrabackup_slave_info 文件找到备份点位，也就是恢复的初始点位</span></span><br><span class="line"><span class="comment">## 若在主库备份，则查看的是 /tmp/restore3306/xtrabackup_info 文件</span></span><br><span class="line"><span class="comment">### 主从基于 binlog file 和 position 复制</span></span><br><span class="line">cat /tmp/restore3306/xtrabackup_slave_info</span><br><span class="line">CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">'mysql-bin.008391'</span>, MASTER_LOG_POS=845521553</span><br><span class="line"></span><br><span class="line"><span class="comment">### 主从基于GTID复制</span></span><br><span class="line">cat xtrabackup_infobinlog_pos = filename <span class="string">'mysql-bin.000079'</span>, position <span class="string">'7372137'</span>, GTID of the last change <span class="string">'7acc0fb9-505a-11e9-aed3-246e96be16a0:1-66040'</span></span><br></pre></td></tr></table></figure><ol start="9"><li>挂载至集群主库</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 登录进实例中进行change master to，假设恢复的临时实例端口为33061</span></span><br><span class="line"><span class="comment">-- 基于binlog file挂载</span></span><br><span class="line">mysql -h127.0.0.1 -P33061 -uroot -pxxxxxx</span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span>  </span><br><span class="line">MASTER_HOST=<span class="string">'192.168.1.1'</span>,  </span><br><span class="line">MASTER_USER=<span class="string">'xxx'</span>,  </span><br><span class="line">MASTER_PASSWORD=<span class="string">'xxx'</span>,  </span><br><span class="line">MASTER_PORT=<span class="number">3306</span>,  </span><br><span class="line">MASTER_LOG_FILE=<span class="string">'mysql-bin.008391'</span>,  </span><br><span class="line">MASTER_LOG_POS=<span class="number">845521553</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- MySQL5.7以上版本基于GTID挂载</span></span><br><span class="line"><span class="keyword">stop</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">slave</span>;</span><br><span class="line"><span class="keyword">reset</span> <span class="keyword">master</span>;</span><br><span class="line"><span class="keyword">SET</span> @MYSQLDUMP_TEMP_LOG_BIN = @@SESSION.SQL_LOG_BIN;</span><br><span class="line"><span class="keyword">SET</span> @@SESSION.SQL_LOG_BIN= <span class="number">0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> gtid_purged=<span class="string">'7acc0fb9-505a-11e9-aed3-246e96be16a0:1-66040'</span>;</span><br><span class="line"><span class="keyword">SET</span> @@SESSION.SQL_LOG_BIN = @MYSQLDUMP_TEMP_LOG_BIN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span>  </span><br><span class="line">MASTER_HOST=<span class="string">'192.168.1.1'</span>,  </span><br><span class="line">MASTER_USER=<span class="string">'xxx'</span>,  </span><br><span class="line">MASTER_PASSWORD=<span class="string">'xxx'</span>,  </span><br><span class="line">MASTER_PORT=<span class="number">3306</span>,  </span><br><span class="line">master_auto_position=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 此时一定不能start slave开启主从同步，否则误操作位置也会同步至新建实例</span></span><br></pre></td></tr></table></figure><ol start="10"><li>获取恢复时刻主库点位</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 以MySQL5.6基于binlog file复制为例</span></span><br><span class="line"><span class="comment">## 需要恢复到的时间为2021-03-01 17:00:00，可根据时间以及业务提供误操作SQL解析当时的binlog并获取误操作点位</span></span><br><span class="line">mysqlbinlog --base64-output=<span class="string">'decode-rows'</span> --start-datetime=<span class="string">'2021-03-01 17:00:00'</span> --stop-datetime=<span class="string">'2021-03-01 17:20:00'</span> mysql-bin.008394 &gt; restore.log</span><br><span class="line"></span><br><span class="line"><span class="comment">## 假设最终找到点位为：mysql-bin.008394    end_log_pos 539183745</span></span><br></pre></td></tr></table></figure><ol start="11"><li>开启主从同步</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 开启IO线程获取主库binlog信息</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span> IO_THREAD;</span><br><span class="line"><span class="comment">-- 开启SQL线程只同步至找到的误操作点位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于binlog file同步</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span> SQL_THREAD <span class="keyword">until</span> MASTER_LOG_FILE=<span class="string">'mysql-bin.008394'</span>,MASTER_LOG_POS=<span class="number">539183745</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 基于GTID同步</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span> SQL_THREAD <span class="keyword">UNTIL</span> SQL_AFTER_GTIDS = <span class="number">3E11</span>FA47<span class="number">-71</span>CA<span class="number">-11E1</span><span class="number">-9E33</span>-C80AA9429562:<span class="number">11</span><span class="number">-56</span>;</span><br></pre></td></tr></table></figure><ol start="12"><li>恢复完成</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用show slave status查看同步状态</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>\G</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 直到Seconds_Behind_Master变为NULL，SQL线程停止表示已经恢复至当时误操作节点，此时恢复完成</span></span><br><span class="line"><span class="comment">-- 恢复完成后需 stop slave;停止同步，否则IO线程会不断获取主库日志</span></span><br></pre></td></tr></table></figure><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>数据库备份是一种防患于未然的手段，完整有效、安全可靠的备份数据有利于提高数据库的容错及可恢复性，基于备份数据的恢复是数据库系统崩溃时所提供的恢复代价最小的优解。所以，保证备份的准确可用是个人甚至公司必要且重要的事情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对个人乃至企业来说，数据都是至关重要的。不小心丢失或误操作都会造成不可估量的损失，但对数据的操作是无法避免的。数据损坏之后如何补救则成为了数据运维中非常重要的一部分。本文通过常用的 MySQL 数据库介绍数据的备份恢复基础概念及具体操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://schnappi618.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://schnappi618.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL慢查询SQL触发阈值邮件报警</title>
    <link href="https://schnappi618.github.io/2020/08/10/DB/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2SQL%E8%A7%A6%E5%8F%91%E9%98%88%E5%80%BC%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6/"/>
    <id>https://schnappi618.github.io/2020/08/10/DB/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2SQL%E8%A7%A6%E5%8F%91%E9%98%88%E5%80%BC%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6/</id>
    <published>2020-08-10T02:55:18.000Z</published>
    <updated>2020-08-10T05:16:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>这个只是我作为数据库和开发小白自己的一个解决思路，如果有更恰当的思路，欢迎评论或私聊呀～</p><h2 id="一、项目背景"><a href="#一、项目背景" class="headerlink" title="一、项目背景"></a>一、项目背景</h2><p>业务数据库被异常调用时导致慢查询量增大，影响到正常业务使用，业务只能通过nginx超时异常等来进行问题排查，增大了定位和处理问题的难度、时间，尤其商品库或者交易库可能会出现页面无法正常显示的情况。故业务需求为若主库和从库慢查询总量每分钟超过某个阈值之后则发送邮件报警。</p><h2 id="二、开发逻辑问题及处理"><a href="#二、开发逻辑问题及处理" class="headerlink" title="二、开发逻辑问题及处理"></a>二、开发逻辑问题及处理</h2><h3 id="1、问题梳理"><a href="#1、问题梳理" class="headerlink" title="1、问题梳理"></a>1、问题梳理</h3><ol><li>由于主库和从库在不同主机上，故不能开启pt-kill的<code>--log-dsn</code>参数将pt-kill结果写入数据库中，否则会出现主从数据不一致，从而导致主从异常中断</li><li>pt-kill在哪台主机上执行，如果pt-kill在主库、从库本身机器上执行，会将文件写入到本地，pt-kill效率的确最高，但后续如何将文件汇总到一起；而且最终需要将日志文件作为附件发送邮件，线上机器无法到外网，所以还需要分别将文件传输到中控机等可以访问外网的机器上</li><li>对应数据库的主库、从库可能会由于实例均衡发生变动，若直接在对应主机上启动pt-kill，会出现异常情况，并且还需要代码变动</li><li>pt-kill日志文件时间问题，本次需求为超过1分钟的数量触发到阈值之后发送邮件报警，若所有pt-kill结果都放入一个文件，这个文件会越来越大，不仅处理时间会越来越长，而且获取1分钟内的记录计算数量可能会存在漏掉或重复计算的情况</li><li>邮件内容如何发送，虽使用附件将pt-kill日志发送，但仍需要将统计内容作为邮件正文</li></ol><h3 id="2、问题处理"><a href="#2、问题处理" class="headerlink" title="2、问题处理"></a>2、问题处理</h3><ol><li>直接在中控机上执行对应的pt-kill命令</li><li>使用pt-kill的<code>--log</code>参数直接将kill掉的记录写入到本地文件中</li><li>使用多进程每一分钟启动对应的pt-kill进程，并写入到对应文件中，日志文件命名为<code>角色_端口_主机区分_时间戳_slow.log</code>。例如：主库某个时间的文件名为：<code>m_3306_733_20200810114116_slow.log</code>，表示端口为3306的主库，在主机后两位为733上2020年8月10日11时41分16秒生成的kill日志文件</li><li>pt-kill进程结束后使用子进程grep对应文件来获取慢SQL数量，并记录下来</li><li>由于为1min便有新的日志文件生成，时间久了之后数据量会特别大，还需要一个定时任务去清除日志文件。这里直接使用了crontab清除每10分钟清除30min之前的日志文件</li><li>邮件正文通过html写为表格，详细慢查询SQL直接通过附件发送</li></ol><h2 id="三、逻辑流程梳理"><a href="#三、逻辑流程梳理" class="headerlink" title="三、逻辑流程梳理"></a>三、逻辑流程梳理</h2><ol><li>持续使用percona提供的pt-kill工具kill对应数据库集群(主库+从库)的超过2s的慢查询并记录到日志文件中<ol><li>在管理库上获取对应集群的主库和从库主机名等信息</li><li>使用合适的pt-kill参数将每分钟kill掉的慢SQL记录到文件中</li></ol></li><li>获取主库和从库总共kill的慢SQL数量<ol><li>获取每个主库和从库日志文件所记录的kill慢SQL数量</li><li>获取所有主机被kill的慢SQL总数</li></ol></li><li>如果超过设定的阈值，则发送邮件报警<ol><li>判断是否超过设置阈值</li><li>超过则发送邮件报警</li></ol></li></ol><h2 id="四、主要功能代码"><a href="#四、主要功能代码" class="headerlink" title="四、主要功能代码"></a>四、主要功能代码</h2><p><strong>由于markdown粘贴代码，缩进可能有部分问题，复制粘贴后需注意一下，并且这里取消了log模块，可将需要内容打印到使用的log中去</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 公共函数</span></span><br><span class="line"><span class="comment">## 1. 获取数据库连接</span></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adminMySQLConn</span><span class="params">(User,Pass,Host,Port,DBName)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            adminConn=<span class="string">"mysql+pymysql://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?charset=utf8mb4"</span>.\</span><br><span class="line">                    format(User,Pass,Host,Port,DBName)</span><br><span class="line">            adminEngine = create_engine(adminConn)</span><br><span class="line">            <span class="keyword">return</span> adminEngine</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            self.log.error(<span class="string">"adminMySQLConn: &#123;&#125;"</span>.format(err))</span><br><span class="line">            <span class="comment">#self.log.error("adminMySQLConn: &#123;&#125;".format(err.message))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. 获取当前时间戳</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initCurrentDateTime</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> datetime.now().strftime(<span class="string">'%Y%m%d%H%M%S'</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">            self.log.error(<span class="string">"initCurrentDateTime: &#123;&#125;"</span>.format(err.message))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 3. 远程/本地执行linux命令(在本地执行可以直接使用os.system或subprocess.getstatusoutput，但由于这里是个公共函数，其他程序可能需要远程执行，故这里统一使用paramiko执行)</span></span><br><span class="line"><span class="keyword">from</span> paramiko <span class="keyword">import</span> SSHClient, AutoAddPolicy</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">executeSSH</span><span class="params">(ip, cmds)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">            client = SSHClient()</span><br><span class="line">            client.set_missing_host_key_policy(AutoAddPolicy())</span><br><span class="line">            system(<span class="string">'kinit -kt /etc/krb5.keytab'</span>)</span><br><span class="line">            client.connect(ip, look_for_keys=<span class="literal">False</span>, gss_auth=<span class="literal">True</span>, gss_kex=<span class="literal">True</span>)</span><br><span class="line">            stdin, stdout, stderr = client.exec_command(cmds)</span><br><span class="line">            <span class="comment"># result = stdout.readlines()       # 获取命令执行结果,返回的数据是一个list</span></span><br><span class="line">            _result = stdout.read().decode()  <span class="comment"># 命令执行结果</span></span><br><span class="line">            _status = stdout.channel.recv_exit_status()  <span class="comment"># 命令执行状态码</span></span><br><span class="line">            client.close()</span><br><span class="line">            <span class="keyword">return</span> _status, _result</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="comment"># print(e)</span></span><br><span class="line">            <span class="keyword">raise</span> e</span><br></pre></td></tr></table></figure><h3 id="1、获取初始化信息"><a href="#1、获取初始化信息" class="headerlink" title="1、获取初始化信息"></a>1、获取初始化信息</h3><p>由于这里存在一个管理库，上面有所有数据库的信息，则通过pymysql去查看并获取对应信息即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入信息，即GetHost中的info</span></span><br><span class="line">Inputinfo = &#123;<span class="string">"rsPort"</span>: <span class="number">3306</span><span class="string">'&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># tb_mysql_instance为管理表，其中：rsPort为端口，rsHost为对应数据库所在主机，rsRole为数据库角色：master主库，slave从库</span></span><br><span class="line">SQLlist = &#123;</span><br><span class="line">    <span class="string">"getHost"</span>: <span class="string">"select rsHost, rsPort, rsRole from tb_mysql_instance where rsPort = &#123;&#125; and rsRole in ('master', 'slave');"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetHost</span><span class="params">(**info)</span>:</span></span><br><span class="line">    port = info[<span class="string">'rsPort'</span>]</span><br><span class="line">    insInfoList = []</span><br><span class="line">    adminConn = adminMySQLConn()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        executeSQL = SQLlist[<span class="string">'getHost'</span>].format(port)</span><br><span class="line">        insList = adminConn.execute(executeSQL).fetchall()</span><br><span class="line">        <span class="keyword">if</span> insList:</span><br><span class="line">            datetime = initCurrentDateTime()</span><br><span class="line">            <span class="keyword">for</span> insInfo <span class="keyword">in</span> insList:</span><br><span class="line">                infoDict = dict(zip(insInfo.keys(), insInfo.values()))</span><br><span class="line">                <span class="keyword">if</span> infoDict[<span class="string">'rsRole'</span>] == <span class="string">'master'</span>:</span><br><span class="line">                    infoDict[<span class="string">'logFile'</span>] = <span class="string">"m_&#123;&#125;_&#123;&#125;_&#123;&#125;_slow.log"</span>.format(infoDict[<span class="string">'rsPort'</span>],<span class="string">''</span>.join(infoDict[<span class="string">'rsHost'</span>].split(<span class="string">'.'</span>)[<span class="number">2</span>:]) , datetime)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    infoDict[<span class="string">'logFile'</span>] = <span class="string">"s_&#123;&#125;_&#123;&#125;_&#123;&#125;_slow.log"</span>.format(infoDict[<span class="string">'rsPort'</span>],<span class="string">''</span>.join(infoDict[<span class="string">'rsHost'</span>].split(<span class="string">'.'</span>)[<span class="number">2</span>:]) , datetime)</span><br><span class="line">                infoDict[<span class="string">'ptkillLogFile'</span>] = <span class="string">"./SlowLog/&#123;&#125;"</span>.format(infoDict[<span class="string">'logFile'</span>])</span><br><span class="line">                insInfoList.append(infoDict)</span><br><span class="line">            msg = <span class="string">"Get &#123;&#125; pt-kill master and slave host info success."</span>.format(port)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>, insInfoList</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">"Get &#123;&#125; pt-kill master and slave host info failed. SQL:&#123;&#125; insList: "</span>.format(port, executeSQL), insList</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>, msg</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        msg = <span class="string">"Get &#123;&#125; pt-kill master and slave host info err: "</span>.format(port), err</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, msg</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出结果示例：</span></span><br><span class="line">[&#123;<span class="string">'rsHost'</span>: <span class="string">'1.1.1.1'</span>, <span class="string">'rsPort'</span>: <span class="number">3306</span>, <span class="string">'rsRole'</span>: <span class="string">'master'</span>, <span class="string">'logFile'</span>: <span class="string">'m_3306_11_20200810084828_slow.log'</span>, <span class="string">'ptkillLogFile'</span>: <span class="string">'/path/SlowLog/m_3306_11_20200810084828_slow.log'</span>&#125;, &#123;<span class="string">'rsHost'</span>: <span class="string">'2.2.2.2'</span>, <span class="string">'rsPort'</span>: <span class="number">3306</span>, <span class="string">'rsRole'</span>: <span class="string">'slave'</span>, <span class="string">'logFile'</span>: <span class="string">'s_3306_22_20200810084828_slow.log'</span>, <span class="string">'ptkillLogFile'</span>: <span class="string">'/path/SlowLog/s_3306_22_20200810084828_slow.log'</span>&#125;, &#123;<span class="string">'rsHost'</span>: <span class="string">'3.3.3.3'</span>, <span class="string">'rsPort'</span>: <span class="number">3306</span>, <span class="string">'rsRole'</span>: <span class="string">'slave'</span>, <span class="string">'logFile'</span>: <span class="string">'s_3306_33_20200810084828_slow.log'</span>, <span class="string">'ptkillLogFile'</span>: <span class="string">'/path/SlowLog/s_3306_33_20200810084828_slow.log'</span>&#125;]</span><br></pre></td></tr></table></figure><h3 id="2、执行pt-kill并获取慢SQL数量"><a href="#2、执行pt-kill并获取慢SQL数量" class="headerlink" title="2、执行pt-kill并获取慢SQL数量"></a>2、执行pt-kill并获取慢SQL数量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 后面的info都一直表示获取初始化信息后的里面的字典格式</span></span><br><span class="line"><span class="comment"># 例如：&#123;'rsHost': '1.1.1.1', 'rsPort': 3306, 'rsRole': 'master', 'logFile': 'm_3306_11_20200810084828_slow.log', 'ptkillLogFile': '/path/SlowLog/m_3306_11_20200810084828_slow.log'&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子函数</span></span><br><span class="line"><span class="comment">## 执行pt-kill命令，pt-kill一次只执行60s</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ExecutePtkillCmd</span><span class="params">(**info)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        ptkillCmd = <span class="string">"/opt/soft/percona-toolkit-2.2.14/bin/pt-kill --no-version-check "</span> \</span><br><span class="line">                    <span class="string">"--host &#123;rsHost&#125; --port &#123;rsPort&#125; --user 'dba' --password '5d63f33c10b8f430'"</span> \</span><br><span class="line">                    <span class="string">" --busy-time 2 --match-state='Sending data|Sorting result' --victim all "</span> \</span><br><span class="line">                    <span class="string">"--interval 1 --run-time 60 --daemonize  --kill --print --log=&#123;ptkillLogFile&#125;"</span>.format(**info)</span><br><span class="line">        status, ret = executeSSH(<span class="string">'10.148.16.25'</span>, ptkillCmd)</span><br><span class="line">        <span class="keyword">if</span> status == <span class="number">0</span>:</span><br><span class="line">            msg = <span class="string">"Execute &#123;rsHost&#125;:&#123;rsPort&#125; pt-kill command success."</span>.format(**info)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>, msg</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">"Execute &#123;rsHost&#125;:&#123;rsPort&#125; pt-kill command failed, Cmd:"</span>.format(**info), ptkillCmd</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span>, msg</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        msg = <span class="string">"Execute &#123;rsHost&#125;:&#123;rsPort&#125; pt-kill command error."</span>.format(**info), err</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, msg</span><br><span class="line"></span><br><span class="line"><span class="comment">## 获取慢SQL数量，并写入info中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">GetFileRegixCount</span><span class="params">(**info)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        logPwd = info[<span class="string">'ptkillLogFile'</span>]</span><br><span class="line">        process = Popen([<span class="string">'grep'</span>, <span class="string">'^# [0-9]\&#123;4\&#125;-[0-9]\&#123;2\&#125;-[0-9]\&#123;2\&#125;'</span>, logPwd], stdout=PIPE)</span><br><span class="line">        info[<span class="string">'slowSQLCount'</span>] = len((process.stdout).readlines())</span><br><span class="line">        msg = <span class="string">"Get &#123;rsHost&#125;:&#123;rsPort&#125; slow log count success."</span>.format(**info)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, info</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        msg = <span class="string">"Get &#123;rsHost&#125;:&#123;rsPort&#125; slow log count err:"</span>.format(**info), err</span><br><span class="line">        log.error(msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, msg</span><br><span class="line"><span class="comment">### 输出info格式类似为：</span></span><br><span class="line">&#123;<span class="string">'rsHost'</span>: <span class="string">'1.1.1.1'</span>, <span class="string">'rsPort'</span>: <span class="number">3306</span>, <span class="string">'rsRole'</span>: <span class="string">'master'</span>, <span class="string">'logFile'</span>: <span class="string">'m_3306_11_20200810084828_slow.log'</span>, <span class="string">'ptkillLogFile'</span>: <span class="string">'/path/SlowLog/m_3306_11_20200810084828_slow.log'</span>, <span class="string">'slowSQLCount'</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 每60s触发一次pt-kill的执行</span></span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">killSlowSql</span><span class="params">(info)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        status, msg = ExecutePtkillCmd(**info)</span><br><span class="line">        <span class="keyword">if</span> status <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> status, msg</span><br><span class="line">        sleep(<span class="number">60</span>) </span><br><span class="line">        <span class="keyword">return</span> GetFileRegixCount(**info)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        msg = <span class="string">"kill &#123;rsHost&#125;:&#123;rsPort&#125; &#123;ptkillLogFile&#125; err:"</span>.format(**info), err</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, msg</span><br><span class="line"></span><br><span class="line"><span class="comment">## 多进程执行pt-kill</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(*HostInfoList)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        pool = Pool(<span class="number">8</span>)</span><br><span class="line">        res_l = []</span><br><span class="line">        infoList = []</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> HostInfoList:</span><br><span class="line">            base = pool.apply_async(killSlowSql, (info, ))</span><br><span class="line">            res_l.append(base)</span><br><span class="line">        pool.close()</span><br><span class="line">        pool.join()</span><br><span class="line">        <span class="keyword">for</span> res <span class="keyword">in</span> res_l:</span><br><span class="line">            ret = res.get()</span><br><span class="line">            infoList.append(ret[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>, infoList</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span>, err</span><br></pre></td></tr></table></figure><h3 id="3、邮件正文html表格"><a href="#3、邮件正文html表格" class="headerlink" title="3、邮件正文html表格"></a>3、邮件正文html表格</h3><p>由于python自带html表格样式有些许丑，所以参考<a href="https://blog.csdn.net/u012111465/article/details/82713561" target="_blank" rel="noopener">这个小姐姐的表格前端页面</a>来进行了修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">head = \</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">            &lt;meta charset="utf-8"&gt;</span></span><br><span class="line"><span class="string">            &lt;STYLE TYPE="text/css" MEDIA=screen&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                table.dataframe &#123;</span></span><br><span class="line"><span class="string">                    border-collapse: collapse;</span></span><br><span class="line"><span class="string">                    border: 2px solid #a19da2;</span></span><br><span class="line"><span class="string">                    /*居中显示整个表格*/</span></span><br><span class="line"><span class="string">                    margin: auto;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                table.dataframe thead &#123;</span></span><br><span class="line"><span class="string">                    border: 2px solid #91c6e1;</span></span><br><span class="line"><span class="string">                    background: #f1f1f1;</span></span><br><span class="line"><span class="string">                    padding: 10px 10px 10px 10px;</span></span><br><span class="line"><span class="string">                    color: #333333;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                table.dataframe tbody &#123;</span></span><br><span class="line"><span class="string">                    border: 2px solid #91c6e1;</span></span><br><span class="line"><span class="string">                    padding: 10px 10px 10px 10px;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                table.dataframe tr &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                table.dataframe th &#123;</span></span><br><span class="line"><span class="string">                    vertical-align: top;</span></span><br><span class="line"><span class="string">                    font-size: 14px;</span></span><br><span class="line"><span class="string">                    padding: 10px 10px 10px 10px;</span></span><br><span class="line"><span class="string">                    color: #105de3;</span></span><br><span class="line"><span class="string">                    font-family: arial;</span></span><br><span class="line"><span class="string">                    text-align: center;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                table.dataframe td &#123;</span></span><br><span class="line"><span class="string">                    text-align: center;</span></span><br><span class="line"><span class="string">                    padding: 10px 10px 10px 10px;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                body &#123;</span></span><br><span class="line"><span class="string">                    font-family: 宋体;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                h1 &#123;</span></span><br><span class="line"><span class="string">                    color: #5db446</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                div.header h2 &#123;</span></span><br><span class="line"><span class="string">                    color: #0002e3;</span></span><br><span class="line"><span class="string">                    font-family: 黑体;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                div.content h2 &#123;</span></span><br><span class="line"><span class="string">                    text-align: center;</span></span><br><span class="line"><span class="string">                    font-size: 28px;</span></span><br><span class="line"><span class="string">                    text-shadow: 2px 2px 1px #de4040;</span></span><br><span class="line"><span class="string">                    color: #fff;</span></span><br><span class="line"><span class="string">                    font-weight: bold;</span></span><br><span class="line"><span class="string">                    background-color: #008eb7;</span></span><br><span class="line"><span class="string">                    line-height: 1.5;</span></span><br><span class="line"><span class="string">                    margin: 20px 0;</span></span><br><span class="line"><span class="string">                    box-shadow: 10px 10px 5px #888888;</span></span><br><span class="line"><span class="string">                    border-radius: 5px;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                h3 &#123;</span></span><br><span class="line"><span class="string">                    font-size: 22px;</span></span><br><span class="line"><span class="string">                    background-color: rgba(0, 2, 227, 0.71);</span></span><br><span class="line"><span class="string">                    text-shadow: 2px 2px 1px #de4040;</span></span><br><span class="line"><span class="string">                    color: rgba(239, 241, 234, 0.99);</span></span><br><span class="line"><span class="string">                    line-height: 1.5;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                h4 &#123;</span></span><br><span class="line"><span class="string">                    color: #e10092;</span></span><br><span class="line"><span class="string">                    font-family: 楷体;</span></span><br><span class="line"><span class="string">                    font-size: 20px;</span></span><br><span class="line"><span class="string">                    text-align: center;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                td img &#123;</span></span><br><span class="line"><span class="string">                    /*width: 60px;*/</span></span><br><span class="line"><span class="string">                    max-width: 300px;</span></span><br><span class="line"><span class="string">                    max-height: 300px;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &lt;/STYLE&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为表格需要的输入</span></span><br><span class="line"><span class="comment">## 输入格式类似为result=[[1,2,3],['a','b','c']], title=['id', 'name']</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">convert_to_html</span><span class="params">(result,title)</span>:</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> title:</span><br><span class="line">        d[t] = result[index]</span><br><span class="line">        index +=<span class="number">1</span></span><br><span class="line">    df = pd.DataFrame(d)</span><br><span class="line">    <span class="comment">#如数据过长，可能在表格中无法显示，加上pd.set_option语句可以避免这一情况</span></span><br><span class="line">    pd.set_option(<span class="string">'max_colwidth'</span>,<span class="number">200</span>)</span><br><span class="line">    pd.set_option(<span class="string">'colheader_justify'</span>, <span class="string">'center'</span>)</span><br><span class="line">    df = df [title]</span><br><span class="line">    <span class="comment">#h =df.to_html(index=False)</span></span><br><span class="line">    h =df.to_html(col_space=<span class="number">30</span>,border=<span class="number">1</span>,justify=<span class="string">'center'</span>)</span><br><span class="line">    h2 = h.replace(<span class="string">'class'</span>, <span class="string">'cellspacing=\"0\" class'</span>)</span><br><span class="line">    <span class="keyword">return</span> h2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化表格</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">formatHtmlTable</span><span class="params">(result, title)</span>:</span></span><br><span class="line">    df_html = convert_to_html(result,title)</span><br><span class="line">    body = \</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;div align="center" class="header"&gt;</span></span><br><span class="line"><span class="string">            &lt;!--标题部分的信息--&gt;</span></span><br><span class="line"><span class="string">            &lt;h1 align="center"&gt;慢查询SQL邮件报警&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            详情请查看附件</span></span><br><span class="line"><span class="string">&lt;!--            &lt;h2 align="center"&gt;具体SQL详情请查看附件&lt;/h2&gt; --&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &lt;div class="content"&gt;</span></span><br><span class="line"><span class="string">            &lt;!--正文内容--&gt;</span></span><br><span class="line"><span class="string">            &lt;h2&gt; &lt;/h2&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &lt;div&gt;</span></span><br><span class="line"><span class="string">                &lt;h4&gt;&lt;/h4&gt;</span></span><br><span class="line"><span class="string">                &#123;df_html&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &lt;p style="text-align: center"&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            &lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">        """</span>.format(df_html=df_html)</span><br><span class="line">    html_msg = <span class="string">"&lt;html&gt;"</span> + head + body + <span class="string">"&lt;/html&gt;"</span></span><br><span class="line">    html_msg = html_msg.replace(<span class="string">'\n'</span>,<span class="string">''</span>).encode(<span class="string">"utf-8"</span>)</span><br><span class="line">    <span class="keyword">return</span> html_msg</span><br></pre></td></tr></table></figure><h3 id="4、邮件发送"><a href="#4、邮件发送" class="headerlink" title="4、邮件发送"></a>4、邮件发送</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"><span class="comment">## 发送邮件，username和password为发送人邮箱的用户名和密码。注意密码为smtp的授权码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sendMail</span><span class="params">(sender, receivers, message)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        username = <span class="string">''''''</span><span class="string">'xxxx@qq.com'</span></span><br><span class="line">        password = <span class="string">'xxxxxx</span></span><br><span class="line"><span class="string">        smtp = smtplib.SMTP(host='</span>xxxx.qq.com<span class="string">', port=25)</span></span><br><span class="line"><span class="string">        smtp.login(username, password)</span></span><br><span class="line"><span class="string">        rdict = smtp.sendmail(sender, receivers, message.as_string())</span></span><br><span class="line"><span class="string">        smtp.quit()</span></span><br><span class="line"><span class="string">        msg = "send mail success"</span></span><br><span class="line"><span class="string">        return True, msg</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    except smtplib.SMTPException:</span></span><br><span class="line"><span class="string">        msg = "send mail failed"</span></span><br><span class="line"><span class="string">        return False, msg</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 发送报警</span></span><br><span class="line"><span class="string">def sendMailAlert(*infoList):</span></span><br><span class="line"><span class="string">    sender ='</span>xxx@qq.com<span class="string">'        # 发送人邮箱</span></span><br><span class="line"><span class="string">    receivers = ['</span>yy@<span class="number">163.</span>com<span class="string">']  # 接收人邮箱列表，可写多个</span></span><br><span class="line"><span class="string">    message = MIMEMultipart()</span></span><br><span class="line"><span class="string">    message['</span>From<span class="string">'] = Header("lichunliang", '</span>utf<span class="number">-8</span><span class="string">')  # 发送者别名</span></span><br><span class="line"><span class="string">    message['</span>To<span class="string">'] = Header("business_rds", '</span>utf<span class="number">-8</span><span class="string">')  # 接收者别名</span></span><br><span class="line"><span class="string">    subject = '</span>慢查询邮件告警测试<span class="string">'</span></span><br><span class="line"><span class="string">    message['</span>Subject<span class="string">'] = Header(subject, '</span>utf<span class="number">-8</span><span class="string">')</span></span><br><span class="line"><span class="string">#    message.attach(MIMEText(mail_msg1, '</span>plain<span class="string">', '</span>utf<span class="number">-8</span><span class="string">'))</span></span><br><span class="line"><span class="string">    sumCount = 0</span></span><br><span class="line"><span class="string">    for info in infoList:</span></span><br><span class="line"><span class="string">        sumCount += info["slowSQLCount"]</span></span><br><span class="line"><span class="string">    if sumCount &gt; 5:</span></span><br><span class="line"><span class="string">        retList = []</span></span><br><span class="line"><span class="string">        title = ['</span>rsPort<span class="string">', '</span>rsRole<span class="string">', '</span>logFile<span class="string">', '</span>slowSQLCount<span class="string">']</span></span><br><span class="line"><span class="string">        for t in title:</span></span><br><span class="line"><span class="string">            ret = []</span></span><br><span class="line"><span class="string">            [ret.append(info[t]) for info in infoList]</span></span><br><span class="line"><span class="string">            retList.append(ret)</span></span><br><span class="line"><span class="string">        for info in infoList:</span></span><br><span class="line"><span class="string">            ## 发送附件</span></span><br><span class="line"><span class="string">            att1 = MIMEText(open(info['</span>ptkillLogFile<span class="string">'], '</span>r<span class="string">b').read(), '</span>base64<span class="string">', '</span>utf<span class="number">-8</span><span class="string">')</span></span><br><span class="line"><span class="string">            att1["Content-Type"] = '</span>application/octet-stream<span class="string">'</span></span><br><span class="line"><span class="string">            att1["Content-Disposition"] = '</span>attachment; filename=&#123;&#125;<span class="string">'.format(info['</span>ptkillLogFile<span class="string">'].split('</span>/<span class="string">')[-1])</span></span><br><span class="line"><span class="string">            message.attach(att1)</span></span><br><span class="line"><span class="string">        html_msg = formatHtmlTable(retList,title)</span></span><br><span class="line"><span class="string">        message.attach(MIMEText(html_msg, '</span>html<span class="string">', '</span>utf<span class="number">-8</span><span class="string">'))</span></span><br><span class="line"><span class="string">        return sendMail(sender, receivers, message)</span></span><br><span class="line"><span class="string">    else:</span></span><br><span class="line"><span class="string">        log.info('</span>Dont need sendmail.<span class="string">')</span></span><br></pre></td></tr></table></figure><h2 id="五、邮件报警效果"><a href="#五、邮件报警效果" class="headerlink" title="五、邮件报警效果"></a>五、邮件报警效果</h2><img src="/2020/08/10/DB/MySQL%E6%85%A2%E6%9F%A5%E8%AF%A2SQL%E8%A7%A6%E5%8F%91%E9%98%88%E5%80%BC%E9%82%AE%E4%BB%B6%E6%8A%A5%E8%AD%A6/alert1.png" style="zoom:67%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个只是我作为数据库和开发小白自己的一个解决思路，如果有更恰当的思路，欢迎评论或私聊呀～&lt;/p&gt;
&lt;h2 id=&quot;一、项目背景&quot;&gt;&lt;a href=&quot;#一、项目背景&quot; class=&quot;headerlink&quot; title=&quot;一、项目背景&quot;&gt;&lt;/a&gt;一、项目背景&lt;/h2&gt;&lt;p&gt;业务
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://schnappi618.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://schnappi618.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL使用tokuDB引擎无法备份问题排查</title>
    <link href="https://schnappi618.github.io/2020/08/06/DB/MySQL%E4%BD%BF%E7%94%A8tokuDB%E5%BC%95%E6%93%8E%E6%97%A0%E6%B3%95%E5%A4%87%E4%BB%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <id>https://schnappi618.github.io/2020/08/06/DB/MySQL%E4%BD%BF%E7%94%A8tokuDB%E5%BC%95%E6%93%8E%E6%97%A0%E6%B3%95%E5%A4%87%E4%BB%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</id>
    <published>2020-08-06T09:21:25.000Z</published>
    <updated>2020-08-12T01:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h2><p>​    之前线上和线下测试环境数据库仅允许为MyISAM和InnoDB引擎存在，但本次数据迁移中存在tokuDB引擎的库，一直使用percona提供的xtrabackup每天进行数据备份，innobackup自动恢复数据。但由于该情况并不支持tokuDB引擎的备份，故本次数据迁移生成的十几个集群备份全部无效，后面决定使用mydumper来进行备份恢复。</p><h2 id="二、备份方案及问题处理"><a href="#二、备份方案及问题处理" class="headerlink" title="二、备份方案及问题处理"></a>二、备份方案及问题处理</h2><h3 id="1、备份恢复流程"><a href="#1、备份恢复流程" class="headerlink" title="1、备份恢复流程"></a>1、备份恢复流程</h3><p>​    使用mydumper+myloader来进行tokuDB引擎库的备份恢复，简易备份恢复流程如下：</p><ol><li><p>使用mydumper备份：<code>mydumper -h x.x.x.x -P port -u root -p xxxx -t 16 -e -c -o /path/to/backup</code></p><p>使用16个线程对某主机上某个端口的数据库来进行压缩备份，备份到目录’/path/to/backup’中</p></li><li><p>创建一个和备份库同版本的数据库</p></li><li><p>使用myloader恢复：<code>myloader --user root --password xxxxxxxx --port 3487 --host 127.0.0.1 -C --directory /path/to/backupDataPath/data --threads 8 --verbose 3 &gt; load.log 2&gt;&amp;1</code></p><p>由于备份时进行了压缩，故恢复时需要用-C参数来进行解压，并输出恢复日志load.log</p></li><li><p>创建主从关系：主从信息位于备份目录下的data/metadata文件中，文件内容大致如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 如果想让恢复库为备份主机的从库，则用metadata中show master status中的信息创建主从关系，此时master_host为备份机IP；</span></span><br><span class="line"><span class="comment">## 若需要恢复库和备份机为同一个主库，则使用metadata中show slave status的信息创建主从关系即可。</span></span><br><span class="line">Started dump at: 2020-08-03 02:37:02</span><br><span class="line">SHOW MASTER STATUS:</span><br><span class="line">        Log: mysql-bin.000671</span><br><span class="line">        Pos: 16910</span><br><span class="line">        GTID:</span><br><span class="line"></span><br><span class="line">SHOW SLAVE STATUS:</span><br><span class="line">        Host: x.x.x.x</span><br><span class="line">        Log: mysql-bin.000668</span><br><span class="line">        Pos: 51101690</span><br><span class="line">        GTID:</span><br><span class="line"></span><br><span class="line">Finished dump at: 2020-08-03 04:05:38</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 登陆数据库，执行</span></span><br><span class="line">change master to = <span class="string">'x.x.x.x'</span>,</span><br><span class="line"> master_port=xxxx, </span><br><span class="line"> master_user=<span class="string">'xx'</span></span><br><span class="line"> master_password=<span class="string">'xxxxxxxxxx'</span>,</span><br><span class="line"> master_log_file=<span class="string">'mysql-bin.xxxxx'</span>,</span><br><span class="line"> mysql_log_pos=xxxxxxxxxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 开启主从同步</span></span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure></li></ol><h3 id="2、问题处理"><a href="#2、问题处理" class="headerlink" title="2、问题处理"></a>2、问题处理</h3><h4 id="1-开启主从时出现1062报错"><a href="#1-开启主从时出现1062报错" class="headerlink" title="1. 开启主从时出现1062报错"></a>1. 开启主从时出现1062报错</h4><p><strong>1. 报错信息</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@(none))&gt;show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: x.x.x.x</span><br><span class="line">                  Master_User: xx</span><br><span class="line">                  Master_Port: 3487</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000783</span><br><span class="line">          Read_Master_Log_Pos: 360153174</span><br><span class="line">               Relay_Log_File: relay-log.000002</span><br><span class="line">                Relay_Log_Pos: 283</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000668</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: No</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 1062</span><br><span class="line">                   Last_Error: Error 'Duplicate entry '426922153' for key 'PRIMARY'' on query.</span><br></pre></td></tr></table></figure><p><strong>2. 问题原因</strong></p><p>本次出现该问题是由于在备份过程中原数据库有数据写入，导致数据冲突。故使用备份数据进行恢复时出现’Duplicate entry’报错。在网上查找解决方法时发现其他人出现这个问题是由于两个库有相同表名、相同表结构的表同时进行恢复，这个还未进行测试验证。</p><p><strong>3. 解决方法</strong></p><p>mydumper备份时添加<code>--lock-all-tables</code>参数，即强制在备份开始时开启<code>flush table with read lock;</code>，则在备份时该库无法写入数据，所有的更新操作都会被阻塞，从而强制获得一致性备份数据。由于所有备份都是在从库执行，所以写入阻塞没有很大影响，但数据量较大时会导致主从延迟出现。如果主库备份数据，还是使用mysqldump来进行备份比较稳妥。后面可以考虑用mysqlpump来实现所有备份操作。</p><p>开启备份库的全日制可以看到，在备份开始时开启了FTWRL，备份完成后释放。</p><p><img src="/2020/08/06/DB/MySQL%E4%BD%BF%E7%94%A8tokuDB%E5%BC%95%E6%93%8E%E6%97%A0%E6%B3%95%E5%A4%87%E4%BB%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/1.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、问题背景&quot;&gt;&lt;a href=&quot;#一、问题背景&quot; class=&quot;headerlink&quot; title=&quot;一、问题背景&quot;&gt;&lt;/a&gt;一、问题背景&lt;/h2&gt;&lt;p&gt;​    之前线上和线下测试环境数据库仅允许为MyISAM和InnoDB引擎存在，但本次数据迁移中存在tok
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://schnappi618.github.io/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://schnappi618.github.io/tags/MySQL/"/>
    
      <category term="tokuDB" scheme="https://schnappi618.github.io/tags/tokuDB/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎之ReplacingMergeTree引擎</title>
    <link href="https://schnappi618.github.io/2020/07/28/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BReplacingMergeTree%E5%BC%95%E6%93%8E/"/>
    <id>https://schnappi618.github.io/2020/07/28/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BReplacingMergeTree%E5%BC%95%E6%93%8E/</id>
    <published>2020-07-28T10:16:29.000Z</published>
    <updated>2020-08-03T12:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ReplacingMergeTree作用"><a href="#一、ReplacingMergeTree作用" class="headerlink" title="一、ReplacingMergeTree作用"></a>一、ReplacingMergeTree作用</h2><p>​    ClickHouse中最常用也是最基础的表引擎为MergeTree，在它的功能基础上添加特定功能就构成了MergeTree系列引擎。MergeTree支持主键，但主键主要用来缩小查询范围，且不具备唯一性约束，可以正常写入相同主键的数据。但在一些情况下，可能需要表中没有主键重复的数据。ReplacingMergeTree就是在MergeTree的基础上加入了去重的功能，但它仅会在合并分区时，去删除重复的数据，写入相同数据时并不会引发异常。</p><h2 id="二、功能示例"><a href="#二、功能示例" class="headerlink" title="二、功能示例"></a>二、功能示例</h2><p>创建一张ReplacingMergeTree的表和创建MergeTree类似，修改引擎即可。ReplacingMergeTree引擎创建规范为：<code>ENGINE = ReplacingMergeTree([ver])</code>，其中ver为选填参数，它需要指定一个UInt8/UInt16、Date或DateTime类型的字段，它决定了数据去重时所用的算法，如果没有设置该参数，合并时保留分组内的最后一条数据；如果指定了该参数，则保留ver字段取值最大的那一行。</p><h3 id="1、不指定ver参数"><a href="#1、不指定ver参数" class="headerlink" title="1、不指定ver参数"></a>1、不指定ver参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建未指定ver参数ReplacintMergeTree引擎的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> replac_merge_test</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="keyword">String</span>, </span><br><span class="line">    <span class="string">`code`</span> <span class="keyword">String</span>, </span><br><span class="line">    <span class="string">`create_time`</span> DateTime</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span> = ReplacingMergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (<span class="keyword">id</span>, code)</span><br></pre></td></tr></table></figure><p><strong>ReplacingMergeTree会根据ORDER BY所声明的表达式去重</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在上述表中插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> replac_merge_test <span class="keyword">values</span> (<span class="string">'A000'</span>, <span class="string">'code1'</span>, <span class="keyword">now</span>()),(<span class="string">'A000'</span>, <span class="string">'code1'</span>, <span class="string">'2020-07-28 21:30:00'</span>), (<span class="string">'A001'</span>, <span class="string">'code1'</span>, <span class="keyword">now</span>()), (<span class="string">'A001'</span>, <span class="string">'code2'</span>, <span class="string">'2020-07-28 21:30:00'</span>), (<span class="string">'A0002'</span>, <span class="string">'code2'</span>, <span class="keyword">now</span>());</span><br><span class="line"><span class="comment">-- 查询当前数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> replac_merge_test;</span><br><span class="line">┌─id────┬─code──┬─────────create_time─┐</span><br><span class="line">│ A000  │ code1 │ 2020-07-28 21:23:48 │</span><br><span class="line">│ A000  │ code1 │ 2020-07-28 21:30:00 │</span><br><span class="line">│ A0002 │ code2 │ 2020-07-28 21:23:48 │</span><br><span class="line">│ A001  │ code1 │ 2020-07-28 21:23:48 │</span><br><span class="line">│ A001  │ code2 │ 2020-07-28 21:30:00 │</span><br><span class="line">└───────┴───────┴─────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制进行分区合并</span></span><br><span class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> replac_merge_test <span class="keyword">FINAL</span>;</span><br><span class="line"><span class="comment">-- 再次查询数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> replac_merge_test;</span><br><span class="line">┌─id────┬─code──┬─────────create_time─┐</span><br><span class="line">│ A000  │ code1 │ 2020-07-28 21:30:00 │</span><br><span class="line">│ A0002 │ code2 │ 2020-07-28 21:23:48 │</span><br><span class="line">│ A001  │ code1 │ 2020-07-28 21:23:48 │</span><br><span class="line">│ A001  │ code2 │ 2020-07-28 21:30:00 │</span><br><span class="line">└───────┴───────┴─────────────────────┘</span><br></pre></td></tr></table></figure><p>通过上面示例可以看到，id、code相同的字段’A000’,’code1’被去重剩余一条数据，由于创建表时没有设置ver参数，故保留分组内的最后一条数据(create_time字段)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 再次使用insert插入一条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> replac_merge_test <span class="keyword">values</span> (<span class="string">'A001'</span>, <span class="string">'code1'</span>, <span class="string">'2020-07-28 21:30:00'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询表中数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> replac_merge_test;</span><br><span class="line">┌─id────┬─code──┬─────────create_time─┐</span><br><span class="line">│ A000  │ code1 │ 2020-07-28 21:30:00 │</span><br><span class="line">│ A0002 │ code2 │ 2020-07-28 21:23:48 │</span><br><span class="line">│ A001  │ code1 │ 2020-07-28 21:23:48 │</span><br><span class="line">│ A001  │ code2 │ 2020-07-28 21:30:00 │</span><br><span class="line">└───────┴───────┴─────────────────────┘</span><br><span class="line">┌─id───┬─code──┬─────────create_time─┐</span><br><span class="line">│ A001 │ code1 │ 2020-07-28 21:30:00 │</span><br><span class="line">└──────┴───────┴─────────────────────┘</span><br></pre></td></tr></table></figure><p>可以看到，再次插入重复数据时，查询仍然会存在重复。在ClickHouse中，默认一条insert插入的数据为同一个数据分区，不同insert插入的数据为不同的分区，所以ReplacingMergeTree是以分区为单位进行去重的，也就是说只有在相同的数据分区内，重复数据才可以被删除掉。只有数据合并完成后，才可以使用引擎特性进行去重。</p><h3 id="2、指定ver参数"><a href="#2、指定ver参数" class="headerlink" title="2、指定ver参数"></a>2、指定ver参数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建指定ver参数ReplacingMergeTree引擎的表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> replac_merge_ver_test</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="keyword">String</span>, </span><br><span class="line">    <span class="string">`code`</span> <span class="keyword">String</span>, </span><br><span class="line">    <span class="string">`create_time`</span> DateTime</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span> = ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> <span class="keyword">id</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (<span class="keyword">id</span>, code)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> replac_merge_ver_test <span class="keyword">values</span>(<span class="string">'A000'</span>, <span class="string">'code1'</span>, <span class="string">'2020-07-10 21:35:30'</span>),(<span class="string">'A000'</span>, <span class="string">'code1'</span>, <span class="string">'2020-07-15 21:35:30'</span>),(<span class="string">'A000'</span>, <span class="string">'code1'</span>, <span class="string">'2020-07-05 21:35:30'</span>),(<span class="string">'A000'</span>, <span class="string">'code1'</span>, <span class="string">'2020-06-05 21:35:30'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> replac_merge_ver_test;</span><br><span class="line">┌─id───┬─code──┬─────────create_time─┐</span><br><span class="line">│ A000 │ code1 │ 2020-06-05 21:35:30 │</span><br><span class="line">└──────┴───────┴─────────────────────┘</span><br><span class="line">┌─id───┬─code──┬─────────create_time─┐</span><br><span class="line">│ A000 │ code1 │ 2020-07-10 21:35:30 │</span><br><span class="line">│ A000 │ code1 │ 2020-07-15 21:35:30 │</span><br><span class="line">│ A000 │ code1 │ 2020-07-05 21:35:30 │</span><br><span class="line">└──────┴───────┴─────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 强制进行分区合并</span></span><br><span class="line"><span class="keyword">optimize</span> <span class="keyword">table</span> replac_merge_ver_test <span class="keyword">FINAL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> replac_merge_ver_test;</span><br><span class="line">┌─id───┬─code──┬─────────create_time─┐</span><br><span class="line">│ A000 │ code1 │ 2020-07-15 21:35:30 │</span><br><span class="line">└──────┴───────┴─────────────────────┘</span><br><span class="line">┌─id───┬─code──┬─────────create_time─┐</span><br><span class="line">│ A000 │ code1 │ 2020-06-05 21:35:30 │</span><br><span class="line">└──────┴───────┴─────────────────────┘</span><br></pre></td></tr></table></figure><p>由于上述创建表是以create_time的年月来进行分区的，可以看出不同的数据分区，ReplacingMergeTree并不会进行去重，并且在相同数据分区内，指定ver参数后，会保留同一组数据内create_time时间最大的那一行数据。</p><h2 id="三、ReplacingMergeTree引擎总结"><a href="#三、ReplacingMergeTree引擎总结" class="headerlink" title="三、ReplacingMergeTree引擎总结"></a>三、ReplacingMergeTree引擎总结</h2><ul><li>使用ORDER BY排序键，作为判断数据是否重复的唯一键</li><li>只有在合并分区时，才会触发数据的去重逻辑</li><li>删除重复数据，是以数据分区为单位。同一个数据分区的重复数据才会被删除，不同数据分区的重复数据仍会保留</li><li>在进行数据去重时，由于已经基于ORDER BY排序，所以可以找到相邻的重复数据</li><li>数据去重策略为：<ul><li>若指定了ver参数，则会保留重复数据中，ver字段最大的那一行</li><li>若未指定ver参数，则会保留重复数据中最末的那一行数据</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、ReplacingMergeTree作用&quot;&gt;&lt;a href=&quot;#一、ReplacingMergeTree作用&quot; class=&quot;headerlink&quot; title=&quot;一、ReplacingMergeTree作用&quot;&gt;&lt;/a&gt;一、ReplacingMergeTree
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
      <category term="MergeTree" scheme="https://schnappi618.github.io/tags/MergeTree/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎之MergeTree引擎——数据TTL</title>
    <link href="https://schnappi618.github.io/2020/07/26/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AETTL/"/>
    <id>https://schnappi618.github.io/2020/07/26/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AETTL/</id>
    <published>2020-07-26T12:59:35.000Z</published>
    <updated>2020-07-28T10:07:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据TTL"><a href="#一、数据TTL" class="headerlink" title="一、数据TTL"></a>一、数据TTL</h2><p>​    TTL(Time to Live)，表示数据的存活时间。在MergeTree中，可以为某个列字段或整张表设置TTL时间。若为列字段的TTL，当时间到期时，则会删除这一列的数据；若为表级别的TTL，当时间到期时，则会删除整张表的数据；若一张表同时设置了列级别和表级别的TTL，则会以先到期的为主。</p><p>​    无论是列级别还是表级别的TTL，都需要依托于某个DateTime或Date类型的字段，通过对这个时间字段的INTERVAL操作，来描述TTL的过期时间，设置TTL过期时间的INTERVAL完整操作包括：SECOND、MINUTE、HOUR、DAY、WEEK、MONTH、QUARTER和YEAR。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表示数据存活时间为，time_col时间的三天内</span></span><br><span class="line">TTL time_col + INTERVAL 3 DAY</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表示数据存活时间为，time_col一月内</span></span><br><span class="line">TTL time_col + INTERVAL 1 MONTH</span><br></pre></td></tr></table></figure><h2 id="二、列级别TTL"><a href="#二、列级别TTL" class="headerlink" title="二、列级别TTL"></a>二、列级别TTL</h2><p>​    若设置了列级别的TTL，当列字段中的值过期时，ClickHouse会将他们替换成默认值。如果一个分区内，某一列的所有值都已过期，那么ClickHouse会从文件系统中删除这个分区目录下的列文件。</p><p>​    如果想要设置列级别的TTL，需要在定义表字段的时候，为列声明TTL表达式，主键字段不能被声明成TTL。示例数据如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建有TTL列的表结构</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ttl_table_t1</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="keyword">String</span>, </span><br><span class="line">    <span class="string">`create_time`</span> DateTime, </span><br><span class="line">    <span class="string">`code`</span> <span class="keyword">String</span> TTL create_time + toIntervalSecond(<span class="number">10</span>), </span><br><span class="line">    <span class="string">`type`</span> UInt8 TTL create_time + toIntervalSecond(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span> = MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以看到，create_time为日期类型，列字段code和type都被设置了TTL时间，他们存活时间，都为create_time建立后向后10s</span></span><br><span class="line"><span class="comment">-- 写入测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> ttl_table_t1 <span class="keyword">VALUES</span>(<span class="string">'A000'</span>, <span class="keyword">now</span>(), <span class="string">'c1'</span>, <span class="number">1</span>), (<span class="string">'A000'</span>, <span class="keyword">now</span>() + <span class="built_in">INTERVAL</span> <span class="number">2</span> <span class="keyword">MINUTE</span>, <span class="string">'c1'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ttl_table_t1;</span><br><span class="line">┌─id───┬─────────create_time─┬─code─┬─type─┐</span><br><span class="line">│ A000 │ 2020-07-27 21:29:15 │ c1   │    1 │</span><br><span class="line">│ A000 │ 2020-07-27 21:31:15 │ c1   │    2 │</span><br><span class="line">└──────┴─────────────────────┴──────┴──────┘</span><br></pre></td></tr></table></figure><p>ClickHouse看到数据已经过期的时候，将执行合并，合并的频率由<code>merge_with_ttl_timeout</code>参数控制，<code>SETTINGS merge_with_ttl_timeout = 86400 </code>默认为86400s即1天，如果这个值太低，表示ClickHouse需要执行许多计划外的合并，可能消耗大量的资源。</p><p>如果在ClickHouse合并期间进行查询，可能会获得过期的数据，所以在select查询之前可使用<code>optimize</code>命令强制触发TTL清理机制。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看merge_with_ttl_timeout参数的值</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> system.merge_tree_settings <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'merge_with_ttl_timeout'</span>;</span><br><span class="line">┌─name───────────────────┬─value─┬─changed─┬─description───────────────────────────────────────────────────┐</span><br><span class="line">│ merge_with_ttl_timeout │ 86400 │       0 │ Minimal time in seconds, when <span class="keyword">merge</span> <span class="keyword">with</span> TTL can be repeated. │</span><br><span class="line">└────────────────────────┴───────┴─────────┴───────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 10s后强制触发TTL清理，FINAL表示触发所有分区合并，没有FINAL表示触发一个分区合并</span></span><br><span class="line"><span class="keyword">optimize</span> <span class="keyword">TABLE</span> ttl_table_t1 <span class="keyword">FINAL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 再次查看数据</span></span><br><span class="line"><span class="comment">-- 可以看到由于第一行满足TTL过期条件，所以被还原为了列的默认值</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ttl_table_t1;</span><br><span class="line">┌─id───┬─────────create_time─┬─code─┬─type─┐</span><br><span class="line">│ A000 │ 2020-07-27 21:29:15 │      │    0 │</span><br><span class="line">│ A000 │ 2020-07-27 21:31:15 │ c1   │    2 │</span><br><span class="line">└──────┴─────────────────────┴──────┴──────┘</span><br></pre></td></tr></table></figure><p>​    如果需要修改列字段的TTL或为已有字段添加TTL，可使用ALTER语句设置：<code>ALTER TABLE ttl_table_t1 MODIFY COLUMN code STRING TTL create_time + INTERVAL 1 DAY</code>，目前<strong>ClickHouse没有提供取消列级别TTL的方法。</strong></p><h2 id="三、表级别TTL"><a href="#三、表级别TTL" class="headerlink" title="三、表级别TTL"></a>三、表级别TTL</h2><p>​    如果需要为整张表设置TTL过期时间，则需要在MergeTree的表参数重增加TTL表达式，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ttl_table_t2</span><br><span class="line">(</span><br><span class="line">    <span class="string">`id`</span> <span class="keyword">String</span>, </span><br><span class="line">    <span class="string">`create_time`</span> DateTime, </span><br><span class="line">    <span class="string">`code`</span> <span class="keyword">String</span> TTL create_time + toIntervalSecond(<span class="number">10</span>), </span><br><span class="line">    <span class="string">`type`</span> UInt8 TTL create_time + toIntervalSecond(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span> = MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">id</span></span><br><span class="line">TTL create_time + <span class="built_in">INTERVAL</span> <span class="number">1</span> <span class="keyword">DAY</span></span><br></pre></td></tr></table></figure><p>​    上面示例中整张表都被设置了TTL，当触发到TTL清理时，满足过期时间的数据行将被整行删除。表级别的TTL也支持修改，同样适用ALTER语句：<code>ALTER TABLE ttl_table_t2 MODIFY TTL create_time + INTERVAL 3 DAY</code>，<strong>同样，表级别的TTL目前也不支持删除。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行上述alter语句修改后表结构如下：</span></span><br><span class="line">clickhouse-server_1 :) desc ttl_table_t2</span><br><span class="line"></span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">TABLE</span> ttl_table_t2</span><br><span class="line"></span><br><span class="line">┌─<span class="keyword">name</span>────────┬─<span class="keyword">type</span>─────┬─default_type─┬─default_expression─┬─<span class="keyword">comment</span>─┬─codec_expression─┬─ttl_expression─────────────────────┐</span><br><span class="line">│ <span class="keyword">id</span>          │ <span class="keyword">String</span>   │              │                    │         │                  │                                    │</span><br><span class="line">│ create_time │ DateTime │              │                    │         │                  │                                    │</span><br><span class="line">│ code        │ <span class="keyword">String</span>   │              │                    │         │                  │ create_time + toIntervalSecond(<span class="number">10</span>) │</span><br><span class="line">│ <span class="keyword">type</span>        │ UInt8    │              │                    │         │                  │ create_time + toIntervalSecond(<span class="number">10</span>) │</span><br><span class="line">└─────────────┴──────────┴──────────────┴────────────────────┴─────────┴──────────────────┴────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="四、TTL的运行原理"><a href="#四、TTL的运行原理" class="headerlink" title="四、TTL的运行原理"></a>四、TTL的运行原理</h2><p>​    当一张MergeTree表被设置了TTL表达式，在写入数据时，会以数据分区为单位，在每个分区目录内生成一个<code>ttl.txt</code>的文件，以上面的表ttl_table_t2为例，它既包含了列级别TTL，还包含了表级别的TTL。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 向ttl_table_t2表插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ttl_table_t2 <span class="keyword">VALUES</span>(<span class="string">'A000'</span>, <span class="keyword">now</span>(), <span class="string">'haha'</span>, <span class="number">2</span>), (<span class="string">'A001'</span>, <span class="keyword">now</span>(), <span class="string">'xx'</span>, <span class="number">2</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> ttl_table_t2</span><br><span class="line"></span><br><span class="line">┌─<span class="keyword">id</span>───┬─────────create_time─┬─code─┬─<span class="keyword">type</span>─┐</span><br><span class="line">│ A000 │ <span class="number">2020</span><span class="number">-07</span><span class="number">-28</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">23</span> │ haha │    <span class="number">2</span> │</span><br><span class="line">│ A001 │ <span class="number">2020</span><span class="number">-07</span><span class="number">-28</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">23</span> │ xx   │    <span class="number">2</span> │</span><br><span class="line">└──────┴─────────────────────┴──────┴──────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 由于这里插入了两条数据，所以会有两个分区目录</span></span><br><span class="line">[root@xxxx ttl_table_t2]<span class="comment"># ll</span></span><br><span class="line">total <span class="number">8</span></span><br><span class="line">drwxr-x<span class="comment">--- 2 101 101 4096 Jul 28 14:28 202007_1_1_0</span></span><br><span class="line">drwxr-x<span class="comment">--- 2 101 101  272 Jul 28 14:28 202007_1_1_1</span></span><br><span class="line">drwxr-x<span class="comment">--- 2 101 101   10 Jul 28 14:28 detached</span></span><br><span class="line">-rw-r<span class="comment">----- 1 101 101    1 Jul 28 14:28 format_version.txt</span></span><br></pre></td></tr></table></figure><p>​    在写入数据后，每个分区目录内都会生成ttl.txt文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## tree查看当前分区目录结构,用202007_1_1_0分区为例</span></span><br><span class="line">tree ./202007_1_1_0</span><br><span class="line">.</span><br><span class="line">├── checksums.txt</span><br><span class="line">├── code.bin</span><br><span class="line">├── code.mrk2</span><br><span class="line">├── columns.txt</span><br><span class="line">├── count.txt</span><br><span class="line">├── create_time.bin</span><br><span class="line">├── create_time.mrk2</span><br><span class="line">├── id.bin</span><br><span class="line">├── id.mrk2</span><br><span class="line">├── minmax_create_time.idx</span><br><span class="line">├── partition.dat</span><br><span class="line">├── primary.idx</span><br><span class="line">├── ttl.txt</span><br><span class="line">├── type.bin</span><br><span class="line">└── type.mrk2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看ttl.txt信息</span></span><br><span class="line">cat ttl.txt </span><br><span class="line">ttl format version: 1</span><br><span class="line">&#123;<span class="string">"columns"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"code"</span>,<span class="string">"min"</span>:1595917713,<span class="string">"max"</span>:1595917713&#125;,&#123;<span class="string">"name"</span>:<span class="string">"type"</span>,<span class="string">"min"</span>:1595917713,<span class="string">"max"</span>:1595917713&#125;],<span class="string">"table"</span>:&#123;<span class="string">"min"</span>:1596004103,<span class="string">"max"</span>:1596004103&#125;&#125;</span><br></pre></td></tr></table></figure><p>​    通过ttl.txt内容可以发现，MergeTree时通过一串JSON配置保存了ttl的相关信息，其中：</p><ul><li>columns：用于保存列级别ttl的信息</li><li>table：用于表示表级别ttl的信息</li><li>min和max：保存了当前数据分区内，TTL指定日期字段的最小值、最大值分别与INVERTAL表达式计算后的时间戳。</li></ul><p>将table属性中的min和max时间戳格式化，并分别和create_time最小值与最大值对比：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    toDateTime(<span class="string">'1596004103'</span>) <span class="keyword">AS</span> ttl_min, </span><br><span class="line">    toDateTime(<span class="string">'1596004103'</span>) <span class="keyword">AS</span> ttl_max, </span><br><span class="line">    ttl_min - <span class="keyword">MIN</span>(create_time) <span class="keyword">AS</span> expire_min, </span><br><span class="line">    ttl_max - <span class="keyword">MAX</span>(create_time) <span class="keyword">AS</span> expire_max</span><br><span class="line"><span class="keyword">FROM</span> ttl_table_t2</span><br><span class="line"></span><br><span class="line">┌─────────────ttl_min─┬─────────────ttl_max─┬─expire_min─┬─expire_max─┐</span><br><span class="line">│ <span class="number">2020</span><span class="number">-07</span><span class="number">-29</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">23</span> │ <span class="number">2020</span><span class="number">-07</span><span class="number">-29</span> <span class="number">14</span>:<span class="number">28</span>:<span class="number">23</span> │      <span class="number">86400</span> │      <span class="number">86400</span> │</span><br><span class="line">└─────────────────────┴─────────────────────┴────────────┴────────────┘</span><br></pre></td></tr></table></figure><hr><p><strong>TTL的处理逻辑：</strong></p><ul><li>MergeTree以分区目录为单位，通过分区内的ttl.txt文件记录过期时间，并最为后续的判断依据</li><li>当写入一批数据时，都会给予INTERVAL表达式的计算结果为这个分区生成对应的ttl.txt文件</li><li>在MergeTree进行合并分区时，会触发删除TTL过期数据的逻辑</li><li>在选择删除的分区时，使用了贪婪算法：尽可能找到会最早过期，合并次数最多的分区(MaxBlockNum)最大</li><li>如果一个分区内某一列数据因为TTL到期被全部删除，在合并之后的新分区目录中，不会包含这个列字段的数据文件(column.bin和column.mrk)</li></ul><p>ClickHouse针对列级别和表级别的TTL目前都没有提供删除TTL策略的方法，仅提供了全局开启/关闭TTL的方法：<code>SYSTEM START/STOP TTL MERGES;</code>，而且该配置并不能指定某张表开启或关闭TTL。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、数据TTL&quot;&gt;&lt;a href=&quot;#一、数据TTL&quot; class=&quot;headerlink&quot; title=&quot;一、数据TTL&quot;&gt;&lt;/a&gt;一、数据TTL&lt;/h2&gt;&lt;p&gt;​    TTL(Time to Live)，表示数据的存活时间。在MergeTree中，可以为某个
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
      <category term="MergeTree" scheme="https://schnappi618.github.io/tags/MergeTree/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎之MergeTree引擎——数据标记</title>
    <link href="https://schnappi618.github.io/2020/07/20/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0/"/>
    <id>https://schnappi618.github.io/2020/07/20/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0/</id>
    <published>2020-07-20T15:15:56.000Z</published>
    <updated>2020-07-27T12:52:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、数据标记文件的作用"><a href="#一、数据标记文件的作用" class="headerlink" title="一、数据标记文件的作用"></a>一、数据标记文件的作用</h2><p>​    在MergeTree中，保存数据的物理文件包括索引文件primary.idx、column.bin数据文件和column.mrk数据标记文件(若使用了自适应大小的索引间隔，则标记文件会为column.mrk2)，这三种文件帮助人们快速找到需要的数据。如果把MergeTree看为一本书，primary.idx一级索引文件类似于书的一级章节目录，column.bin文件中的数据类似书中具体的文字，而数据标记文件则将一级章节目录和具体文字关联起来。</p><p>​    对于数据标记而言，它记录了两个信息：一是一级章节对应的页码信息；二是对应的文字在某一页中的起始位置信息。通过数据标记文件就可以很快的翻到关注内容所在的页，并知道从第几行开始阅读。</p><h2 id="二、数据标记的生成规则"><a href="#二、数据标记的生成规则" class="headerlink" title="二、数据标记的生成规则"></a>二、数据标记的生成规则</h2><p>​    数据标记文件、一级索引的对应关系大致如下：</p><img src="/2020/07/20/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0/biaoji_1.svg" style="zoom:70%;"><p>​    从上图可以看出列数据标记和索引区间是对齐的，都按照index_granularity(默认8192)索引粒度间隔，故通过索引区间的下标编号就可以直接找到对应的数据标记。</p><p>​    数据标记文件也和column.bin文件一一对应，每一个列字段都有一个对应的column.mrk数据标记文件，用于记录数据在column.bin文件中的偏移量信息。一行标记数据用一个元组表示，元组内包含了两个整型数值的偏移量信息：某段数据区间内，对应的column.bin压缩文件中，压缩数据块的起始偏移量；未压缩数据的起始偏移量。对应关系如下表所示：</p><table><thead><tr><th>编号</th><th>压缩文件中的偏移量</th><th>解压缩块中的偏移量</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>0</td><td>8192</td></tr><tr><td>2</td><td>0</td><td>16384</td></tr><tr><td>3</td><td>0</td><td>24576</td></tr><tr><td>4</td><td>0</td><td>32768</td></tr><tr><td>5</td><td>0</td><td>40960</td></tr><tr><td>6</td><td>0</td><td>49152</td></tr><tr><td>7</td><td>0</td><td>57344</td></tr><tr><td>8</td><td>12016</td><td>0</td></tr><tr><td>9</td><td>12016</td><td>8192</td></tr></tbody></table><p>​    这里使用了之前MergeTree引擎——数据存储中的示例数据，可以看到在示例数据中，第0个压缩块的大小是12000，而在上表中对应的第0个压缩数据块的截止偏移量是12016，在数据存储的文章中我们知道，压缩数据块包含了压缩数据和头信息，并且为了让读取粒度进一步精确到压缩数据块，加载数据还包含了下一个压缩数据块的头文件，一个压缩数据块的头信息固定由9个字节组成，压缩后大小为8字节，所以这里截止偏移量就为8+12000+8=12016.</p><p>​    由表中还可以看出，每一行标记数据都表示了一个片段的数据(默认8192行)在column.bin压缩文件中的读取位置信息。标记数据和一级索引数据不同，它不能常驻于内存中，clickhouse使用了LRU(最近最少使用)缓存策略加快其获取速度。</p><h2 id="三、数据标记的工作方式"><a href="#三、数据标记的工作方式" class="headerlink" title="三、数据标记的工作方式"></a>三、数据标记的工作方式</h2><p>​    MergeTree读取数据时，需要通过标记数据的位置信息再找到需要的数据，整个查找过程大致分为读取压缩数据块和读取数据两个步骤</p><img src="/2020/07/20/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E6%A0%87%E8%AE%B0/biaoji2.jpg" style="zoom:67%;"><p>​    上图为ClickHouse官方提供的hits_v1测试表中，JavaEnable字段标记文件和压缩数据文件的对应关系示例。由于测试表中JavaEnable字段的数据类型为UInt8，该列每行数据大小为1字节，hits_v1表的索引粒度index_granularity为8192，所以一个索引片段的数据大小为8192字节。按照压缩数据块的生成规则，当数据大小在64KB～1MB之间时，生成一个压缩数据块(64K=65536字节，65536/5192=8)，所以在该JavaEnable的标记文件中，每8行标记数据对应一个压缩数据块，故从图中可以看到，在标记文件中，压缩文件中8行数据的偏移量相同，这8行标记指向了同一个压缩数据块。由于每一个片段的数据大小都为8192字节，所以解压缩块中每8行的偏移量都按照8192的大小递增，到第9行时，又会置为0，这是由于从这里开始，又生成了下一个压缩数据块。</p><p><strong>MergeTree定位压缩数据块并读取数据：</strong></p><ol><li><p>读取压缩数据块</p><p>在查询某一列数据时，MergeTree不需要一次性加载所有column.bin文件，而可以根据需要，借助标记文件中保存的压缩数据偏移量只加载特定的数据块。</p><p>在上图示例中，上下相邻两个压缩文件的起始偏移量，构成了获取当前标记对应压缩块的偏移量区间。由当前标记数据开始，向下找到不同的压缩文件偏移量为止，此时获得的一组偏移量区间，就是压缩数据块在column.bin数据文件中的偏移量。例如在上图中，读取.bin文件中[0, 12016]字节数据，就能得到第0个压缩数据块的数据。</p></li><li><p>读取数据</p><p>在读取数据时，MergeTree也可以根据需要借助标记文件中保存的解压缩块中的偏移量，以index_granularity的索引粒度加载特定的一小段。标记数据中，上下相邻的两个解压缩块中的偏移起始量，构成了获取当前标记对应数据的偏移量区间。通过这个区间，能在它的压缩块解压之后，按照偏移量按需读取数据。例如，在图中，通过[0, 8192]便能够读取压缩块0中的第一个数据片段。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、数据标记文件的作用&quot;&gt;&lt;a href=&quot;#一、数据标记文件的作用&quot; class=&quot;headerlink&quot; title=&quot;一、数据标记文件的作用&quot;&gt;&lt;/a&gt;一、数据标记文件的作用&lt;/h2&gt;&lt;p&gt;​    在MergeTree中，保存数据的物理文件包括索引文件pr
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
      <category term="MergeTree" scheme="https://schnappi618.github.io/tags/MergeTree/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎之MergeTree引擎——数据存储</title>
    <link href="https://schnappi618.github.io/2020/07/12/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    <id>https://schnappi618.github.io/2020/07/12/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</id>
    <published>2020-07-12T07:21:13.000Z</published>
    <updated>2020-07-20T16:45:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、按列存储"><a href="#一、按列存储" class="headerlink" title="一、按列存储"></a>一、按列存储</h2><p>​    在MergeTree中，数据按列存储，每个字段也独立单独存储，每个列字段均拥有一个对应的column.bin数据文件，这些数据文件便为数据的物理存储。数据文件以分区目录的形式被组织存放，所以每个分区目录中的bin文件只保存了当前分区片段内的该列数据。按列独立存储有利于更好的进行数据压缩(相同类型数据存放在一起)，还可以最小化需扫描数据的范围。</p><p>​    MergeTree会将经过压缩的数据存放到对应column.bin文件中，默认使用LZ4算法，然后将数据按照声明的ORDER BY排序。最后，数据会以压缩数据块的方式被有序的写入数据文件中的。</p><h2 id="二、压缩数据块"><a href="#二、压缩数据块" class="headerlink" title="二、压缩数据块"></a>二、压缩数据块</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>​    一个压缩数据块由头信息和压缩数据两部分组成。头信息固定使用9位字节表示，具体由1个UInt8(1字节)和2个UInt32(4字节)整型组成，分别代表了使用的压缩算法类型、压缩后的数据大小和压缩前的数据大小，具体格式如图所示：</p><img src="/2020/07/12/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/cunchu_1.svg" width="50%"><p>​    从上图可以看出，column.bin文件由多个压缩数据块组成，每个压缩数据块的头部信息是基于CompressionMethod_CompressedSize_UncompressedSize公式生成，可通过ClickHouse提供的clickhouse-compressor工具查询到某个.bin文件中压缩数据的统计信息。这里以官方提供的测试数据hit_v1为例，执行该命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-compressor --<span class="built_in">stat</span> &lt;  /var/lib/clickhouse/data/datasets/hits_v1/201403_1_32_2/JavaEnable.bin </span><br><span class="line"><span class="comment">## 结果如下，每一行数据表示一个压缩数据块的头信息，分表表示该压缩数据块中未压缩数据大小和压缩后数据大小(打印信息和物理存储的顺序刚好相反)</span></span><br><span class="line">65536   12000</span><br><span class="line">65536   14661</span><br><span class="line">65536   4936</span><br><span class="line">65536   7506</span><br><span class="line">65536   18660</span><br><span class="line">65536   14892</span><br><span class="line">65536   17474</span><br><span class="line">65536   13464</span><br><span class="line">65536   14999</span><br><span class="line">...</span><br><span class="line">72776   1546</span><br><span class="line">68558   12639</span><br><span class="line">72089   11184</span><br><span class="line">71612   6945</span><br><span class="line">65857   11135</span><br><span class="line">7963    1559</span><br></pre></td></tr></table></figure><p>​    每个压缩数据块的体积，按照其压缩前的数据字节大小，被严格控制在64KB～1MB之间，上下限大小由<code>min_compress_block_size(默认65536)</code>和<code>max_compress_block_size(默认1048576)</code>参数指定。而每一个压缩数据块最终大小，则和一个index_granularity内实际的数据大小有关。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> * <span class="keyword">from</span> system.settings <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%_compress_block_size%'</span>\G</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> system.settings</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%_compress_block_size%'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Row</span> <span class="number">1</span>:</span><br><span class="line">──────</span><br><span class="line"><span class="keyword">name</span>:        min_compress_block_size</span><br><span class="line"><span class="keyword">value</span>:       <span class="number">65536</span></span><br><span class="line"><span class="keyword">changed</span>:     <span class="number">0</span></span><br><span class="line">description: The actual <span class="keyword">size</span> <span class="keyword">of</span> the <span class="keyword">block</span> <span class="keyword">to</span> <span class="keyword">compress</span>, <span class="keyword">if</span> the uncompressed <span class="keyword">data</span> <span class="keyword">less</span> <span class="keyword">than</span> max_compress_block_size <span class="keyword">is</span> <span class="keyword">no</span> <span class="keyword">less</span> <span class="keyword">than</span> this <span class="keyword">value</span> <span class="keyword">and</span> <span class="keyword">no</span> <span class="keyword">less</span> <span class="keyword">than</span> the volume <span class="keyword">of</span> <span class="keyword">data</span> <span class="keyword">for</span> one mark.</span><br><span class="line"><span class="keyword">min</span>:         ᴺᵁᴸᴸ</span><br><span class="line"><span class="keyword">max</span>:         ᴺᵁᴸᴸ</span><br><span class="line">readonly:    <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Row</span> <span class="number">2</span>:</span><br><span class="line">──────</span><br><span class="line"><span class="keyword">name</span>:        max_compress_block_size</span><br><span class="line"><span class="keyword">value</span>:       <span class="number">1048576</span></span><br><span class="line"><span class="keyword">changed</span>:     <span class="number">0</span></span><br><span class="line">description: The maximum <span class="keyword">size</span> <span class="keyword">of</span> blocks <span class="keyword">of</span> uncompressed <span class="keyword">data</span> <span class="keyword">before</span> compressing <span class="keyword">for</span> writing <span class="keyword">to</span> a table.</span><br><span class="line"><span class="keyword">min</span>:         ᴺᵁᴸᴸ</span><br><span class="line"><span class="keyword">max</span>:         ᴺᵁᴸᴸ</span><br><span class="line">readonly:    <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure><h3 id="2、压缩规则及流程"><a href="#2、压缩规则及流程" class="headerlink" title="2、压缩规则及流程"></a>2、压缩规则及流程</h3><p>​    MergeTree在数据存储过程中，会遵循以下规则：</p><ul><li>单个索引粒度间隔数据size &lt; 64KB：如果单个索引粒度数据大小小于64KB，则继续获取下一个索引粒度的数据，一直到size &gt;= 64KB，生成下一个压缩数据块。</li><li>单个索引粒度间隔数据 64KB &lt;= size &lt;= 1MB：如果单个索引粒度数据大小大于64KB，小于1MB，则直接生成下一个压缩数据块</li><li>单个索引粒度间隔数据 size &gt; 1MB：如果单个索引粒度数据大小超过1MB，则先按照1MB大小截断并生成下一个压缩数据块，剩余数据按照这三个规则对应执行。这时就会出现一批数据生成多个压缩数据块的情况。</li></ul><p><img src="/2020/07/12/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/cunchu_2.svg"></p><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>​    一个column.bin文件是由一个到多个压缩数据块组成的，每个压缩数据块大小在64KB～1MB之间。多个压缩数据块之间，按照写入顺序首尾相接，紧密排列在一起。数据被压缩后可以减少数据大小，降低存储空间并且加快数据的传输效率，但数据的压缩和解压动作，本身也会带来额外的性能损耗，所以需要控制被压缩数据的大小。另外，在具体读取某一列的压缩数据时，首先需要将压缩数据(包含了整个压缩数据块以及下个压缩数据块的头文件)加载到内存并解压，再进行后续的数据处理。通过压缩数据块，可以在不读取整个.bin文件的情况下将读取粒度降低到压缩数据块级别，进一步缩小了数据读取的范围。</p><img src="/2020/07/12/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/cunchu_3.png" style="zoom:67%;">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、按列存储&quot;&gt;&lt;a href=&quot;#一、按列存储&quot; class=&quot;headerlink&quot; title=&quot;一、按列存储&quot;&gt;&lt;/a&gt;一、按列存储&lt;/h2&gt;&lt;p&gt;​    在MergeTree中，数据按列存储，每个字段也独立单独存储，每个列字段均拥有一个对应的colum
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
      <category term="MergeTree" scheme="https://schnappi618.github.io/tags/MergeTree/"/>
    
  </entry>
  
  <entry>
    <title>简述ClickHouse数据类型</title>
    <link href="https://schnappi618.github.io/2020/07/12/clickhouse/%E7%AE%80%E8%BF%B0ClickHouse%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://schnappi618.github.io/2020/07/12/clickhouse/%E7%AE%80%E8%BF%B0ClickHouse%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-07-12T02:54:10.000Z</published>
    <updated>2020-07-12T12:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    ClickHouse作为一个DBMS，提供了DDL和DML的功能，并支持部分标准的SQL语法。但ClickHouse在基础数据方面，既提供了常规的数据类型、字符串类型格式，又提供了一些常用的复合类型(数组、元组等)，并且与常规的数据库，在DML的使用上也存在不同(例如：UPDATE和DELETE是借助ALTER实现的)。本文将简单介绍ClickHouse所提供的各种数据类型。</p><h2 id="一、ClickHouse的数据类型"><a href="#一、ClickHouse的数据类型" class="headerlink" title="一、ClickHouse的数据类型"></a>一、ClickHouse的数据类型</h2><p>​    <strong>ClickHouse提供了许多数据类型，可以分为基础类型、符合类型和特殊类型</strong>，可进入clickhouse数据库中，通过<code>select * from system.data_type_families</code>查询所支持的所有数据类型。</p><h2 id="二、基础数据类型"><a href="#二、基础数据类型" class="headerlink" title="二、基础数据类型"></a>二、基础数据类型</h2><p>​    ClickHouse基础数据类型可分为数值、字符串和时间三种类型，没有Boolean类型，可用整型的0和1来替代。</p><h3 id="1、数值型"><a href="#1、数值型" class="headerlink" title="1、数值型"></a>1、数值型</h3><p>数值型可分为Int、Float和Decimal三种类型</p><h4 id="1-1-Int"><a href="#1-1-Int" class="headerlink" title="1.1 Int"></a>1.1 Int</h4><p>​    在MySQL中，使用Tinyint、smallint、int和bigint来指代整数类型的取值。ClickHouse中使用了Int8、Int16、Int32、Int64来分别指代不同大小的Int类型(末尾数字表明占用字节大小，1字节=8位)，具体对比关系如下：</p><table><thead><tr><th align="center">名称</th><th align="center">字节大小</th><th>范围</th><th align="center">MySQL</th></tr></thead><tbody><tr><td align="center">Int8</td><td align="center">1</td><td>-128到127</td><td align="center">Tinyint</td></tr><tr><td align="center">Int16</td><td align="center">2</td><td>-32768到32767</td><td align="center">Smallint</td></tr><tr><td align="center">Int32</td><td align="center">4</td><td>-2147483648到214783647</td><td align="center">Int</td></tr><tr><td align="center">Int64</td><td align="center">8</td><td>-9223372036854775808到9223372036854775807</td><td align="center">Bigint</td></tr><tr><td align="center">UInt8</td><td align="center">1</td><td>0到255</td><td align="center">Tinyint Unsinged</td></tr><tr><td align="center">UInt16</td><td align="center">2</td><td>0到65535</td><td align="center">Smallint Unsigned</td></tr><tr><td align="center">UInt32</td><td align="center">4</td><td>0到4294967295</td><td align="center">Int Unsigned</td></tr><tr><td align="center">UInt64</td><td align="center">8</td><td>0到18446744073709551615</td><td align="center">Bigint Unsigned</td></tr></tbody></table><h4 id="1-2-Float"><a href="#1-2-Float" class="headerlink" title="1.2 Float"></a>1.2 Float</h4><p>​    ClickHouse使用了Float32和Float64来代表单精度浮点数一级双精度浮点数，具体对比关系如下，使用浮点数会引起四舍五入的误差：</p><table><thead><tr><th align="center">名称</th><th align="center">大小(字节)</th><th align="center">有效精度(位数)</th><th align="center">C语言类型</th></tr></thead><tbody><tr><td align="center">Float32</td><td align="center">4</td><td align="center">7</td><td align="center">float</td></tr><tr><td align="center">Float64</td><td align="center">8</td><td align="center">16</td><td align="center">Double</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 转换为Float32类型</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> toFloat32(<span class="string">'0.123456789098765432'</span>) <span class="keyword">as</span> a, toTypeName(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    toFloat32(<span class="string">'0.123456789098765432'</span>) <span class="keyword">AS</span> a, </span><br><span class="line">    toTypeName(a)</span><br><span class="line"></span><br><span class="line">┌──────────a─┬─toTypeName(toFloat32(<span class="string">'0.123456789098765432'</span>))─┐</span><br><span class="line">│ <span class="number">0.12345679</span> │ Float32                                       │</span><br><span class="line">└────────────┴───────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 转换为Float64类型</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> toFloat64(<span class="string">'0.123456789098765432'</span>) <span class="keyword">as</span> a, toTypeName(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    toFloat64(<span class="string">'0.123456789098765432'</span>) <span class="keyword">AS</span> a, </span><br><span class="line">    toTypeName(a)</span><br><span class="line"></span><br><span class="line">┌───────────────────a─┬─toTypeName(toFloat64(<span class="string">'0.123456789098765432'</span>))─┐</span><br><span class="line">│ <span class="number">0.12345678909876544</span> │ Float64                                       │</span><br><span class="line">└─────────────────────┴───────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.003</span> sec.</span><br></pre></td></tr></table></figure><p>​    和标准的SQL相比，ClickHouse还支持了以下类别的浮点数：</p><ul><li><p>Inf：正无穷</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> <span class="number">0.5</span>/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">0.5</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line">┌─divide(<span class="number">0.5</span>, <span class="number">0</span>)─┐</span><br><span class="line">│            inf │</span><br><span class="line">└────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.007</span> sec.</span><br></pre></td></tr></table></figure></li><li><p>-Inf：负无穷</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> <span class="number">-0.5</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">-0.5</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line">┌─divide(<span class="number">-0.5</span>, <span class="number">0</span>)─┐</span><br><span class="line">│            -inf │</span><br><span class="line">└─────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.001</span> sec.</span><br></pre></td></tr></table></figure></li><li><p>NaN：非数字</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> <span class="number">0</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">0</span> / <span class="number">0</span></span><br><span class="line"></span><br><span class="line">┌─divide(<span class="number">0</span>, <span class="number">0</span>)─┐</span><br><span class="line">│          <span class="keyword">nan</span> │</span><br><span class="line">└──────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-3-Decimal"><a href="#1-3-Decimal" class="headerlink" title="1.3 Decimal"></a>1.3 Decimal</h4><p>​    在高精度的数值运算中，会使用Decimal类型。ClickHouse提供了Decimal32、Decimal64和Decimal128三种精度的定点数，可通过<code>Decimal(P, S)</code>或简写<code>Decimal32(S), Decimal64(S), Decimal128(S)</code>来表示定义，参数含义如下：</p><ul><li>P表示精度，有效范围为[1, 38]，决定总位数(整数部分+小数部分)</li><li>S表示规模，有效范围为[0, P]，决定小数位数</li></ul><p>简写方式和原生方式的对应如下：</p><table><thead><tr><th align="center">简写</th><th align="center">原生</th><th align="center">范围</th></tr></thead><tbody><tr><td align="center">Decimal32(S)</td><td align="center">Decimal(1~9, S)</td><td align="center">$-1 * 10^(9 - S)$ 到 $1 * 10^(9 - S)$</td></tr><tr><td align="center">Decimal64(S)</td><td align="center">Decimal(10~18, S)</td><td align="center">$-1 * 10^(18 - S)$ 到 $1 * 10^(18 - S)$</td></tr><tr><td align="center">Decimal128(S)</td><td align="center">Decimal(19~38, S)</td><td align="center">$-1 * 10^(38 - S)$ 到 $1 * 10^(38 - S)$</td></tr></tbody></table><p>​    使用两个不同精度的定点数进行元算的话，他们小数位数S会发生变化：</p><ul><li>加法：S = max(S1, S2)</li><li>减法：S = max(S1, S2)</li><li>乘法：S = S1 + S2</li><li>除法：S = S1  (S1 为被除数，且被除数S1必须大于除数S2，即S1 / S2)</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 加法示例</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> toDecimal32(<span class="number">2</span>,<span class="number">4</span>) + toDecimal64(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> toDecimal32(<span class="number">2</span>, <span class="number">4</span>) + toDecimal64(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">┌─plus(toDecimal32(<span class="number">2</span>, <span class="number">4</span>), toDecimal64(<span class="number">2</span>, <span class="number">2</span>))─┐</span><br><span class="line">│                                     <span class="number">4.0000</span> │</span><br><span class="line">└────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.006</span> sec. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 减法示例</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> toDecimal32(<span class="number">4</span>, <span class="number">6</span>) - toDecimal64(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> toDecimal32(<span class="number">4</span>, <span class="number">6</span>) - toDecimal64(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">┌─<span class="keyword">minus</span>(toDecimal32(<span class="number">4</span>, <span class="number">6</span>), toDecimal64(<span class="number">2</span>, <span class="number">2</span>))─┐</span><br><span class="line">│                                    <span class="number">2.000000</span> │</span><br><span class="line">└─────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.003</span> sec. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 乘法示例</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> toDecimal64(<span class="number">4</span>, <span class="number">4</span>) * toDecimal32(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> toDecimal64(<span class="number">4</span>, <span class="number">4</span>) * toDecimal32(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">┌─multiply(toDecimal64(<span class="number">4</span>, <span class="number">4</span>), toDecimal32(<span class="number">2</span>, <span class="number">2</span>))─┐</span><br><span class="line">│                                       <span class="number">8.000000</span> │</span><br><span class="line">└────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 除法示例</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> toDecimal64(<span class="number">4</span>, <span class="number">4</span>) / toDecimal32(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> toDecimal64(<span class="number">4</span>, <span class="number">4</span>) / toDecimal32(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">┌─divide(toDecimal64(<span class="number">4</span>, <span class="number">4</span>), toDecimal32(<span class="number">2</span>, <span class="number">2</span>))─┐</span><br><span class="line">│                                       <span class="number">2.0000</span> │</span><br><span class="line">└──────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.003</span> sec.</span><br></pre></td></tr></table></figure><p><strong>溢出检查：</strong></p><p>对Decimal进行操作时，数值可能会发生溢出。小数部分过多数字会被丢弃(不是四舍五入)，整数数字过多会导致异常。可通过设置<code>decimal_check_overflow</code>来关闭溢出检查，但溢出会导致结果不正确，而且会让计算变慢。在比较计算上也会发生溢出。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 数值溢出，x/3的结果本应为无限循环小数，只保留了S位，其余小数被丢弃</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">SELECT</span> toDecimal32(<span class="number">2</span>, <span class="number">4</span>) <span class="keyword">AS</span> x, x / <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    toDecimal32(<span class="number">2</span>, <span class="number">4</span>) <span class="keyword">AS</span> x, </span><br><span class="line">    x / <span class="number">3</span></span><br><span class="line"></span><br><span class="line">┌──────x─┬─divide(toDecimal32(<span class="number">2</span>, <span class="number">4</span>), <span class="number">3</span>)─┐</span><br><span class="line">│ <span class="number">2.0000</span> │                       <span class="number">0.6666</span> │</span><br><span class="line">└────────┴──────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 整数部分溢出导致报错</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">SELECT</span> toDecimal32(<span class="number">4.2</span>, <span class="number">8</span>) <span class="keyword">AS</span> x, x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    toDecimal32(<span class="number">4.2</span>, <span class="number">8</span>) <span class="keyword">AS</span> x, </span><br><span class="line">    x * x</span><br><span class="line"></span><br><span class="line">Received <span class="keyword">exception</span> <span class="keyword">from</span> <span class="keyword">server</span> (<span class="keyword">version</span> <span class="number">20.3</span><span class="number">.4</span>):</span><br><span class="line">Code: <span class="number">69.</span> DB::<span class="keyword">Exception</span>: Received <span class="keyword">from</span> localhost:<span class="number">9000.</span> DB::<span class="keyword">Exception</span>: Scale <span class="number">16</span> <span class="keyword">is</span> <span class="keyword">out</span> <span class="keyword">of</span> bounds. </span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.005</span> sec. </span><br><span class="line"></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">SELECT</span> toDecimal32(<span class="number">4.2</span>, <span class="number">8</span>) <span class="keyword">AS</span> x, <span class="number">6</span> * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    toDecimal32(<span class="number">4.2</span>, <span class="number">8</span>) <span class="keyword">AS</span> x, </span><br><span class="line">    <span class="number">6</span> * x</span><br><span class="line"></span><br><span class="line">Received <span class="keyword">exception</span> <span class="keyword">from</span> <span class="keyword">server</span> (<span class="keyword">version</span> <span class="number">20.3</span><span class="number">.4</span>):</span><br><span class="line">Code: <span class="number">407.</span> DB::<span class="keyword">Exception</span>: Received <span class="keyword">from</span> localhost:<span class="number">9000.</span> DB::<span class="keyword">Exception</span>: <span class="built_in">Decimal</span> math overflow. </span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 关闭溢出检查</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">SET</span> decimal_check_overflow = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> decimal_check_overflow = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.001</span> sec. </span><br><span class="line"></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">SELECT</span> toDecimal32(<span class="number">4.2</span>, <span class="number">8</span>) <span class="keyword">AS</span> x, <span class="number">6</span> * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    toDecimal32(<span class="number">4.2</span>, <span class="number">8</span>) <span class="keyword">AS</span> x, </span><br><span class="line">    <span class="number">6</span> * x</span><br><span class="line"></span><br><span class="line">┌──────────x─┬─multiply(<span class="number">6</span>, toDecimal32(<span class="number">4.2</span>, <span class="number">8</span>))─┐</span><br><span class="line">│ <span class="number">4.20000000</span> │                     <span class="number">-17.74967296</span> │</span><br><span class="line">└────────────┴──────────────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 比较，溢出提示Can't compare</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">SELECT</span> toDecimal32(<span class="number">1</span>, <span class="number">8</span>) &lt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> toDecimal32(<span class="number">1</span>, <span class="number">8</span>) &lt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line">Received <span class="keyword">exception</span> <span class="keyword">from</span> <span class="keyword">server</span> (<span class="keyword">version</span> <span class="number">20.3</span><span class="number">.4</span>):</span><br><span class="line">Code: <span class="number">407.</span> DB::<span class="keyword">Exception</span>: Received <span class="keyword">from</span> localhost:<span class="number">9000.</span> DB::<span class="keyword">Exception</span>: Can<span class="string">'t compare. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0 rows in set. Elapsed: 0.010 sec.</span></span><br></pre></td></tr></table></figure><hr><h3 id="2、字符串类型"><a href="#2、字符串类型" class="headerlink" title="2、字符串类型"></a>2、字符串类型</h3><p>字符串类型可分为String、FixedString和UUID类型。</p><h4 id="2-1-String"><a href="#2-1-String" class="headerlink" title="2.1 String"></a>2.1 String</h4><p>字符串由String类型定义，无长度限制。在使用时也不需要声明大小，代替了其他数据库上的Varchar、Text、Blob等自负类型。而且String类型不限制字符集限制，可以写入任意编码的字符串，但为了标准统一化开发管理，官方建议一套程序中应使用统一的编码类型。</p><h4 id="2-2-FixedString"><a href="#2-2-FixedString" class="headerlink" title="2.2 FixedString"></a>2.2 FixedString</h4><p>FixedString和传统的char类型类似，用来定义一些固定长度的字符串。通过<code>FixedString(N)</code>来定义声明，N表示字符串长度，当数据长度小于N字节时，会降低一定效率。但Char类型通常使用空格填充末尾字符，而FixedString用null字节来填充。</p><ul><li>当向ClickHouse中插入数据时<ul><li>如果字符串包含字节数少于N，将用null字节来填充</li><li>如果字符串包含字节数大于N，将抛出<code>Too large value for FixedString(N)</code>的异常</li></ul></li><li>当查询数据时<ul><li>ClickHouse不会删除字符串末尾的空字节，如果使用WHERE子句，则<strong>需要手动添加空字节来匹配FixedString的值</strong></li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建一个用来测试的表，并插入测试数据，若没有test库则需要create database test来进行创建</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">use</span> <span class="keyword">test</span></span><br><span class="line"></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">create</span> <span class="keyword">table</span> FixedStringTest ( a FixedString(<span class="number">2</span>) ) <span class="keyword">engine</span>=MergeTree <span class="keyword">order</span> <span class="keyword">by</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 插入正常数据</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">insert</span> <span class="keyword">into</span> FixedStringTest <span class="keyword">values</span> (<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 插入大于N数据</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">insert</span> <span class="keyword">into</span> FixedStringTest <span class="keyword">values</span> (<span class="string">'abc'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 查询数据</span></span><br><span class="line"><span class="comment">-- where查询时并不会自动删除后面的null，所以无法得到想要的结果</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> * <span class="keyword">from</span> FixedStringTest <span class="keyword">where</span> a = <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> FixedStringTest</span><br><span class="line"><span class="keyword">WHERE</span> a = <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询可看到，长度为2</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> a, <span class="keyword">length</span>(a) <span class="keyword">from</span> FixedStringTest</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    a, </span><br><span class="line">    <span class="keyword">length</span>(a)</span><br><span class="line"><span class="keyword">FROM</span> FixedStringTest</span><br><span class="line"></span><br><span class="line">┌─a─┬─<span class="keyword">length</span>(a)─┐</span><br><span class="line">│ a │         <span class="number">2</span> │</span><br><span class="line">└───┴───────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 需手动填充空字节用于where匹配</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> * <span class="keyword">from</span> FixedStringTest <span class="keyword">where</span> a = <span class="string">'a\0'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> FixedStringTest</span><br><span class="line"><span class="keyword">WHERE</span> a = <span class="string">'a\0'</span></span><br><span class="line"></span><br><span class="line">┌─a─┐</span><br><span class="line">│ a │</span><br><span class="line">└───┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure><h4 id="2-3-UUID"><a href="#2-3-UUID" class="headerlink" title="2.3 UUID"></a>2.3 UUID</h4><p>UUID经常会在数据库中使用，有时候还会作为主键，ClickHouse直接将UUID作为了一种数据类型。UUID一共有32位，格式为<code>8-4-4-4-12</code>,如果UUID类型的字段在写入数据时没有被赋值，则会按照格式用0来填充。ClickHouse还提供了<code>generateUUIDv4</code>来生成随机的UUID。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 创建测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_uuid (x <span class="keyword">UUID</span>, y <span class="keyword">String</span>) <span class="keyword">ENGINE</span>=TinyLog</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 插入UUID</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_uuid <span class="keyword">SELECT</span> generateUUIDv4(), <span class="string">'Example 1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 查询</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> * <span class="keyword">from</span> t_uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> t_uuid</span><br><span class="line"></span><br><span class="line">┌────────────────────────────────────x─┬─y─────────┐</span><br><span class="line">│ a603876a<span class="number">-38</span>cb<span class="number">-460</span>a-bafb-a08d4ab1b9c4 │ Example <span class="number">1</span> │</span><br><span class="line">└──────────────────────────────────────┴───────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 不指定UUID插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_uuid (y) <span class="keyword">VALUES</span> (<span class="string">'Example 2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> * <span class="keyword">from</span> t_uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> t_uuid</span><br><span class="line"></span><br><span class="line">┌────────────────────────────────────x─┬─y─────────┐</span><br><span class="line">│ a603876a<span class="number">-38</span>cb<span class="number">-460</span>a-bafb-a08d4ab1b9c4 │ Example <span class="number">1</span> │</span><br><span class="line">│ <span class="number">00000000</span><span class="number">-0000</span><span class="number">-0000</span><span class="number">-0000</span><span class="number">-000000000000</span> │ Example <span class="number">2</span> │</span><br><span class="line">└──────────────────────────────────────┴───────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure><h3 id="3、时间类型"><a href="#3、时间类型" class="headerlink" title="3、时间类型"></a>3、时间类型</h3><p>时间类型分为DateTime、DateTime64和Date三种。ClickHouse目前不存在时间戳类型，时间类型的最高精度到秒，所以若需要毫秒、微秒等时间，只能用UInt类型实现</p><h4 id="3-1-DateTime"><a href="#3-1-DateTime" class="headerlink" title="3.1 DateTime"></a>3.1 DateTime</h4><p>DateTime类型精确到秒，可表示的时间范围为<code>[&#39;1970-01-01 00:00:00&#39;, &#39;2105-12-31 23:59:59&#39;]</code>，创建表时，可以为DateTime的列显示设置失去，如果未为表设置失去，启动ClickHouse服务时，它将使用系统设置中的timezone参数，也可以使用<code>--use_client_time_zone</code>参数来启动clickhouse-client，默认格式为<code>YYYY-MM-DD hh:mm:ss</code>输出至，也可以使用<code>formatDateTime</code>函数来更改输出，插入数据时格式则取决于<code>date_time_input_format</code>的设置。</p><p><strong>1. 创建设置了DateTime类型列的表并插入数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dt ( <span class="string">`timestamp`</span> DateTime(<span class="string">'Asia/Shanghai'</span>), <span class="string">`event_id`</span> UInt8 ) <span class="keyword">ENGINE</span> = TinyLog;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dt <span class="keyword">Values</span> (<span class="number">1546300800</span>, <span class="number">1</span>), (<span class="string">'2020-07-12 00:00:00'</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> * <span class="keyword">from</span> dt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> dt</span><br><span class="line"></span><br><span class="line">┌───────────<span class="built_in">timestamp</span>─┬─event_id─┐</span><br><span class="line">│ <span class="number">2019</span><span class="number">-01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00</span> │        <span class="number">1</span> │</span><br><span class="line">│ <span class="number">2020</span><span class="number">-07</span><span class="number">-12</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │        <span class="number">2</span> │</span><br><span class="line">└─────────────────────┴──────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure><ul><li>将datetime插入为整数时，它会被视为Unix时间戳(UTC)，1546300800表示’2019-01-01 00:00:00’UTC，但由于timestamp列已指定了时区<code>Asia/Shanghai</code>，所以会显示为东八区时间<code>2019-01-01 08:00:00</code></li></ul><p><strong>2. 指定时区删选DateTime值</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dt <span class="keyword">WHERE</span> <span class="built_in">timestamp</span> = toDateTime(<span class="string">'2020-07-12 00:00:00'</span>, <span class="string">'Asia/Shanghai'</span>)</span><br><span class="line"><span class="comment">-- 结果为</span></span><br><span class="line">┌───────────<span class="built_in">timestamp</span>─┬─event_id─┐</span><br><span class="line">│ <span class="number">2020</span><span class="number">-07</span><span class="number">-12</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │        <span class="number">2</span> │</span><br><span class="line">└─────────────────────┴──────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 也可通过where字符串值过滤</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> dt <span class="keyword">WHERE</span> <span class="built_in">timestamp</span> = <span class="string">'2020-07-12 00:00:00'</span></span><br><span class="line">┌───────────<span class="built_in">timestamp</span>─┬─event_id─┐</span><br><span class="line">│ <span class="number">2020</span><span class="number">-07</span><span class="number">-12</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │        <span class="number">2</span> │</span><br><span class="line">└─────────────────────┴──────────┘</span><br></pre></td></tr></table></figure><p><strong>3. 获取DateTime列和时区类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> toDateTime(<span class="keyword">now</span>(), <span class="string">'Asia/Shanghai'</span>) <span class="keyword">AS</span> <span class="keyword">column</span>, toTypeName(<span class="keyword">column</span>) <span class="keyword">AS</span> x</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">┌──────────────<span class="keyword">column</span>─┬─x─────────────────────────┐</span><br><span class="line">│ <span class="number">2020</span><span class="number">-07</span><span class="number">-12</span> <span class="number">12</span>:<span class="number">41</span>:<span class="number">28</span> │ DateTime(<span class="string">'Asia/Shanghai'</span>) │</span><br><span class="line">└─────────────────────┴───────────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>4. 转换列时区</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> toDateTime(<span class="built_in">timestamp</span>, <span class="string">'Europe/London'</span>) <span class="keyword">as</span> lon_time, toDateTime(<span class="built_in">timestamp</span>, <span class="string">'Europe/Moscow'</span>) <span class="keyword">as</span> mos_time <span class="keyword">FROM</span> dt</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">┌────────────lon_time─┬────────────mos_time─┐</span><br><span class="line">│ <span class="number">2019</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> │ <span class="number">2019</span><span class="number">-01</span><span class="number">-01</span> <span class="number">03</span>:<span class="number">00</span>:<span class="number">00</span> │</span><br><span class="line">│ <span class="number">2020</span><span class="number">-07</span><span class="number">-11</span> <span class="number">17</span>:<span class="number">00</span>:<span class="number">00</span> │ <span class="number">2020</span><span class="number">-07</span><span class="number">-11</span> <span class="number">19</span>:<span class="number">00</span>:<span class="number">00</span> │</span><br><span class="line">└─────────────────────┴─────────────────────┘</span><br></pre></td></tr></table></figure><h4 id="3-2-DateTime64"><a href="#3-2-DateTime64" class="headerlink" title="3.2 DateTime64"></a>3.2 DateTime64</h4><p>DateTime64在DateTime类型基础上增加了精度设置，可以记录到亚秒，其余使用方法和DateTime相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dt64 (<span class="string">`timestamp`</span> DateTime64(<span class="number">3</span>, <span class="string">'Asia/Shanghai'</span>), <span class="string">`event_id`</span> UInt8 ) <span class="keyword">ENGINE</span> = TinyLog</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入测试数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dt64 <span class="keyword">Values</span> (<span class="number">1546300800000</span>, <span class="number">1</span>), (<span class="string">'2019-01-01 00:00:00'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询结果</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> dt64</span><br><span class="line"><span class="comment">-- 结果为</span></span><br><span class="line">┌───────────────<span class="built_in">timestamp</span>─┬─event_id─┐</span><br><span class="line">│ <span class="number">2019</span><span class="number">-01</span><span class="number">-01</span> <span class="number">08</span>:<span class="number">00</span>:<span class="number">00.000</span> │        <span class="number">1</span> │</span><br><span class="line">│ <span class="number">2019</span><span class="number">-01</span><span class="number">-01</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00.000</span> │        <span class="number">2</span> │</span><br><span class="line">└─────────────────────────┴──────────┘</span><br></pre></td></tr></table></figure><h4 id="3-3-Date"><a href="#3-3-Date" class="headerlink" title="3.3 Date"></a>3.3 Date</h4><p>Date类型不包含具体的时间，只精确到天，存储的日期值不带时区，同样支持字符串的形式写入。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> date_test(<span class="string">`c1`</span> <span class="built_in">Date</span>, <span class="string">`event_id`</span> UInt8 ) <span class="keyword">Engine</span> = TinyLog</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据，即使插入包含具体时间的值，也只会写入日期</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> date_test <span class="keyword">values</span> (<span class="string">'2019-01-01 00:00:00'</span>, <span class="number">1</span>), (<span class="string">'2020-07-12'</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> date_test</span><br><span class="line"><span class="comment">-- 结果为</span></span><br><span class="line">┌─────────c1─┬─event_id─┐</span><br><span class="line">│ <span class="number">2019</span><span class="number">-01</span><span class="number">-01</span> │        <span class="number">1</span> │</span><br><span class="line">│ <span class="number">2020</span><span class="number">-07</span><span class="number">-12</span> │        <span class="number">2</span> │</span><br><span class="line">└────────────┴──────────┘</span><br></pre></td></tr></table></figure><h2 id="三、复合类型"><a href="#三、复合类型" class="headerlink" title="三、复合类型"></a>三、复合类型</h2><p>除了数值、字符串和时间这些基础数据类型之外，ClickHouse还提供了数组、元组、枚举和嵌套四种复合类型。</p><h3 id="1、数组Array"><a href="#1、数组Array" class="headerlink" title="1、数组Array"></a>1、数组Array</h3><p>数组有两种定义形式：array(T)和[]</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">array</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">as</span> a, toTypeName(a)</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">┌─a─────┬─toTypeName([<span class="number">1</span>, <span class="number">2</span>])─┐</span><br><span class="line">│ [<span class="number">1</span>,<span class="number">2</span>] │ <span class="built_in">Array</span>(UInt8)       │</span><br><span class="line">└───────┴────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> [<span class="number">1</span>,<span class="number">2</span>] <span class="keyword">as</span> a, toTypeName(a)</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">┌─a─────┬─toTypeName([<span class="number">1</span>, <span class="number">2</span>])─┐</span><br><span class="line">│ [<span class="number">1</span>,<span class="number">2</span>] │ <span class="built_in">Array</span>(UInt8)       │</span><br><span class="line">└───────┴────────────────────┘</span><br></pre></td></tr></table></figure><p>可以看出，在查询时并不需要主动声明数组的元素类型，这是因为ClickHouse的数组拥有类型推断的能力。但在快速创建数组时，ClickHouse会自动将参数定义为最小的可表达的数据类型。例如若数组中存在NULL值，数组元素类型会变为Nullable。<strong>但在进行表定义时，数组需要指定明确的元素类型</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NULL</span>) <span class="keyword">AS</span> x, toTypeName(x)</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">┌─x──────────┬─toTypeName([<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NULL</span>])─┐</span><br><span class="line">│ [<span class="number">1</span>,<span class="number">2</span>,<span class="literal">NULL</span>] │ <span class="built_in">Array</span>(Nullable(UInt8))   │</span><br><span class="line">└────────────┴──────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表时需要指定类型</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> array_test(c1 <span class="built_in">Array</span>(<span class="keyword">String</span>)) <span class="keyword">engine</span> = TinyLog     <span class="comment">## 可创建成功，数据写入过程中会进行类型检查</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> array_test(c1 <span class="built_in">Array</span>) <span class="keyword">engine</span> = TinyLog     <span class="comment">## 会创建失败</span></span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">Received <span class="keyword">exception</span> <span class="keyword">from</span> <span class="keyword">server</span> (<span class="keyword">version</span> <span class="number">20.3</span><span class="number">.4</span>):</span><br><span class="line">Code: <span class="number">42.</span> DB::<span class="keyword">Exception</span>: Received <span class="keyword">from</span> localhost:<span class="number">9000.</span> DB::<span class="keyword">Exception</span>: <span class="built_in">Array</span> <span class="keyword">data</span> <span class="keyword">type</span> family must have exactly one argument - <span class="keyword">type</span> <span class="keyword">of</span> elements.</span><br></pre></td></tr></table></figure><p>当一个数组内包含了多种数据类型，则ClickHouse会引发异常。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">array</span>(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">Received <span class="keyword">exception</span> <span class="keyword">from</span> <span class="keyword">server</span> (<span class="keyword">version</span> <span class="number">20.3</span><span class="number">.4</span>):</span><br><span class="line">Code: <span class="number">386.</span> DB::<span class="keyword">Exception</span>: Received <span class="keyword">from</span> localhost:<span class="number">9000.</span> DB::<span class="keyword">Exception</span>: There <span class="keyword">is</span> <span class="keyword">no</span> supertype <span class="keyword">for</span> types UInt8, <span class="keyword">String</span> because <span class="keyword">some</span> <span class="keyword">of</span> them <span class="keyword">are</span> <span class="keyword">String</span>/FixedString <span class="keyword">and</span> <span class="keyword">some</span> <span class="keyword">of</span> them <span class="keyword">are</span> not.</span><br></pre></td></tr></table></figure><h3 id="2、元组Tuple"><a href="#2、元组Tuple" class="headerlink" title="2、元组Tuple"></a>2、元组Tuple</h3><p>元组类型有1～n个元素组成，每个元素都是一个单独的类型。与数组类似，元组也可用两种方式定义：tuple(T)或(t1, t2, …)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tuple(<span class="number">1</span>,<span class="string">'a'</span>) <span class="keyword">AS</span> x, toTypeName(x)</span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line">┌─x───────┬─toTypeName(tuple(<span class="number">1</span>, <span class="string">'a'</span>))─┐</span><br><span class="line">│ (<span class="number">1</span>,<span class="string">'a'</span>) │ Tuple(UInt8, <span class="keyword">String</span>)      │</span><br><span class="line">└─────────┴───────────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> tuple(<span class="number">1</span>, <span class="literal">NULL</span>) <span class="keyword">AS</span> x, toTypeName(x)</span><br><span class="line">┌─x────────┬─toTypeName(tuple(<span class="number">1</span>, <span class="literal">NULL</span>))──────┐</span><br><span class="line">│ (<span class="number">1</span>,<span class="literal">NULL</span>) │ Tuple(UInt8, Nullable(<span class="keyword">Nothing</span>)) │</span><br><span class="line">└──────────┴─────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>定义表字段时，同样需要指定明确的元素类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tuple_test ( c1 Tuple(<span class="keyword">String</span>, <span class="built_in">Int8</span>)) <span class="keyword">Engine</span> = TinyLog</span><br><span class="line"><span class="comment">-- 插入数据时也会进行类型检查</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tuple_test <span class="keyword">values</span>((<span class="string">'abc'</span>, <span class="number">123</span>))    <span class="comment">## 可插入成功</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tuple_test <span class="keyword">values</span>((<span class="string">'abc'</span>, <span class="string">'def'</span>))<span class="comment">## 会提示类型报错</span></span><br><span class="line"><span class="comment">-- 结果</span></span><br><span class="line"><span class="keyword">Exception</span> <span class="keyword">on</span> <span class="keyword">client</span>:</span><br><span class="line">Code: <span class="number">6.</span> DB::<span class="keyword">Exception</span>: Cannot <span class="keyword">parse</span> <span class="keyword">string</span> <span class="string">'def'</span> <span class="keyword">as</span> <span class="built_in">Int8</span>: syntax <span class="keyword">error</span> <span class="keyword">at</span> <span class="keyword">begin</span> <span class="keyword">of</span> string. Note: there <span class="keyword">are</span> toInt8OrZero <span class="keyword">and</span> toInt8OrNull functions, which <span class="keyword">returns</span> zero/<span class="literal">NULL</span> instead <span class="keyword">of</span> throwing exception.</span><br></pre></td></tr></table></figure><h3 id="3、枚举Enum"><a href="#3、枚举Enum" class="headerlink" title="3、枚举Enum"></a>3、枚举Enum</h3><p>ClickHouse提供了Enum8和Enum16两种枚举类型，ClickHouse可自动选择Enum插入数据的类型，也可以手动指定。他们仅取值范围不同：</p><ul><li>Enum8包含[-128, 127]范围内列举的256个值-</li><li>Enum16最多包含[-32768, 32767]范围内列举的65536个值</li></ul><p>命名值必须声明为<code>&#39;string: Int&#39;的Key/Value</code>键值对形式，所以Enum8和Enum16分别为<code>(String: Int8)</code>和<code>(String: Int16)</code>.</p><p>在使用枚举类型时，有以下限制：</p><ul><li>Key和Value不允许重复，需保证唯一性</li><li>Key和Value值都不能为Null，但Key允许是空字符串</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_enum (x Enum(<span class="string">'hello'</span> = <span class="number">1</span>, <span class="string">'world'</span> = <span class="number">2</span>)) <span class="keyword">ENGINE</span> = TinyLog</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_enum <span class="keyword">VALUES</span> (<span class="string">'hello'</span>), (<span class="string">'world'</span>), (<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment">-- 插入成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 若插入enum之外的key，则会抛出异常</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_enum <span class="keyword">values</span>(<span class="string">'a'</span>)</span><br><span class="line"><span class="comment">-- 结果：</span></span><br><span class="line"><span class="keyword">Exception</span> <span class="keyword">on</span> <span class="keyword">client</span>:</span><br><span class="line">Code: <span class="number">36.</span> DB::<span class="keyword">Exception</span>: <span class="literal">Unknown</span> <span class="keyword">element</span> <span class="string">'a'</span> <span class="keyword">for</span> <span class="keyword">type</span> Enum8(<span class="string">'hello'</span> = <span class="number">1</span>, <span class="string">'world'</span> = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据，会输出字符串类型的Key值</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_enum</span><br><span class="line">┌─x─────┐</span><br><span class="line">│ hello │</span><br><span class="line">│ world │</span><br><span class="line">│ hello │</span><br><span class="line">└───────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 若需要查看对应的value值，则需要将Enum值转换为整数类型，CAST(x, T)则将x类型转换为T类型</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CAST</span>(x, <span class="string">'Int8'</span>) <span class="keyword">FROM</span> t_enum</span><br><span class="line">┌─<span class="keyword">CAST</span>(x, <span class="string">'Int8'</span>)─┐</span><br><span class="line">│               <span class="number">1</span> │</span><br><span class="line">│               <span class="number">2</span> │</span><br><span class="line">│               <span class="number">1</span> │</span><br><span class="line">└─────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 若在select中直接创建Enum类型，仍然需要CAST函数转换</span></span><br><span class="line"><span class="keyword">SELECT</span> toTypeName(<span class="keyword">CAST</span>(<span class="string">'hello'</span>, <span class="string">'Enum(\'</span>hello\<span class="string">' = 1, \'</span>world\<span class="string">' = 2)'</span>))</span><br><span class="line">┌─toTypeName(<span class="keyword">CAST</span>(<span class="string">'hello'</span>, <span class="string">'Enum(\'</span>hello\<span class="string">' = 1, \'</span>world\<span class="string">' = 2)'</span>))─┐</span><br><span class="line">│ Enum8(<span class="string">'hello'</span> = <span class="number">1</span>, <span class="string">'world'</span> = <span class="number">2</span>)                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="4、嵌套Nested"><a href="#4、嵌套Nested" class="headerlink" title="4、嵌套Nested"></a>4、嵌套Nested</h3><p>一个数据表可以定义任意多个嵌套类型字段，但每个字段只能有一层潜逃，即嵌套字段内不能继续使用嵌套类型。ClickHouse的嵌套类型本质是一个多维数组的结构，即嵌套表中的每个字段都是一个数组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> nested_test(<span class="keyword">name</span> <span class="keyword">String</span>, age UInt8, dept <span class="keyword">Nested</span>(<span class="keyword">id</span> UInt8, <span class="keyword">name</span> <span class="keyword">String</span>)) <span class="keyword">Engine</span> = TinyLog</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> nested_test <span class="keyword">values</span> (<span class="string">'alice'</span>, <span class="number">18</span>, [<span class="number">10000</span>, <span class="number">10001</span>], [<span class="string">'aaa'</span>, <span class="string">'bbb'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据时，同一行数据中嵌套类型的数组字段长度必须相同，否则会抛出以下异常</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> nested_test <span class="keyword">values</span> (<span class="string">'bob'</span>, <span class="number">22</span>, [<span class="number">10000</span>], [<span class="string">'aaa'</span>, <span class="string">'bbb'</span>])</span><br><span class="line">Received <span class="keyword">exception</span> <span class="keyword">from</span> <span class="keyword">server</span> (<span class="keyword">version</span> <span class="number">20.3</span><span class="number">.4</span>):</span><br><span class="line">Code: <span class="number">190.</span> DB::<span class="keyword">Exception</span>: Received <span class="keyword">from</span> localhost:<span class="number">9000.</span> DB::<span class="keyword">Exception</span>: Elements <span class="string">'dept.id'</span> <span class="keyword">and</span> <span class="string">'dept.name'</span> <span class="keyword">of</span> <span class="keyword">Nested</span> <span class="keyword">data</span> structure <span class="string">'dept'</span> (<span class="built_in">Array</span> <span class="keyword">columns</span>) have different <span class="built_in">array</span> sizes.. </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, dept.id, dept.name <span class="keyword">from</span> nested_test;</span><br><span class="line">┌─name──┬─dept.id─┬─dept.name─────┐</span><br><span class="line">│ alice │ [16,17] │ ['aaa','bbb'] │</span><br><span class="line">└───────┴─────────┴───────────────┘</span><br></pre></td></tr></table></figure><h2 id="四、其他类型"><a href="#四、其他类型" class="headerlink" title="四、其他类型"></a>四、其他类型</h2><p>​    ClickHouse除了上述类型之外，还定义了一些其他字段类型作为对基础数据的进一步修饰和封装。</p><h3 id="1、Nullable"><a href="#1、Nullable" class="headerlink" title="1、Nullable"></a>1、Nullable</h3><p>​    Nullable并不能算一种独立的数据类型，它需要和基础数据类型配合使用，并不能用于数组和元组这些复合类型，通过Nullable修饰之后，该基础类型字段可以输入Null值。</p><p>​    使用了Nullable修饰后，该字段不能作为索引字段，并且会使查询和写入性能变慢。这是由于一般情况下每个字段的数据会存储在对应的column.bin文件中，如果该字段被Nullable修饰，会额外生成column.null.bin文件专门保存null值，这表示读取和写入，需要一倍的额外文件操作。故官方并不建议经常使用Nullable类型</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_null(x <span class="built_in">Int8</span>, y Nullable(<span class="built_in">Int8</span>)) <span class="keyword">ENGINE</span> TinyLog</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_null <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="literal">NULL</span>), (<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_null</span><br><span class="line">┌─x─┬────y─┐</span><br><span class="line">│ <span class="number">1</span> │ ᴺᵁᴸᴸ │</span><br><span class="line">│ <span class="number">2</span> │    <span class="number">3</span> │</span><br><span class="line">└───┴──────┘</span><br></pre></td></tr></table></figure><h3 id="2、Domain"><a href="#2、Domain" class="headerlink" title="2、Domain"></a>2、Domain</h3><p>Domain类型分为IPv4和IPv6两种，本质是对整型和字符串型的进一步封装，虽然Domain类型看起来和String类型相同，但它并不是字符串类型，不支持隐式的自动类型转换，如果需要返回IP的字符串形式，需要调用<code>IPv4NumToString</code>或<code>IPv6NumToString</code>函数进行转换。IPv4类型是基于UInt32封装，IPv6基于FixedString(16)封装。他们使用方式相同，以下用IPv4作为示例。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hits (<span class="keyword">url</span> <span class="keyword">String</span>, <span class="keyword">from</span> IPv4) <span class="keyword">ENGINE</span> = MergeTree() <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">url</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hits <span class="keyword">values</span>(<span class="string">'www.zzdb.com'</span>, <span class="string">'1.1.1.1'</span>),(<span class="string">'test.db.com'</span>, <span class="string">'2.2.2.2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- Domain格式会进行数据类型检查</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hits <span class="keyword">values</span> (<span class="string">'www.test.com'</span>, <span class="string">'192.168.1'</span>)</span><br><span class="line"><span class="keyword">Exception</span> <span class="keyword">on</span> <span class="keyword">client</span>:</span><br><span class="line">Code: <span class="number">441.</span> DB::<span class="keyword">Exception</span>: Invalid IPv4 value.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询数据</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> hits</span><br><span class="line">┌─<span class="keyword">url</span>──────────┬────<span class="keyword">from</span>─┐</span><br><span class="line">│ test.db.com  │ <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span> │</span><br><span class="line">│ www.zzdb.com │ <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span> │</span><br><span class="line">└──────────────┴─────────┘</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 转换为字符串类型</span></span><br><span class="line"><span class="keyword">SELECT</span> toTypeName(s), IPv4NumToString(<span class="keyword">from</span>) <span class="keyword">as</span> s <span class="keyword">FROM</span> hits <span class="keyword">LIMIT</span> <span class="number">1</span>;</span><br><span class="line">┌─toTypeName(IPv4NumToString(from))─┬─s───────┐</span><br><span class="line">│ String                            │ 2.2.2.2 │</span><br><span class="line">└───────────────────────────────────┴─────────┘</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    ClickHouse作为一个DBMS，提供了DDL和DML的功能，并支持部分标准的SQL语法。但ClickHouse在基础数据方面，既提供了常规的数据类型、字符串类型格式，又提供了一些常用的复合类型(数组、元组等)，并且与常规的数据库，在DML的使用上也存在不同(
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎之MergeTree引擎——索引</title>
    <link href="https://schnappi618.github.io/2020/07/05/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/"/>
    <id>https://schnappi618.github.io/2020/07/05/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/</id>
    <published>2020-07-05T12:16:36.000Z</published>
    <updated>2020-07-12T12:14:01.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、一级索引"><a href="#一、一级索引" class="headerlink" title="一、一级索引"></a>一、一级索引</h2><p>​    MergeTree的主键使用PRIMARY KEY来定义，MergeTree会根据index_granularity间隔(默认8192行)，为数据表生成一级索引并保存到primary.idx文件里，索引数据会按照PRIMARY KEY排序，所以，ClickHouse中经常通过ORDER BY来代替主键。此时，索引(primary.idx)和数据文件(column.bin)会按照相同的规则排序</p><p>​    ClickHouse的一级索引使用了稀疏索引实现，即每一行索引表计对应的是一段数据，而不是一行数据。它使用少量的索引标记就可以记录大量数据的区间位置信息。</p><h3 id="1、索引粒度"><a href="#1、索引粒度" class="headerlink" title="1、索引粒度"></a>1、索引粒度</h3><p>​    ClickHouse通过<code>index_granularity</code>参数来控制索引粒度，默认为8192，最新版本可以使用自适应索引粒度大小，则标记文件会被命名为(column.mrk2)。数据会以该参数的大小被标记为多个小区间，每个区间默认最多8192行数据，MergeTree使用MarkRange来表示一个具体区间，并通过start和end表示具体范围。</p><p>​    在ClickHouse中，索引粒度不仅影响一级索引(primary.idx)，同时也影响数据标记文件(column.mrk)和数据文件(column.bin)。这是由于MergeTree无法只通过索引来完成查询工作，通过标记文件建立以稀疏索引(primary.idx)和对应数据文件(column.bin)的映射关系，MergeTree会先通过稀疏索引(primary.idx)找到对应数据的偏移量信息(column.mrk)，再通过偏移量直接从数据文件(column.bin)读取数据。所以一级索引和数据标记的间隔粒度相同，均有<code>index_granularity</code>参数决定，数据文件也会依据该参数生成压缩数据块。</p><img src="/2020/07/05/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/suoyin_1.png" alt="MergeTree按照索引粒度划分数据" style="zoom:50%;"><h3 id="2、索引数据的生成规则"><a href="#2、索引数据的生成规则" class="headerlink" title="2、索引数据的生成规则"></a>2、索引数据的生成规则</h3><p>​    MergeTree需要间隔index_granularity行数据才会生成一条索引记录，索引值会依据声明的主键字段来获取。例如官方提供的测试数据表hits_v1使用了年月分区(PARTITION BY toYYYYMM(EventDate))，如果使用CounterID作为主键，则每间隔8192行数据就会取一次CounterID的值作为索引值，索引数据最终写入parimary.idx文件中保存。</p><img src="/2020/07/05/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/suoyin_2.png" style="zoom:60%;"><p>​    以上是使用单个字段作为主键的情况，若使用多个主键，例<code>ORDER BY(CounterID, EventDate)</code>，则每间隔8192行同时取CounterID和EventDate两列值作为索引，上述例子，索引值将为<code>572014-03-1716352014-03-1832662014-03-19</code></p><h2 id="二、索引的查询过程"><a href="#二、索引的查询过程" class="headerlink" title="二、索引的查询过程"></a>二、索引的查询过程</h2><p>​    MarkRange在ClickHouse中用来定义标记区间，MergeTree按照index_granularity设置的索引粒度，将一段完整的数据划分成了多个小的间隔数据段，一个数据段则是一个MarkRange，它与索引编号对应，使用start和end两个属性表示区间范围，通过start和end对应的索引编号的取值，可以得到它所对应的数值区间，数值区间则表示了该MarkRange的数据范围。</p><p>​    假如一份测试数据，共有192条记录。其中主键ID为String类型，ID取值从A000开始，后面依次为A001、A002…A191。MergeTree的索引粒度为index_granularity=3，根据索引的生成规则，primary.idx文件内的索引数据会为<code>A000A003A006A009A012...A186A189</code></p><p>​    根据索引数据，MergeTree会将此数据片段分为192/3 = 64个小的MarkRange，两个相邻MarkRange相距步长为1，所有MarkRange(整个数据片段)的最大数值区间为[A000, +inf)。MarkRange和数值区间范围示意图如下：</p><img src="/2020/07/05/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/suoyin_3.png" style="zoom:60%;"><p>​    索引的查询其实为基于主键的查询条件转换的条件区间和MarkRange对应的数值区间这两个区间的交集判断。整个查询过程可分为以下三个步骤：</p><ol><li><p>生成查询条件区间。</p><p>例如：</p><p>条件为 <code>WHERE ID = &#39;A003&#39;</code>,条件区间会转换为<code>[&#39;A003&#39;, &#39;A003&#39;]</code>;</p><p>条件为<code>WHEER ID &gt; &#39;A000&#39;</code>,条件区间会转换为<code>[&#39;A000&#39;, +inf]</code>;</p></li><li><p>递归交集判断：以递归的形式，依次对MarkRange的数值区间与条件区间做交集判断。从最大的MarkRange区间<code>[A000,+inf]</code>开始</p><ol><li>如果不存在交集，则直接去掉整段MarkRange数据</li><li>存在交集，且MarkRange步长大于8(end - start)，则将此区间进一步拆分成8个字区间(由merge_tree_coarse_index_granularity指定，默认为8)，不断重复，做交集判断</li><li>存在交集，并且MarkRange不可被再分解(步长小于8)，则记录MarkRange并返回</li></ol></li><li><p>合并MarkRange区间：将最终匹配的MarkRange聚合</p></li></ol><p>大致流程图如下：</p><img src="/2020/07/05/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/suoyin_4.png" style="zoom:80%;"><h2 id="二、二级索引"><a href="#二、二级索引" class="headerlink" title="二、二级索引"></a>二、二级索引</h2><p>MergeTree还支持二级索引，但目前还处于测试阶段，官方不建议大量使用。</p><h3 id="1、定义方式"><a href="#1、定义方式" class="headerlink" title="1、定义方式"></a>1、定义方式</h3><p>MergeTree二级索引又叫跳数索引，是由数据按索引粒度分割后的每部分在指定表达式上的汇总信息组成，这些汇总信息有助于用where条件过滤时跳过不满足的数据，从而减少select查询从磁盘读取的数据量以及数据扫描的范围。</p><p>跳数索引默认是关闭的，需要执行<code>SET allow_experimental_data_skipping_indices = 1</code>开启，在创建表时指定，定义语法为：</p><p><code>INDEX index_name expr TYPE index_type(...) GRANULARITY granularity_value</code></p><p>当建表语句中声明了跳数索引，则会额外生成相对应的索引和标记文件(skp_idx_[column].idx和skp_idx_[column].mrk)</p><h3 id="2、granularity与index-granularity的关系"><a href="#2、granularity与index-granularity的关系" class="headerlink" title="2、granularity与index_granularity的关系"></a>2、granularity与index_granularity的关系</h3><p>不同的二级索引中，除了各个索引不同类型的参数以外，都共同拥有granularity参数。对于跳数索引，index_granularity定义了数据粒度，二granularity定义了聚合信息汇总的力度。即granularity定义了一行跳数索引能够跳过多少个index_granularity区间的数据。</p><p>跳数索引的生成规则可以大概解释为：</p><ol><li>按照index_granularity粒度间隔将数据划分为n段，总共有[0, n-1]个区间(n = total_rows / index_granularity，向上取整)</li><li>根据索引定义声明，从0区间开始，一次按照index_granularity粒度从数据中获取聚合信息，每次向前移动1步(n + 1)，聚合信息逐步累加</li><li>当移动到granularity次区间时，则进行数据汇总并生成一行跳数索引数据</li></ol><p><strong>示例：</strong></p><p>以minmax索引为例，它聚合了一个index_granularity区间内的最大和最小数据，假设index_granulariyt=8192且granulariyt=3，则数据按照index_granularity划分为n等份，MergeTree从第0段分区开始，依次获取聚合信息，当获取到第三个分区(granularity=3)，则汇总并生成第一行minmax索引(前3段minmax汇总后取值为[1, 9])，如下图所示：</p><img src="/2020/07/05/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E7%B4%A2%E5%BC%95/suoyin_5.svg" style="zoom:80%;"><h3 id="3、跳数索引的类型"><a href="#3、跳数索引的类型" class="headerlink" title="3、跳数索引的类型"></a>3、跳数索引的类型</h3><p>​    目前，MergeTree支持4中跳数座因，分别是minmax、set、ngrambf_v1和tokenbf_v1，一张数据表支持同时声明多个跳数索引。</p><ul><li><p><code>minmax</code>：minmax索引记录了一段数据内的最小值和最大值，用于快速跳过无用的数据区间</p><ul><li><code>INDEX a ID TYPE minmax GRANULARITY 5</code> 表示minmax索引会记录每5个index_granularity区间数据中的最大值和最小值</li></ul></li><li><p><code>set</code>：存储指定字段或表达式的唯一值，完整形式为<code>set(max_rows)</code>，max_rows表示在一个index_granularity内，索引最多纪录的数据行数，如果max_rows=0，则表示无限制</p><ul><li><code>INDEX b(length(ID) * 8) TYPE set(100) GRANULARITY 5</code> 表示该索引会记录数据中ID长度*8之后的取值，并且每个index_granularity最多纪录100条</li></ul></li><li><p><code>ngrambf_v1</code>：记录了数据块中n元短语的布隆表过滤器(简单来讲，布隆表过滤器本质是由仅包含0和1位值的列表组成，默认均为0，利用哈希函数对数据值进行处理，并将结果位置上对应位的值改为1，由于存在哈希冲突，所以只能判断不在列表中和可能在列表中)，只支持String和FixedString数据类型，可用于优化like、in、equals、notIn、notEquals的查询性能，完整形式为<code>ngrambf_v1(n, size_of_bloom_filter_in_bytes, number_of_hash_functions, random_seed)</code>，各参数含义为：</p><ul><li>n: token长度，依据n长度将数据切割为token短语</li><li>size_of_bloom_filter_in_bytes: 布隆过滤器的大小</li><li>number_of_hash_functions: 布隆过滤器中使用Hash函数的个数</li><li>random_seed: Hash函数的随机种子</li></ul><p>例如：<code>INDEX c(ID, Code) TYPE ngrambf_v1(3, 256, 2, 0) GRANULARITY 5</code> 表示依照3的粒度将数据切割成短语token，token经过两个Hash函数映射后再被写入，布隆过滤器大小伟256字节</p></li><li><p><code>tokenbf_v1</code>：和ngrambf_v1类似，但它会自动按照非字符、数字的字符串切割token</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、一级索引&quot;&gt;&lt;a href=&quot;#一、一级索引&quot; class=&quot;headerlink&quot; title=&quot;一、一级索引&quot;&gt;&lt;/a&gt;一、一级索引&lt;/h2&gt;&lt;p&gt;​    MergeTree的主键使用PRIMARY KEY来定义，MergeTree会根据index_gr
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
      <category term="MergeTree" scheme="https://schnappi618.github.io/tags/MergeTree/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎之MergeTree引擎——数据分区</title>
    <link href="https://schnappi618.github.io/2020/06/27/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/"/>
    <id>https://schnappi618.github.io/2020/06/27/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/</id>
    <published>2020-06-27T02:09:11.000Z</published>
    <updated>2020-07-27T08:37:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>​    从<a href="%5Bhttps://schnappi618.github.io/2020/06/11/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/%5D(https://schnappi618.github.io/2020/06/11/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/)">ClickHouse存储引擎之MergeTree引擎——概述</a>中可以知道，在MergeTree存储引擎中，数据是以分区目录的形式存放的。基于该原理，在进行数据查询时，可以仅查询最小的分区目录。</p><h2 id="一、MergeTree数据分区规则"><a href="#一、MergeTree数据分区规则" class="headerlink" title="一、MergeTree数据分区规则"></a>一、MergeTree数据分区规则</h2><h3 id="1、测试示例"><a href="#1、测试示例" class="headerlink" title="1、测试示例"></a>1、测试示例</h3><p>​    下面仍然使用上一篇的测试数据来继续说明MergeTree的数据分区方式和规则</p><ol><li>原始数据情况</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化数据后的数据目录如下</span></span><br><span class="line">[root@xxxx partitioned_by_week]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 13 17:18 19991227_1_1_0</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 13 17:18 20000103_2_2_0</span><br><span class="line">drwxr-x--- 2 101 101  10 Jun 13 17:15 detached</span><br><span class="line">-rw-r----- 1 101 101   1 Jun 13 17:15 format_version.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目前partitioned_by_week表的数据内容为</span></span><br><span class="line"><span class="comment">## 查询该表的测试数据</span></span><br><span class="line">clickhouse-server_1 :) select * from partitioned_by_week;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM partitioned_by_week</span><br><span class="line"></span><br><span class="line">┌──────────d─┬─x─┐</span><br><span class="line">│ 2000-01-03 │ 3 │</span><br><span class="line">└────────────┴───┘</span><br><span class="line">┌──────────d─┬─x─┐</span><br><span class="line">│ 2000-01-01 │ 1 │</span><br><span class="line">│ 2000-01-02 │ 2 │</span><br><span class="line">└────────────┴───┘</span><br><span class="line"></span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.004 sec. </span><br><span class="line"><span class="comment">## 表结构如下</span></span><br><span class="line">clickhouse-server_1 :) show create table partitioned_by_week;</span><br><span class="line"></span><br><span class="line">SHOW CREATE TABLE partitioned_by_week</span><br><span class="line"></span><br><span class="line">┌─statement────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│ CREATE TABLE test.partitioned_by_week (`d` Date, `x` UInt8) ENGINE = MergeTree PARTITION BY toMonday(d) ORDER BY x SETTINGS index_granularity = 8192 │</span><br><span class="line">└──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">1 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.003 sec.</span><br></pre></td></tr></table></figure><ol start="2"><li>插入一条新的数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入一条新的数据('2000-01-05', 4)</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">insert</span> <span class="keyword">into</span> partitioned_by_week (d, x) <span class="keyword">values</span>(<span class="string">'2000-01-05'</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> partitioned_by_week (d, x) <span class="keyword">VALUES</span></span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.004</span> sec.</span><br></pre></td></tr></table></figure><ol start="3"><li>数据内容及数据目录如下</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询数据情况</span></span><br><span class="line">clickhouse-server_1 :) select * from partitioned_by_week</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM partitioned_by_week</span><br><span class="line"></span><br><span class="line">┌──────────d─┬─x─┐</span><br><span class="line">│ 2000-01-03 │ 3 │</span><br><span class="line">└────────────┴───┘</span><br><span class="line">┌──────────d─┬─x─┐</span><br><span class="line">│ 2000-01-01 │ 1 │</span><br><span class="line">│ 2000-01-02 │ 2 │</span><br><span class="line">└────────────┴───┘</span><br><span class="line">┌──────────d─┬─x─┐</span><br><span class="line">│ 2000-01-05 │ 4 │</span><br><span class="line">└────────────┴───┘</span><br><span class="line"></span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.009 sec.</span><br><span class="line"><span class="comment"># 查询数据分区情况，active = 1表示启用中</span></span><br><span class="line">clickhouse-server_1 :) SELECT partition,name,active FROM system.parts WHERE table = <span class="string">'partitioned_by_week'</span></span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    partition, </span><br><span class="line">    name, </span><br><span class="line">    active</span><br><span class="line">FROM system.parts</span><br><span class="line">WHERE table = <span class="string">'partitioned_by_week'</span></span><br><span class="line"></span><br><span class="line">┌─partition──┬─name───────────┬─active─┐</span><br><span class="line">│ 1999-12-27 │ 19991227_1_1_0 │      1 │</span><br><span class="line">│ 2000-01-03 │ 20000103_2_2_0 │      1 │</span><br><span class="line">│ 2000-01-03 │ 20000103_3_3_0 │      1 │</span><br><span class="line">└────────────┴────────────────┴────────┘</span><br><span class="line"></span><br><span class="line">3 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.012 sec. </span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据目录情况</span></span><br><span class="line">[root(host/tjtx148-16-25.58os.org)@tjtx162-17-78 partitioned_by_week]<span class="comment"># ll</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 13 17:18 19991227_1_1_0</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 13 17:18 20000103_2_2_0</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 27 10:20 20000103_3_3_0</span><br><span class="line">drwxr-x--- 2 101 101  10 Jun 13 17:15 detached</span><br><span class="line">-rw-r----- 1 101 101   1 Jun 13 17:15 format_version.txt</span><br></pre></td></tr></table></figure><ol start="4"><li>查询并查看执行计划</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询一条数据</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> x <span class="keyword">from</span> partitioned_by_week <span class="keyword">where</span> d = <span class="string">'2000-01-05'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> x</span><br><span class="line"><span class="keyword">FROM</span> partitioned_by_week</span><br><span class="line"><span class="keyword">WHERE</span> d = <span class="string">'2000-01-05'</span></span><br><span class="line"></span><br><span class="line">┌─x─┐</span><br><span class="line">│ <span class="number">4</span> │</span><br><span class="line">└───┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.383307</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;Debug&gt; executeQuery: (<span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58492</span>) <span class="keyword">SELECT</span> x <span class="keyword">FROM</span> partitioned_by_week <span class="keyword">WHERE</span> d = <span class="string">'2000-01-05'</span></span><br><span class="line"><span class="comment">-- clickhouse将where条件自动优化为了PREWHERE，用来做数据过滤</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.383577</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;Debug&gt; InterpreterSelectQuery: MergeTreeWhereOptimizer: condition <span class="string">"d = '2000-01-05'"</span> moved <span class="keyword">to</span> PREWHERE</span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.383734</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;<span class="keyword">Trace</span>&gt; AccessRightsContext (<span class="keyword">default</span>): <span class="keyword">Access</span> granted: <span class="keyword">SELECT</span>(d, x) <span class="keyword">ON</span> test.partitioned_by_week</span><br><span class="line"><span class="comment">-- 没有使用主键索引</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.383836</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;Debug&gt; test.partitioned_by_week (SelectExecutor): <span class="keyword">Key</span> condition: <span class="literal">unknown</span></span><br><span class="line"><span class="comment">-- 分区索引被启动</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.383859</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;Debug&gt; test.partitioned_by_week (SelectExecutor): MinMax <span class="keyword">index</span> condition: (<span class="keyword">column</span> <span class="number">0</span> <span class="keyword">in</span> [<span class="number">10961</span>, <span class="number">10961</span>])</span><br><span class="line"><span class="comment">-- 借助date类型的分区索引，本次查询仅扫描了一个分区目录</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.383878</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;Debug&gt; test.partitioned_by_week (SelectExecutor): Selected <span class="number">1</span> parts <span class="keyword">by</span> <span class="built_in">date</span>, <span class="number">1</span> parts <span class="keyword">by</span> <span class="keyword">key</span>, <span class="number">1</span> marks <span class="keyword">to</span> <span class="keyword">read</span> <span class="keyword">from</span> <span class="number">1</span> ranges</span><br><span class="line"><span class="comment">-- 最终需要读取到内存的预估数据量是1行</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.383924</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;<span class="keyword">Trace</span>&gt; test.partitioned_by_week (SelectExecutor): Reading approx. <span class="number">8192</span> <span class="keyword">rows</span> <span class="keyword">with</span> <span class="number">1</span> streams</span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.383968</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;<span class="keyword">Trace</span>&gt; InterpreterSelectQuery: FetchColumns -&gt; <span class="keyword">Complete</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.384464</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;Information&gt; executeQuery: <span class="keyword">Read</span> <span class="number">1</span> <span class="keyword">rows</span>, <span class="number">3.00</span> B <span class="keyword">in</span> <span class="number">0.001</span> sec., <span class="number">915</span> <span class="keyword">rows</span>/sec., <span class="number">2.68</span> KiB/sec.</span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.384501</span> [ <span class="number">81</span> ] &#123;f0a4f689<span class="number">-76</span>f3<span class="number">-4342</span>-ab8f<span class="number">-2e8349</span>ca5970&#125; &lt;Debug&gt; MemoryTracker: Peak <span class="keyword">memory</span> <span class="keyword">usage</span> (<span class="keyword">for</span> <span class="keyword">query</span>): <span class="number">0.00</span> B.</span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.384574</span> [ <span class="number">81</span> ] &#123;&#125; &lt;Debug&gt; MemoryTracker: Peak <span class="keyword">memory</span> <span class="keyword">usage</span> (total): <span class="number">0.00</span> B.</span><br><span class="line"><span class="number">2020.06</span><span class="number">.27</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">58.384595</span> [ <span class="number">81</span> ] &#123;&#125; &lt;Information&gt; TCPHandler: Processed <span class="keyword">in</span> <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure><h3 id="2、MergeTree数据分区规则"><a href="#2、MergeTree数据分区规则" class="headerlink" title="2、MergeTree数据分区规则"></a>2、MergeTree数据分区规则</h3><p>​    从插入数据过程中，数据分区目录的变化可以看出，MergeTree的分区目录不是在表创建的时候就存在的，而是在写入数据的过程中被创建出来，也就是说如果仅创建了表结构，没有任何数据的时候，是不会有分区目录存在的。</p><ul><li><p>MergeTree数据分区目录命名规则</p><p>利用上面的示例数据，我们可以看到数据目录都是类似于<code>19991227_1_1_0</code>的格式，它们是由MergeTree自己的规则来命名的，规则为<code>PartitionID_MinBlockNum_MaxBlockNum_Level</code></p><p>示例数据中19991227 表示分区目录的ID，1_1 分别表示最小的数据块编号和最大的数据块编号，最后的_0 表示目前分区合并的层级</p></li></ul><hr><p>​    各部分的含义及命名规则如下：</p><ul><li><p><code>PartitionID</code>：MergeTree数据分区的规则是由分区ID来决定，分区ID的值则是由插入数据时分区键的取值来决定的。分区键支持使用任何一个或一组字段表达式来声明，针对取值数据类型的不同，分区ID的生成逻辑目前有四种规则</p><ul><li><p>不指定分区键：如果建表时未指定分区键，则分区ID默认使用all，所有数据都被写入all分区中</p></li><li><p>整型字段：如果分区键取值是整型字段，并且无法转换为YYYYMMDD的格式，则会按照该整型字段的字符形式输出，作为分区ID取值</p></li><li><p>日期类型：如果分区键属于日期格式，或可以转换为YYYYMMDD格式的整型，则按照YYYYMMDD格式化后的字符形式输出，作为分区ID取值</p></li><li><p>其他类型：如果使用其他类似Float、String等类型作为分区键，会通过对其插入数据的128位Hash值作为分区ID的取值  </p></li><li><p><img src="/2020/06/27/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/fenqu_1.png"></p></li></ul></li></ul><ul><li><p><code>MinBlockNum</code>和<code>MaxBlockNum</code>：BlockNum是一个整型的自增长型编号，该编号在单张MergeTree表中从1开始全局累加，当有新的分区目录创建后，该值就加1，对新的分区目录来讲，MinBlockNum和MaxBlockNum取值相同。例如上面示例数据为<code>19991227_1_1_0</code>和<code>20000103_2_2_0</code>，但当分区目录进行合并后，取值规则会发生变化</p></li><li><p><code>Level</code>：表示合并的层级。相当于某个分区被合并的次数，它不是以表全局累加，而是以分区为单位，初始创建的分区，初始值为0，相同分区ID发生合并动作时，在相应分区内累计加1</p></li></ul><h2 id="二、MergeTree数据分区合并规则"><a href="#二、MergeTree数据分区合并规则" class="headerlink" title="二、MergeTree数据分区合并规则"></a>二、MergeTree数据分区合并规则</h2><p>​    示例数据以周为分区，可以看出<code>2000-01-02, 2</code>和<code>2000-01-03, 3</code>两条数据最终产生了两个相同分区ID的数据目录<code>20000103_2_2_0</code>和<code>20000103_3_3_0</code>，由于它们是通过两条不同的sql插入进去的数据，所以，在ClickHouse中，即使数据属于相同分区，不同批次写入的数据，MergeTree都会生成不同的分区目录，对于同一个分区而言，会存在多个分区目录的情况。</p><p>​    MergeTree可以通过分区合并将属于相同分区的多个目录合并为一个新的目录(官方描述在10到15分钟内会进行合并&lt;控制该值的参数目前还未找到&gt;，也可直接执行optimize语句)，已经存在的就目录在之后某个时刻通过后台任务被删除(默认8分钟之后，暂未找到控制该值的参数)。</p><h3 id="1、合并分区后的命名规则"><a href="#1、合并分区后的命名规则" class="headerlink" title="1、合并分区后的命名规则"></a>1、合并分区后的命名规则</h3><p>​    同个分区的数据目录合并后会产生一个新的目录，目录中的索引和数据文件也会进行合并，新目录的命名规则如下：</p><ul><li>PartitionID：分区ID保持不变</li><li>MinBlockNum：取同一个分区内所有目录中最小的MinBlockNum值</li><li>MaxBlockNUm：取同一个分区内所有目录中最大的MaxBlockNum值</li><li>Level：取同一个分区内最大Level值并加1</li></ul><h3 id="2、示例"><a href="#2、示例" class="headerlink" title="2、示例"></a>2、示例</h3><p>​    按照示例的两个数据目录以及合并的命名规则，可以得到新的数据目录中PartitionID仍然为<code>20000103</code>，MinBlockNum取两个目录中该值的最小值为2，MaxBlockNum取该值的最大值为3，Level原目录都为0加1等于1，故合并后的目录名称为<code>20000103_2_3_1</code>。</p><img src="/2020/06/27/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%88%86%E5%8C%BA/fenqu_2.png" style="zoom:50%;"><p>​    再次插入一个20000103分区的数据进行合并后的目录名称会为<code>20000103_2_4_2</code>，过程如下：</p><ol><li>插入数据</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入一条新的数据</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">insert</span> <span class="keyword">into</span> partitioned_by_week(d, x) <span class="keyword">values</span>(<span class="string">'2000-01-04'</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> partitioned_by_week (d, x) <span class="keyword">VALUES</span></span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> * <span class="keyword">from</span> partitioned_by_week</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> partitioned_by_week</span><br><span class="line"></span><br><span class="line">┌──────────d─┬─x─┐</span><br><span class="line">│ <span class="number">2000</span><span class="number">-01</span><span class="number">-03</span> │ <span class="number">3</span> │</span><br><span class="line">│ <span class="number">2000</span><span class="number">-01</span><span class="number">-05</span> │ <span class="number">4</span> │</span><br><span class="line">└────────────┴───┘</span><br><span class="line">┌──────────d─┬─x─┐</span><br><span class="line">│ <span class="number">2000</span><span class="number">-01</span><span class="number">-01</span> │ <span class="number">1</span> │</span><br><span class="line">│ <span class="number">2000</span><span class="number">-01</span><span class="number">-02</span> │ <span class="number">2</span> │</span><br><span class="line">└────────────┴───┘</span><br><span class="line">┌──────────d─┬─x─┐</span><br><span class="line">│ <span class="number">2000</span><span class="number">-01</span><span class="number">-04</span> │ <span class="number">4</span> │</span><br><span class="line">└────────────┴───┘</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure><ol start="2"><li>产生新的数据目录</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@xxxx <span class="built_in">test</span>]<span class="comment"># ll partitioned_by_week/</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 13 17:18 19991227_1_1_0</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 27 11:26 20000103_2_3_1</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 27 12:12 20000103_4_4_0</span><br><span class="line">drwxr-x--- 2 101 101  10 Jun 13 17:15 detached</span><br><span class="line">-rw-r----- 1 101 101   1 Jun 13 17:15 format_version.txt</span><br></pre></td></tr></table></figure><ol start="3"><li>进行合并</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-server_1 :) <span class="keyword">optimize</span> <span class="keyword">table</span> partitioned_by_week</span><br><span class="line"></span><br><span class="line"><span class="keyword">OPTIMIZE</span> <span class="keyword">TABLE</span> partitioned_by_week</span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec.</span><br></pre></td></tr></table></figure><ol start="4"><li>合并后数据目录发生变化</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 旧数据目录20000103_2_3_1和20000103_4_4_0会在一段时间后被后台删除</span></span><br><span class="line">[root@xxxx <span class="built_in">test</span>]<span class="comment"># ll partitioned_by_week/</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 13 17:18 19991227_1_1_0</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 27 11:26 20000103_2_3_1</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 27 12:14 20000103_2_4_2</span><br><span class="line">drwxr-x--- 2 101 101 221 Jun 27 12:12 20000103_4_4_0</span><br><span class="line">drwxr-x--- 2 101 101  10 Jun 13 17:15 detached</span><br><span class="line">-rw-r----- 1 101 101   1 Jun 13 17:15 format_version.txt</span><br></pre></td></tr></table></figure><p>​    可以看到，分区目录发生合并之后，旧分区目录不会被立即删除，此时旧分区目录在<code>system.parts</code>分区详情表中状态会处于未激活状态(active=0)，故查询数据时，这部分分区的数据会被自动过滤。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​    从&lt;a href=&quot;%5Bhttps://schnappi618.github.io/2020/06/11/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
      <category term="MergeTree" scheme="https://schnappi618.github.io/tags/MergeTree/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎之MergeTree引擎——概述</title>
    <link href="https://schnappi618.github.io/2020/06/11/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/"/>
    <id>https://schnappi618.github.io/2020/06/11/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</id>
    <published>2020-06-11T07:55:35.000Z</published>
    <updated>2020-07-12T12:13:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、MergeTree系列引擎概述"><a href="#一、MergeTree系列引擎概述" class="headerlink" title="一、MergeTree系列引擎概述"></a>一、MergeTree系列引擎概述</h2><p>​    在ClickHouse中，存储引擎决定了一张表拥有哪些特性以及读写数据的方式等。在所有的存储引擎中，MergeTree及其*MergeTree系列是最强大的表引擎，它适用于一些高负载任务，可以快速插入数据并在后台进行数据处理，还支持了主键索引、分区、数据复制等一些其他引擎不支持的功能。</p><p>​    该类型的引擎包括：</p><ul><li><p>MergeTree</p></li><li><p>Replacing MergeTree</p></li><li><p>Summing MergeTree</p></li><li><p>Aggregating MergeTree</p></li><li><p>Collapsing MergeTree</p></li><li><p>Versioned Collapsing MergeTree</p></li><li><p>Graphite MergeTree</p><p>其中，MergeTree引擎具备了这一系列引擎的基本特征，是<em>MergeTree系列引擎的基础，需要注意的是**</em>MergeTree引擎并不属于*MergeTree系列**</p></li></ul><h2 id="二、MergeTree-合并树-引擎"><a href="#二、MergeTree-合并树-引擎" class="headerlink" title="二、MergeTree(合并树)引擎"></a>二、MergeTree(合并树)引擎</h2><p>​    MergeTree插入的数据会直接写入文件系统，故它仅适用于批量插入数据，而不适合频繁插入单行数据的情况，MergeTree在写入一批数据时，数据会以不可修改的数据片段形式写入到磁盘中，同时为了避免数据片段过多，ClickHouse会通过后台线程，定期合并数据片段，属于相同分区的数据片段会被合并为一个新的片段。</p><h3 id="1、创建方式"><a href="#1、创建方式" class="headerlink" title="1、创建方式"></a>1、创建方式</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- MergeTree引擎表的创建格式为</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name [<span class="keyword">ON</span> CLUSTER cluster]</span><br><span class="line">(</span><br><span class="line">    name1 [type1] [<span class="keyword">DEFAULT</span>|<span class="keyword">MATERIALIZED</span>|<span class="keyword">ALIAS</span> expr1] [TTL expr1],</span><br><span class="line">    name2 [type2] [<span class="keyword">DEFAULT</span>|<span class="keyword">MATERIALIZED</span>|<span class="keyword">ALIAS</span> expr2] [TTL expr2],</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">INDEX</span> index_name1 expr1 <span class="keyword">TYPE</span> type1(...) GRANULARITY value1,</span><br><span class="line">    <span class="keyword">INDEX</span> index_name2 expr2 <span class="keyword">TYPE</span> type2(...) GRANULARITY value2</span><br><span class="line">) <span class="keyword">ENGINE</span> = MergeTree()</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> expr</span><br><span class="line">[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[PRIMARY <span class="keyword">KEY</span> expr]</span><br><span class="line">[<span class="keyword">SAMPLE</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[TTL expr [<span class="keyword">DELETE</span>|<span class="keyword">TO</span> DISK <span class="string">'xxx'</span>|<span class="keyword">TO</span> VOLUME <span class="string">'xxx'</span>], ...]</span><br><span class="line">[<span class="keyword">SETTINGS</span> <span class="keyword">name</span>=<span class="keyword">value</span>, ...]</span><br></pre></td></tr></table></figure><hr><h3 id="2、配置参数介绍"><a href="#2、配置参数介绍" class="headerlink" title="2、配置参数介绍"></a>2、配置参数介绍</h3><ol><li>必填项：</li></ol><ul><li><code>ENGINE</code>：指定使用的引擎。</li><li><code>ORDER BY</code>：排序键，用于指定在一个数据片段内，使用的排序方式。<ul><li>当未指定排序键时，默认会使用主键排序，同样的，当未指定主键时，默认会使用排序键作为主键</li><li>可以是单列名称或多列字段的元组格式。例如：<code>ORDER BY (CounterId)</code>或``ORDER BY (CounterID, EventDate)`</li><li>当使用多列字段排序，例如<code>ORDER BY (CounterID, EventDate)</code>，在单个数据片段内，会先根据CounterID字段排序，CounterID相同的数据再按照EventDate排序</li></ul></li></ul><ol start="2"><li>可选项：</li></ol><ul><li><code>PARITION BY</code>：分区键</li><li><code>PRIMARY KEY</code>：主键，指定后会按照主键字段生成一级索引，用于加速表查询。默认情况下与<code>ORDER BY</code>子句相同，否则的话主键表达式必须为排序表达式元组的前缀。主键声明后，单个数据片段内会按照主键字段升序排序。<strong>MergeTree主键允许数据重复。</strong></li><li><code>SAMPLE BY</code>：抽样表达式。若指定了该选项，则主键也必须包含它。例如：<code>...ENGINE = MergeTree() ORDER BY (CounterID, EventDate, intHash32(UserID)) SAMPLE BY intHash32(UserID)</code></li><li><code>TTL</code>：数据生存期，用于指定数据的存储时间。<ul><li>表达式中必须包含一个<code>Date</code>或<code>DateTime</code>类型的列，例如：<code>TTL date + INTERVAL 1 DAY</code>，默认当表中数据达到这个时间时，会删除对应的数据信息</li><li>也可对满足该表达式的数据进行对应操作，例如：<code>TTL date + INTERVAL 1 MONTH DELETE|TO DISK &#39;xxx&#39;</code>，对满足表达式的数据，表中删除过期的行并移动到指定的磁盘上</li><li>可以指定多个规则的操作，但只能有一个<code>DELETE</code>操作</li></ul></li><li><code>SETTING</code>：控制MergeTree的其他可选参数<ul><li><code>index_granularity</code>：索引粒度，默认值为8192。表示在默认情况下，clickhouse每间隔8192条数据生成一条索引</li><li><code>index_granularity_bytes</code>：索引粒度，早期版本只允许<code>index_granularity</code>参数按照间隔数据条数设置索引粒度，后续版本支持该参数设置数据量大小限制索引粒度，默认值为10M，设置为0表示不启动根据数据量自适应功能</li><li><code>enable_mixed_granularity_parts</code>：表示是否开启自适应限制索引粒度的功能，默认开启</li><li><code>merge_with_ttl_timeout</code>：TTL合并频率的最小时间间隔，默认值为86400(1天)</li><li><code>use_minimalistic_part_header_in_zookeeper</code>：设置数据片段头部在zookeeper中的存储方式</li><li><code>min_merge_bytes_to_use_direct_io</code>：当数据量大于这个值时，使用直接I/O来读取数据并进行合并操作，默认值为10G，设置为0时表示禁用直接I/O</li><li><code>storage_policy</code>：设置存储策略</li></ul></li></ul><h2 id="三、MergeTree存储结构"><a href="#三、MergeTree存储结构" class="headerlink" title="三、MergeTree存储结构"></a>三、MergeTree存储结构</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试数据库</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test.partitioned_by_week(d <span class="built_in">Date</span>, x UInt8) <span class="keyword">ENGINE</span> = MergeTree <span class="keyword">PARTITION</span> <span class="keyword">BY</span> toMonday(d) <span class="keyword">ORDER</span> <span class="keyword">BY</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test.partitioned_by_week</span><br><span class="line">(</span><br><span class="line">    <span class="string">`d`</span> <span class="built_in">Date</span>, </span><br><span class="line">    <span class="string">`x`</span> UInt8</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span> = MergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toMonday(d)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> x</span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入两条测试数据</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.partitioned_by_week <span class="keyword">VALUES</span> (<span class="string">'2000-01-01'</span>, <span class="number">1</span>), (<span class="string">'2000-01-02'</span>, <span class="number">2</span>), (<span class="string">'2000-01-03'</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test.partitioned_by_week <span class="keyword">VALUES</span></span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.070</span> sec. </span><br><span class="line"></span><br><span class="line"><span class="comment">-- test库下的表</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span></span><br><span class="line"></span><br><span class="line">┌─<span class="keyword">name</span>────────────────┐</span><br><span class="line">│ partitioned_by_week │</span><br><span class="line">└─────────────────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.007</span> sec.</span><br></pre></td></tr></table></figure><p>​    执行上述操作后，查看clickhouse中test库下的数据目录如下：</p><img src="/2020/06/11/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMergeTree%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/mergetree1.png" style="zoom:45%;"><p>​    可以看出，一张表完整的物理结构由表目录、分区目录、数据文件作为层级组成，他们各自的作用如下：</p><ul><li><p>partition：分区目录</p><ul><li>测试数据中分区目录为<code>19991227_1_1_0</code>和<code>20000103_2_2_0</code>，属于相同分区的数据，会被合并到同一个分区目录中</li></ul></li><li><p>checksums.txt：校验文件</p><ul><li>按二进制格式存储，保存了剩余数据文件的大小及其哈希值，用于快速校验数据文件的完整性和准确性</li></ul></li><li><p>columns.txt：列信息文件</p><ul><li>使用明文存储，用于保存该分区目录下的列字段信息。例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@xxxx <span class="built_in">test</span>]<span class="comment"># cat partitioned_by_week/19991227_1_1_0/columns.txt </span></span><br><span class="line">columns format version: 1</span><br><span class="line">2 columns:</span><br><span class="line">`d` Date</span><br><span class="line">`x` UInt8</span><br></pre></td></tr></table></figure></li><li><p>count.txt：计数文件</p><ul><li>使用明文存储，记录保存了当前数据分区目录下的数据行数。例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@xxxx <span class="built_in">test</span>]<span class="comment"># cat partitioned_by_week/19991227_1_1_0/count.txt </span></span><br><span class="line">2</span><br></pre></td></tr></table></figure></li><li><p>primary.idx：一级索引文件</p><ul><li>使用二进制格式存储。用于存放稀疏索引，一张MergeTree通过ORDER BY或PRIMARY KEY只能声明一个一级索引</li></ul></li><li><p>[column].bin：数据文件</p><ul><li>默认使用LZ4压缩格式存储。用来存放该数据分区的某列的数据。MergeTree采用了列式存储，故每列字段都有独立的bin数据文件，以列名命名。</li></ul></li><li><p>[column].mrk或[column].mrk2：列字段标记文件</p><ul><li>使用二进制格式存储。保存了[column].bin文件的偏移量信息，MergeTree通过该文件建立了primary.idx稀疏索引与[column].bin文件之间的映射关系。它会先通过primary.idx找到对应数据的偏移量信息column.mrk，再通过偏移量直接从[column].bin文件中读取数据。该文件与[column].bin文件一一对应，也是每列字段都有独立的mrk文件，如果使用了自适应大小的索引间隔，会以.mrk2命名</li></ul></li><li><p>partition.dat和minmax_d.idx：分区索引文件</p><ul><li>当使用了分区键，例如<code>PARTITION BY toMonday(d)</code>，便会生成partition.dat和minmax_d.idx索引文件，均适用二进制格式存储。</li><li>partition.dat用于保存当前分区下，分区表达式最终生成的值</li><li>minmax_d.idx用于记录当前分区下，分区字段对应原始数据的最小和最大值</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、MergeTree系列引擎概述&quot;&gt;&lt;a href=&quot;#一、MergeTree系列引擎概述&quot; class=&quot;headerlink&quot; title=&quot;一、MergeTree系列引擎概述&quot;&gt;&lt;/a&gt;一、MergeTree系列引擎概述&lt;/h2&gt;&lt;p&gt;​    在Clic
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
      <category term="MergeTree" scheme="https://schnappi618.github.io/tags/MergeTree/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎之MySQL引擎</title>
    <link href="https://schnappi618.github.io/2020/06/09/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMySQL%E5%BC%95%E6%93%8E/"/>
    <id>https://schnappi618.github.io/2020/06/09/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMySQL%E5%BC%95%E6%93%8E/</id>
    <published>2020-06-09T09:25:13.000Z</published>
    <updated>2020-07-12T12:14:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>​    ClickHouse提供了MySQL库引擎可以将MySQL中的表映射到ClickHouse中，并允许用户通过clickhouse对数据进行insert和update操作。实际的操作其实都在<strong>MySQL服务器上完成</strong>，MySQL引擎会将查询转换为MySQL语法并发送到MySQL服务器上面并实现数据交互，但无法通过clickhouse对MySQL数据执行rename、create table、alter等操作。</p><h2 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h2><h3 id="1、ClickHouse建库语法"><a href="#1、ClickHouse建库语法" class="headerlink" title="1、ClickHouse建库语法"></a>1、ClickHouse建库语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] db_name [<span class="keyword">ON</span> CLUSTER cluster]</span><br><span class="line"><span class="keyword">ENGINE</span> = MySQL(<span class="string">'host:port'</span>, <span class="string">'database'</span>, <span class="string">'user'</span>, <span class="string">'password'</span>)</span><br></pre></td></tr></table></figure><p><strong>MySQL引擎参数：</strong></p><ol><li><code>host:port</code>:MySQL地址</li><li><code>database</code>:MySQL数据库名，不指定则表示全部映射</li><li><code>user</code>:使用的用户名</li><li><code>password</code>:用户密码</li></ol><h3 id="2、使用示例"><a href="#2、使用示例" class="headerlink" title="2、使用示例"></a>2、使用示例</h3><h4 id="2-1-环境准备"><a href="#2-1-环境准备" class="headerlink" title="2.1 环境准备"></a>2.1 环境准备</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建映射库，本次使用的clickhouse是由docker启动的，故使用以下命令进入clickhouse客户端</span></span><br><span class="line">[root@xxxx docker_compose]<span class="comment"># docker exec -it 817eeb4e2569 clickhouse-client</span></span><br><span class="line"><span class="comment">-- 用户需有对应操作的权限</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">create</span> <span class="keyword">database</span> test_4098 \</span><br><span class="line">:-] <span class="keyword">ENGINE</span> = MySQL(<span class="string">'x.x.x.x:4098'</span>, <span class="string">'dbzz_dbreport'</span>, \</span><br><span class="line">:-] <span class="string">'dba'</span>, <span class="string">'xxxxxx'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> test_4098</span><br><span class="line"><span class="keyword">ENGINE</span> = MySQL(<span class="string">'x.x.x.x:4098'</span>, <span class="string">'dbzz_dbreport'</span>, <span class="string">'dba'</span>, <span class="string">'xxxxxx'</span>)</span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.030</span> sec. </span><br><span class="line"></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span></span><br><span class="line"></span><br><span class="line">┌─<span class="keyword">name</span>──────┐</span><br><span class="line">│ datasets  │</span><br><span class="line">│ <span class="keyword">default</span>   │</span><br><span class="line">│ <span class="keyword">system</span>    │</span><br><span class="line">│ <span class="keyword">test</span>      │</span><br><span class="line">│ test_4098 │</span><br><span class="line">└───────────┘</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.002</span> sec. </span><br><span class="line"><span class="comment">-- 创建成功之后在MySQL数据库中执行 show processlist; 可以看到成功创建的连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在对应MySQL库上面创建一个测试表，并插入一条数据</span></span><br><span class="line">(dba:<span class="number">4098</span>)@[dbzz_dbreport]&gt;<span class="keyword">create</span> <span class="keyword">table</span> clickhouse_test_table (</span><br><span class="line">    -&gt; <span class="string">`int_id`</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    -&gt; <span class="string">`float`</span> <span class="built_in">FLOAT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    -&gt; PRIMARY <span class="keyword">KEY</span> (<span class="string">`int_id`</span>));</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line">(dba:4098)@[dbzz_dbreport]&gt;insert into clickhouse_test_table values(1, 2); </span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br></pre></td></tr></table></figure><img src="/2020/06/09/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/ClickHouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B9%8BMySQL%E5%BC%95%E6%93%8E/MySQL_engine1.png" style="zoom:33%;"><p>​    上图所在的metadata目录是clickhouse的元数据目录，里面记录了所有建库、建表的语句，可以看出本次测试的test_4098库仅有建库语句，表并不是通过clickhouse创建的；上一级的data目录记录了所有库具体的数据文件信息，可看出并没有test_4098和test_4098_ro库相关数据信息。</p><h4 id="2-2-clickhouse测试"><a href="#2-2-clickhouse测试" class="headerlink" title="2.2 clickhouse测试"></a>2.2 clickhouse测试</h4><ul><li>在clickhouse上执行show tables</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clickhouse对应日志如下，可以看到将show tables语句转换为了SELECT name FROM system.tables WHERE database = 'test_4098'语句</span></span><br><span class="line">2020.06.10 16:10:12.871697 [ 81 ] &#123;3c0db0d4-5f48-4896-8418-6d1e0211a3c8&#125; &lt;Debug&gt; executeQuery: (from 127.0.0.1:55258) SHOW TABLES</span><br><span class="line">2020.06.10 16:10:12.871899 [ 81 ] &#123;3c0db0d4-5f48-4896-8418-6d1e0211a3c8&#125; &lt;Debug&gt; executeQuery: (internal) SELECT name FROM system.tables WHERE database = <span class="string">'test_4098'</span></span><br><span class="line">2020.06.10 16:10:12.872213 [ 81 ] &#123;3c0db0d4-5f48-4896-8418-6d1e0211a3c8&#125; &lt;Trace&gt; AccessRightsContext (default): Access granted: SELECT(database, name) ON system.tables</span><br><span class="line">2020.06.10 16:10:12.872344 [ 81 ] &#123;3c0db0d4-5f48-4896-8418-6d1e0211a3c8&#125; &lt;Trace&gt; InterpreterSelectQuery: FetchColumns -&gt; Complete</span><br><span class="line">2020.06.10 16:10:12.872580 [ 99 ] &#123;3c0db0d4-5f48-4896-8418-6d1e0211a3c8&#125; &lt;Trace&gt; AccessRightsContext (default): Access granted: SHOW ON *.*</span><br><span class="line">2020.06.10 16:10:12.876803 [ 81 ] &#123;3c0db0d4-5f48-4896-8418-6d1e0211a3c8&#125; &lt;Information&gt; executeQuery: Read 27 rows, 1.36 KiB <span class="keyword">in</span> 0.005 sec., 5360 rows/sec., 269.67 KiB/sec.</span><br><span class="line">2020.06.10 16:10:12.876840 [ 81 ] &#123;3c0db0d4-5f48-4896-8418-6d1e0211a3c8&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (<span class="keyword">for</span> query): 0.00 B.</span><br><span class="line">2020.06.10 16:10:12.876934 [ 81 ] &#123;&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (total): 0.00 B.</span><br><span class="line">2020.06.10 16:10:12.876956 [ 81 ] &#123;&#125; &lt;Information&gt; TCPHandler: Processed <span class="keyword">in</span> 0.005 sec.</span><br></pre></td></tr></table></figure><ul><li>clickhouse上查询表中信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行对应表查询</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">select</span> * <span class="keyword">from</span> clickhouse_test_table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> clickhouse_test_table</span><br><span class="line"></span><br><span class="line">┌─int_id─┬─<span class="built_in">float</span>─┐</span><br><span class="line">│      <span class="number">1</span> │     <span class="number">2</span> │</span><br><span class="line">└────────┴───────┘</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.034</span> sec. </span><br><span class="line"></span><br><span class="line"><span class="comment">-- clickhouse日志显示，可以看到会先和对应的MySQL实例建立连接</span></span><br><span class="line"><span class="comment">-- 查询语句被转换为了 SELECT(int_id, float) ON test_4098.clickhouse_test_table </span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">14.851866</span> [ <span class="number">81</span> ] &#123;<span class="number">54864811</span><span class="number">-5</span>b01<span class="number">-4</span>f41<span class="number">-9</span>abf-b4280e7c277b&#125; &lt;Debug&gt; executeQuery: (<span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">55258</span>) <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> clickhouse_test_table</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">14.864183</span> [ <span class="number">81</span> ] &#123;<span class="number">54864811</span><span class="number">-5</span>b01<span class="number">-4</span>f41<span class="number">-9</span>abf-b4280e7c277b&#125; &lt;<span class="keyword">Trace</span>&gt; AccessRightsContext (<span class="keyword">default</span>): <span class="keyword">Access</span> granted: <span class="keyword">SELECT</span>(int_id, <span class="built_in">float</span>) <span class="keyword">ON</span> test_4098.clickhouse_test_table</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">14.868456</span> [ <span class="number">81</span> ] &#123;<span class="number">54864811</span><span class="number">-5</span>b01<span class="number">-4</span>f41<span class="number">-9</span>abf-b4280e7c277b&#125; &lt;Information&gt; Application: MYSQL: Connecting <span class="keyword">to</span> dbzz_dbreport@<span class="number">10.148</span><span class="number">.16</span><span class="number">.25</span>:<span class="number">4098</span> <span class="keyword">as</span> <span class="keyword">user</span> dba</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">14.880487</span> [ <span class="number">81</span> ] &#123;<span class="number">54864811</span><span class="number">-5</span>b01<span class="number">-4</span>f41<span class="number">-9</span>abf-b4280e7c277b&#125; &lt;<span class="keyword">Trace</span>&gt; InterpreterSelectQuery: FetchColumns -&gt; <span class="keyword">Complete</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">14.882556</span> [ <span class="number">81</span> ] &#123;<span class="number">54864811</span><span class="number">-5</span>b01<span class="number">-4</span>f41<span class="number">-9</span>abf-b4280e7c277b&#125; &lt;Information&gt; executeQuery: <span class="keyword">Read</span> <span class="number">1</span> <span class="keyword">rows</span>, <span class="number">8.00</span> B <span class="keyword">in</span> <span class="number">0.031</span> sec., <span class="number">32</span> <span class="keyword">rows</span>/sec., <span class="number">261.44</span> B/sec.</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">14.882602</span> [ <span class="number">81</span> ] &#123;<span class="number">54864811</span><span class="number">-5</span>b01<span class="number">-4</span>f41<span class="number">-9</span>abf-b4280e7c277b&#125; &lt;Debug&gt; MemoryTracker: Peak <span class="keyword">memory</span> <span class="keyword">usage</span> (<span class="keyword">for</span> <span class="keyword">query</span>): <span class="number">0.00</span> B.</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">14.884205</span> [ <span class="number">81</span> ] &#123;&#125; &lt;Debug&gt; MemoryTracker: Peak <span class="keyword">memory</span> <span class="keyword">usage</span> (total): <span class="number">0.00</span> B.</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">13</span>:<span class="number">14.884845</span> [ <span class="number">81</span> ] &#123;&#125; &lt;Information&gt; TCPHandler: Processed <span class="keyword">in</span> <span class="number">0.033</span> sec.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 打开MySQL全日志后，看到所有操作均在MySQL上执行</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-10</span>T08:<span class="number">54</span>:<span class="number">11.541873</span>Z <span class="number">74904749</span> <span class="keyword">Query</span>  <span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">AS</span> table_name,  CREATE_TIME <span class="keyword">AS</span> modification_time  <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES  <span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'dbzz_dbreport'</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-10</span>T08:<span class="number">54</span>:<span class="number">11.545698</span>Z <span class="number">74904749</span> <span class="keyword">Query</span>  <span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">AS</span> table_name,  CREATE_TIME <span class="keyword">AS</span> modification_time  <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES  <span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'dbzz_dbreport'</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-10</span>T08:<span class="number">54</span>:<span class="number">11.549140</span>Z <span class="number">74904749</span> <span class="keyword">Query</span>  <span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">AS</span> table_name,  CREATE_TIME <span class="keyword">AS</span> modification_time  <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES  <span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'dbzz_dbreport'</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-10</span>T08:<span class="number">54</span>:<span class="number">11.552753</span>Z <span class="number">74904749</span> <span class="keyword">Query</span>  <span class="keyword">SELECT</span> TABLE_NAME <span class="keyword">AS</span> table_name,  CREATE_TIME <span class="keyword">AS</span> modification_time  <span class="keyword">FROM</span> INFORMATION_SCHEMA.TABLES  <span class="keyword">WHERE</span> TABLE_SCHEMA = <span class="string">'dbzz_dbreport'</span></span><br><span class="line"><span class="number">2020</span><span class="number">-06</span><span class="number">-10</span>T08:<span class="number">54</span>:<span class="number">11.556415</span>Z <span class="number">75644195</span> <span class="keyword">Query</span>  <span class="keyword">SELECT</span> <span class="string">`int_id`</span>, <span class="string">`float`</span> <span class="keyword">FROM</span> <span class="string">`dbzz_dbreport`</span>.<span class="string">`clickhouse_test_table`</span></span><br></pre></td></tr></table></figure><ul><li>在clickhouse上插入数据</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 执行对应插入数据操作</span></span><br><span class="line">clickhouse-server_1 :) <span class="keyword">insert</span> <span class="keyword">into</span> clickhouse_test_table <span class="keyword">values</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> clickhouse_test_table <span class="keyword">VALUES</span></span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">rows</span> <span class="keyword">in</span> set. Elapsed: <span class="number">0.042</span> sec.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- clickhouse日志显示：在连接已经存在的情况下，可以看到进行权限检查后执行了insert操作</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">51.172346</span> [ <span class="number">81</span> ] &#123;<span class="number">2</span>a1b1d66-dfed<span class="number">-460e-89</span>fe-e7cc9ae3cfa6&#125; &lt;Debug&gt; executeQuery: (<span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">55258</span>) <span class="keyword">insert</span> <span class="keyword">into</span> clickhouse_test_table <span class="keyword">values</span></span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">51.177580</span> [ <span class="number">81</span> ] &#123;<span class="number">2</span>a1b1d66-dfed<span class="number">-460e-89</span>fe-e7cc9ae3cfa6&#125; &lt;<span class="keyword">Trace</span>&gt; AccessRightsContext (<span class="keyword">default</span>): <span class="keyword">Access</span> granted: <span class="keyword">INSERT</span>(int_id, <span class="built_in">float</span>) <span class="keyword">ON</span> test_4098.clickhouse_test_table</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">51.209389</span> [ <span class="number">81</span> ] &#123;<span class="number">2</span>a1b1d66-dfed<span class="number">-460e-89</span>fe-e7cc9ae3cfa6&#125; &lt;Debug&gt; MemoryTracker: Peak <span class="keyword">memory</span> <span class="keyword">usage</span> (<span class="keyword">for</span> <span class="keyword">query</span>): <span class="number">0.00</span> B.</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">51.209481</span> [ <span class="number">81</span> ] &#123;&#125; &lt;Debug&gt; MemoryTracker: Peak <span class="keyword">memory</span> <span class="keyword">usage</span> (total): <span class="number">0.00</span> B.</span><br><span class="line"><span class="number">2020.06</span><span class="number">.10</span> <span class="number">16</span>:<span class="number">18</span>:<span class="number">51.209545</span> [ <span class="number">81</span> ] &#123;&#125; &lt;Information&gt; TCPHandler: Processed <span class="keyword">in</span> <span class="number">0.037</span> sec.</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 解析MySQL二进制日志，可看出写入操作在MySQL上进行</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">/*!*/</span>;</span><br><span class="line"><span class="comment"># at 340</span></span><br><span class="line"><span class="comment">#200610 16:18:51 server id 210894098  end_log_pos 415 CRC32 0x46a5ba76  Table_map: `dbzz_dbreport`.`clickhouse_test_table` mapped to number 2067</span></span><br><span class="line"><span class="comment"># at 415</span></span><br><span class="line"><span class="comment">#200610 16:18:51 server id 210894098  end_log_pos 459 CRC32 0xd8f0a3ac  Write_rows: table id 2067 flags: STMT_END_F</span></span><br><span class="line"><span class="comment">### INSERT INTO `dbzz_dbreport`.`clickhouse_test_table`</span></span><br><span class="line"><span class="comment">### SET</span></span><br><span class="line"><span class="comment">###   @1=3</span></span><br><span class="line"><span class="comment">###   @2=4                   </span></span><br><span class="line"><span class="comment"># at 459</span></span><br><span class="line"><span class="comment">#200610 16:18:51 server id 210894098  end_log_pos 490 CRC32 0xcb88aafc  Xid = 36747174953</span></span><br><span class="line"><span class="keyword">COMMIT</span><span class="comment">/*!*/</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h2&gt;&lt;p&gt;​    ClickHouse提供了MySQL库引擎可以将MySQL中的表映射到ClickHouse中，并允许用户通过cli
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
  </entry>
  
  <entry>
    <title>ClickHouse存储引擎概述</title>
    <link href="https://schnappi618.github.io/2020/05/23/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/clickhouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/"/>
    <id>https://schnappi618.github.io/2020/05/23/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/clickhouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/</id>
    <published>2020-05-23T09:40:08.000Z</published>
    <updated>2020-07-12T12:13:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇内容参考：<a href="https://clickhouse.tech/docs/zh/engines/table-engines/" target="_blank" rel="noopener">clickhouse官方文档</a></p><h2 id="一、ClickHouse引擎的作用"><a href="#一、ClickHouse引擎的作用" class="headerlink" title="一、ClickHouse引擎的作用"></a>一、ClickHouse引擎的作用</h2><p>​    ClickHouse引擎可分为库引擎和表引擎。ClickHouse引擎的作用基本如下：</p><ul><li>数据的存储方式和位置：例如log系列引擎将数据写入在磁盘上，而Special系列的引擎将数据写入在内存上，但Distributed引擎并不存储书籍，仅作为中间件转发</li><li>支持的哪些查询方式：例如log系列引擎不支持update和delete操作</li><li>是否支持并发访问数据，是否可以执行多线程的请求：例如TinyLog引擎不支持并发读取，而Log引擎支持并发读取</li><li>是否可以使用索引：例如log系列引擎并不支持使用索引</li><li>数据如何进行复制：不同的存储引擎进行数据复制的参数完全不同</li></ul><h2 id="二、ClickHouse库引擎分类"><a href="#二、ClickHouse库引擎分类" class="headerlink" title="二、ClickHouse库引擎分类"></a>二、ClickHouse库引擎分类</h2><p>ClickHouse目前支持5种库引擎：</p><ul><li>Ordinary：默认引擎。在该引擎下可以使用任何类型的表引擎</li><li>Dictionary：字典引擎。这种引擎的数据库会自动为所有的数据字典创建它们的数据表</li><li>Memory：内存引擎。用于存放临时数据，这种引擎的数据库下的表只会停留在内存中，不涉及任何磁盘操作，服务重启后数据会被清除</li><li>Lazy：日志引擎。该类数据库只能只用Log系列的表引擎</li><li>MySQL引擎。该类数据库会自动拉取远端MySQL中的数据，并创建MySQL表引擎的数据表。</li></ul><h2 id="三、ClickHouse表引擎分类"><a href="#三、ClickHouse表引擎分类" class="headerlink" title="三、ClickHouse表引擎分类"></a>三、ClickHouse表引擎分类</h2><p>​    ClickHouse提供了大概27种适用于不同情况的表引擎，其中整体大概分为4类，分类大致如下图所示：</p><img src="/2020/05/23/clickhouse/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/clickhouse%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0/%E8%A1%A8%E5%BC%95%E6%93%8E.jpeg" style="zoom:30%;"><p>​    ClickHouse主要将表引擎分为了四类：</p><ul><li>MergeTree系列是主要适用的存储引擎，几乎可以支持clickhouse的所有功能使用</li><li>Log系列主要适用于快速小表写入，全部读出的场景，但之间仍存在查询性能的区别</li><li>Integration系列主要用于将外部数据导入到clickhosue中，或直接在clickhouse中处理其他的数据。例如之前使用过MySQL表引擎在clickhouse中连接到MySQL数据库，直接针对其数据进行查询</li><li>Special系列大多数是为了一些特殊的场景来进行的处理：例如Distributed本身不存储数据，一般作为中间件执行数据聚合等操作返回给用户；Memory将数据写入到内存中，服务重启数据丢失，一般用来做临时表；Null直接将写入数据丢弃，读取时为空，但适合用来作为视图使用等。</li></ul><p>​    具体每类表引擎中各个引擎的区别及使用方法会在后续文档中分别进行描述，重点会在于MergeTree和log系列。其余引擎会简单描述其适用场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇内容参考：&lt;a href=&quot;https://clickhouse.tech/docs/zh/engines/table-engines/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clickhouse官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、C
      
    
    </summary>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/categories/clickhouse/"/>
    
    
      <category term="clickhouse" scheme="https://schnappi618.github.io/tags/clickhouse/"/>
    
      <category term="engine" scheme="https://schnappi618.github.io/tags/engine/"/>
    
  </entry>
  
  <entry>
    <title>行存与列存的简单对比</title>
    <link href="https://schnappi618.github.io/2020/04/25/DB/%E8%A1%8C%E5%AD%98%E4%B8%8E%E5%88%97%E5%AD%98%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/"/>
    <id>https://schnappi618.github.io/2020/04/25/DB/%E8%A1%8C%E5%AD%98%E4%B8%8E%E5%88%97%E5%AD%98%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/</id>
    <published>2020-04-25T04:19:58.000Z</published>
    <updated>2020-07-12T12:11:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、行式存储"><a href="#一、行式存储" class="headerlink" title="一、行式存储"></a>一、行式存储</h2><p>​        一般的事务型数据库(OLTP)基本会增删改查同一行数据，故大多使用了行式存储，所有数据按列名排成一行，可通过主键快速找到对应的那行数据，基本数据存储情况如下表。</p><table><thead><tr><th>编号</th><th>姓名</th><th>年龄</th><th>居住地</th><th>学位</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>20</td><td>北京</td><td>本科</td></tr><tr><td>2</td><td>李四</td><td>21</td><td>上海</td><td>硕士</td></tr><tr><td>3</td><td>王五</td><td>22</td><td>广州</td><td>博士</td></tr></tbody></table><p>​        物理存储格式基本如下：</p><img src="/2020/04/25/DB/%E8%A1%8C%E5%AD%98%E4%B8%8E%E5%88%97%E5%AD%98%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/1.png" style="zoom:50%;"><h2 id="二、列式存储"><a href="#二、列式存储" class="headerlink" title="二、列式存储"></a>二、列式存储</h2><p>​        一般OLAP系统需要查询大量的数据，但仅需要关注其中几个列的数据，基于使用情况，一般会使用列式存储。同样的数据按列存储，基本数据存储情况为：</p><table><thead><tr><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>张三</td><td>李四</td><td>王五</td></tr><tr><td>20</td><td>21</td><td>22</td></tr><tr><td>北京</td><td>上海</td><td>广州</td></tr><tr><td>本科</td><td>硕士</td><td>博士</td></tr></tbody></table><p>​        物理存储格式基本如下：</p><img src="/2020/04/25/DB/%E8%A1%8C%E5%AD%98%E4%B8%8E%E5%88%97%E5%AD%98%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/2.png" style="zoom:50%;"><h2 id="三、读写对比"><a href="#三、读写对比" class="headerlink" title="三、读写对比"></a>三、读写对比</h2><h3 id="1、数据写入"><a href="#1、数据写入" class="headerlink" title="1、数据写入"></a>1、数据写入</h3><ol><li>按照上述示例结构，行存储写入一条数据仅需一次便可直接完成，并且可以保证数据完整性</li><li>列存储上述示例数据写入一条数据，需要拆成五列进行保存，写入次数比行存储翻了五倍，实际写入时间会更长</li></ol><h3 id="2、数据修改"><a href="#2、数据修改" class="headerlink" title="2、数据修改"></a>2、数据修改</h3><ol><li>若需要修改一条数据，行存储到指定位置写入一次即可，列存储需要定位到多个位置进行写入，按上述示例数据，列存储所需次数仍是行存储的5倍</li></ol><h3 id="3、数据读取"><a href="#3、数据读取" class="headerlink" title="3、数据读取"></a>3、数据读取</h3><ol><li>读取某行数据时，行存储会将该条记录的所有数据读出，若仅需要其中某列的数据，则存在了数据冗余，通常会消耗内存来消除这些冗余列数据</li><li>列存储读取的均为所需要的某一段数据，不存在冗余列的数据</li><li>由于行存储读取的数据包含了多种类型，可能存在数据类型之间的转换从而对数据进行解析，列存储读出的每一段数据的类型均相同，不需要对数据进行类型转换，可以使用不同方法对不同类型进行数据压缩，列存储更有利于对大数据进行分析</li></ol><h2 id="四、适用场景"><a href="#四、适用场景" class="headerlink" title="四、适用场景"></a>四、适用场景</h2><p>​    简单来讲，行存储更适合于OLAP场景，列存储更适合于OLTP场景。</p><p>​    当经常需要对某些行进行增删改，无法进行批处理操作，经常关注整张表的结构和数据而不只是某几列的数据，对获取到的数据也并没有很大二次计算处理的需求，此时更适合使用行存储。</p><p>​    若写数据的操作可以进行批量处理，并且经常需要对读取的数据进行聚合运算分析场景时，更适合使用列存储，这是由于列式存储可以对字段数据进行向量化处理，可以将一个列的一整个字段连续读入CPU cache中，可以利用CPU的向量化处理并进行一些常用的计算等操作。</p><h2 id="五、ClickHouse查询写入测试"><a href="#五、ClickHouse查询写入测试" class="headerlink" title="五、ClickHouse查询写入测试"></a>五、ClickHouse查询写入测试</h2><h3 id="1、测试数据导入"><a href="#1、测试数据导入" class="headerlink" title="1、测试数据导入"></a>1、测试数据导入</h3><p>​        本次ClickHouse使用官方提供的Yandex.Metrica Data测试数据来进行测试，其中包含两张表visit_v1(访问数据)和hits_v1(Yandex.Metrica提供的查询匹配数据)，安装流程可参考<a href="https://clickhouse.tech/docs/en/getting_started/example_datasets/metrica/" target="_blank" rel="noopener">ClickHouse测试数据导入</a>，由于官方提供的导入方式前提为直接安装了clickhouse服务，而之前一直使用docker方式来进行安装，所以这里简单描述docker环境下如何导入测试数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用了docker-compose打包了clickhouse镜像</span></span><br><span class="line"><span class="comment">## 1. 下载并解压测试数据</span></span><br><span class="line">[root@xxxx clickhouse]<span class="comment"># curl https://clickhouse-datasets.s3.yandex.net/hits/tsv/hits_v1.tsv.xz | unxz --threads=`nproc` &gt; hits_v1.tsv</span></span><br><span class="line">[root@xxxx clickhouse]<span class="comment"># curl https://clickhouse-datasets.s3.yandex.net/visits/tsv/visits_v1.tsv.xz | unxz --threads=`nproc` &gt; visits_v1.tsv</span></span><br><span class="line"><span class="comment">## 2. 在docker-compose配置文件中volume中添加一个地址和镜像中的对应</span></span><br><span class="line">[root@xxxx docker_compose]<span class="comment"># ll</span></span><br><span class="line">total 28</span><br><span class="line">-rw-r--r--  1 root root 14907 Apr 30 15:49 config.xml</span><br><span class="line">drwxr-xr-x 10  101  101   204 Apr 26 18:56 data</span><br><span class="line">-rw-r--r--  1 root root   733 Apr 26 18:46 docker-compose.yml</span><br><span class="line">drwxr-xr-x  2 root root    80 Apr 30 15:53 <span class="built_in">log</span></span><br><span class="line">drwxr-xr-x  2  101  101    58 Apr 30 15:41 tmp</span><br><span class="line">-rw-r--r--  1 root root  4532 Mar 30 17:43 users.xml</span><br><span class="line">[root@xxxx docker_compose]<span class="comment"># vim docker-compose.yml</span></span><br><span class="line">    volumes:</span><br><span class="line">      ... </span><br><span class="line">      - ./tmp:/var/lib/clickhouse/tmp</span><br><span class="line"><span class="comment"># 这里使用tmp目录存放下载的测试数据，映射到镜像中的/var/lib/clickhouse/tmp目录</span></span><br><span class="line">[root@xxxx docker_compose]<span class="comment"># ll tmp/</span></span><br><span class="line">total 10197044</span><br><span class="line">-rw-r--r-- 1  101  101 7784351125 Apr 26 18:32 hits_v1.tsv</span><br><span class="line">-rw-r--r-- 1 root root 2657415178 Apr 30 15:41 visits_v1.tsv</span><br><span class="line"><span class="comment"># docker clickhouse已经启动，进入docker环境导入数据即可</span></span><br><span class="line">[root(host/tjtx148-16-25.58os.org)@tjtx162-17-78 docker_compose]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE                                                     COMMAND                  CREATED             STATUS                 PORTS                                                                              NAMES</span><br><span class="line">968b926da80b        clickhouse-server-demo:1.0                                <span class="string">"/entrypoint.sh"</span>         3 days ago          Up 3 days              0.0.0.0:8123-&gt;8123/tcp, 0.0.0.0:9000-&gt;9000/tcp, 0.0.0.0:9004-&gt;9004/tcp, 9009/tcp   clickhouse-server_1</span><br><span class="line"><span class="comment">## 3. 导入测试数据</span></span><br><span class="line">[root@xxxx docker_compose]<span class="comment"># docker exec -it clickhouse-server_1 /bin/bash</span></span><br><span class="line">root@clickhouse-server_1:/<span class="comment"># ll /var/lib/clickhouse/tmp/</span></span><br><span class="line">total 10197044</span><br><span class="line">drwxr-xr-x  2 clickhouse clickhouse         58 Apr 30 07:41 ./</span><br><span class="line">drwxr-xr-x 10 clickhouse clickhouse        204 Apr 26 10:56 ../</span><br><span class="line">-rw-r--r--  1 clickhouse clickhouse 7784351125 Apr 26 10:32 hits_v1.tsv</span><br><span class="line">-rw-r--r--  1 root       root       2657415178 Apr 30 07:41 visits_v1.tsv</span><br><span class="line">root@clickhouse-server_1:/<span class="comment"># clickhouse-client --query "CREATE DATABASE IF NOT EXISTS datasets"</span></span><br><span class="line">... <span class="comment"># 建表语句参考官方文档即可</span></span><br><span class="line"><span class="comment">## 将visiit_v1.tsv测试数据导入，另外一张表hists_v1采用同样方法导入</span></span><br><span class="line">root@clickhouse-server_1:/<span class="comment"># cat visits_v1.tsv | clickhouse-client --query "INSERT INTO datasets.visits_v1 FORMAT TSV" --max_insert_block_size=100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 4. 检验测试数据量</span></span><br><span class="line">root@clickhouse-server_1:/<span class="comment"># clickhouse-client </span></span><br><span class="line">ClickHouse client version 20.3.4.10 (official build).</span><br><span class="line">Connecting to localhost:9000 as user default.</span><br><span class="line">Connected to ClickHouse server version 20.3.4 revision 54433.</span><br><span class="line"></span><br><span class="line">clickhouse-server_1 :) use datasets</span><br><span class="line"></span><br><span class="line">USE datasets</span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line">0 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.002 sec. </span><br><span class="line"></span><br><span class="line">clickhouse-server_1 :) select count() from hits_v1;</span><br><span class="line"></span><br><span class="line">SELECT count()</span><br><span class="line">FROM hits_v1</span><br><span class="line"></span><br><span class="line">┌─count()─┐</span><br><span class="line">│ 8873898 │</span><br><span class="line">└─────────┘</span><br><span class="line"></span><br><span class="line">1 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.008 sec. </span><br><span class="line"></span><br><span class="line">clickhouse-server_1 :) select count() from visits_v1;</span><br><span class="line"></span><br><span class="line">SELECT count()</span><br><span class="line">FROM visits_v1</span><br><span class="line"></span><br><span class="line">┌─count()─┐</span><br><span class="line">│ 1676861 │</span><br><span class="line">└─────────┘</span><br><span class="line"></span><br><span class="line">1 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.002 sec.</span><br></pre></td></tr></table></figure><h3 id="2、查询语句测试"><a href="#2、查询语句测试" class="headerlink" title="2、查询语句测试"></a>2、查询语句测试</h3><p>​        由于clickhouse本身并没有提供查看执行计划的命令，所以只能通过查看日志变相看到SQL语句的执行过程，下面将基于hits_v1表以及官方提供的SQL测试语句结合记录的日志来进行查询语句的测试，并且之后针对clickhouse会基于这两张表持续测试。</p><h4 id="1-hits-v1表结构简单介绍"><a href="#1-hits-v1表结构简单介绍" class="headerlink" title="1. hits_v1表结构简单介绍"></a>1. hits_v1表结构简单介绍</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 这里为了后面的测试，简单介绍hits_v1的表结构，具体关于clickhouse的SQL描述在后面的文章中写出</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> datasets.hits_v1 (<span class="string">`WatchID`</span> UInt64, ...<span class="string">`RequestNum`</span> UInt32, <span class="string">`RequestTry`</span> UInt8) <span class="keyword">ENGINE</span> = MergeTree() <span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate) <span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID)) <span class="keyword">SAMPLE</span> <span class="keyword">BY</span> intHash32(UserID) <span class="keyword">SETTINGS</span> index_granularity = <span class="number">8192</span></span><br></pre></td></tr></table></figure><p>clickhouse中create table的基础语法为：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name <span class="keyword">ON</span> CLUSTER cluster</span><br><span class="line">(</span><br><span class="line">    name1 [type1] [<span class="keyword">DEFAULT</span>|<span class="keyword">MATERIALIZED</span>|<span class="keyword">ALIAS</span> expr1],</span><br><span class="line">    name2 [type2] [<span class="keyword">DEFAULT</span>|<span class="keyword">MATERIALIZED</span>|<span class="keyword">ALIAS</span> expr2],</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">INDEX</span> index_name1 expr1 <span class="keyword">TYPE</span> type1(...) GRANULARITY value1,</span><br><span class="line">    <span class="keyword">INDEX</span> index_name2 expr2 <span class="keyword">TYPE</span> type2(...) GRANULARITY value2</span><br><span class="line">) <span class="keyword">ENGINE</span> = engine_name()</span><br><span class="line">[<span class="keyword">PARTITION</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[PRIMARY <span class="keyword">KEY</span> expr]</span><br><span class="line">[<span class="keyword">SAMPLE</span> <span class="keyword">BY</span> expr]</span><br><span class="line">[<span class="keyword">SETTINGS</span> <span class="keyword">name</span>=<span class="keyword">value</span>, ...];</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选项描述</span></span><br><span class="line">- db:指定数据库名称，若未指定，默认使用当前数据库</span><br><span class="line">- cluster: clickhouse中包含集群的概念，可对每个集群进行数据分片，创建分布式表，ON CLUSTER表示将在每个分片上都创建这个本地表，默认为default</span><br><span class="line">- type: 该列类型，例如UInt32，clickhouse大小写敏感，类型必须遵守严格的大小写格式</span><br><span class="line">- MATERIALIZED: 表示该列不能被修改，是通过其他列计算出来的数据并保存在表中，查询时并不需要即时计算，所以<span class="keyword">insert</span>时不需要插入该列数据，<span class="keyword">select</span> *查询时该列数据也不会显示</span><br><span class="line">- <span class="keyword">ALIAS</span>: 类似于<span class="keyword">MATERIALIZED</span>参数，但该列数据并不会保存在表中，每次需要时才会进行计算，同样的<span class="keyword">insert</span>不能修改该列数据，<span class="keyword">select</span> *时该列数据也不会显示</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于hits_v1测试表使用的是MergeTree引擎，这里剩余参数针对MergeTree进行简单描述，其余引擎未必全部支持，关于各个引擎的描述及适用场景会在之后的文档中分开进行详细描述</span></span><br><span class="line">- <span class="keyword">PARTITION</span> <span class="keyword">BY</span>: 指定分区键，该测试表使用日期进行分区(EventDate)</span><br><span class="line">- <span class="keyword">ORDER</span> <span class="keyword">BY</span>: 指定排序键</span><br><span class="line">- PRIMARY <span class="keyword">KEY</span>: 指定主键，默认与<span class="keyword">ORDER</span> <span class="keyword">BY</span>相同</span><br><span class="line">- <span class="keyword">SAMPLE</span> <span class="keyword">BY</span>: 抽样表达式</span><br><span class="line">- SETTING: 其他一些参数</span><br></pre></td></tr></table></figure><h4 id="2-分组排序查询"><a href="#2-分组排序查询" class="headerlink" title="2. 分组排序查询"></a>2. 分组排序查询</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SQL：</span></span><br><span class="line">clickhouse-server_1 :) select CounterID, count() AS c from hits_v1 group by CounterID order by c desc <span class="built_in">limit</span> 10</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">    CounterID, </span><br><span class="line">    count() AS c</span><br><span class="line">FROM hits_v1</span><br><span class="line">GROUP BY CounterID</span><br><span class="line">ORDER BY c DESC</span><br><span class="line">LIMIT 10</span><br><span class="line"></span><br><span class="line">┌─CounterID─┬──────c─┐</span><br><span class="line">│   1704509 │ 523264 │</span><br><span class="line">│    732797 │ 475698 │</span><br><span class="line">│    598875 │ 337212 │</span><br><span class="line">│    792887 │ 252197 │</span><br><span class="line">│   3807842 │ 196036 │</span><br><span class="line">│  25703952 │ 147211 │</span><br><span class="line">│    716829 │  90109 │</span><br><span class="line">│     59183 │  85379 │</span><br><span class="line">│  33010362 │  77807 │</span><br><span class="line">│    800784 │  77492 │</span><br><span class="line">└───────────┴────────┘</span><br><span class="line"></span><br><span class="line">10 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.026 sec. Processed 8.87 million rows, 35.50 MB (339.77 million rows/s., 1.36 GB/s.) </span><br><span class="line"></span><br><span class="line"><span class="comment"># log</span></span><br><span class="line"><span class="comment">## 1. 查询语句</span></span><br><span class="line">2020.05.03 22:31:49.042192 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Debug&gt; executeQuery: (from 127.0.0.1:59736) SELECT CounterID, count() AS c FROM hits_v1 GROUP BY CounterID ORDER BY c DESC LIMIT 10</span><br><span class="line"><span class="comment">## 2. 用户权限验证</span></span><br><span class="line">2020.05.03 22:31:49.042790 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Trace&gt; AccessRightsContext (default): Access granted: SELECT(CounterID) ON datasets.hits_v1</span><br><span class="line"><span class="comment">## 3. 该SQL查询未使用主键索引</span></span><br><span class="line">2020.05.03 22:31:49.042971 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): Key condition: unknown</span><br><span class="line"><span class="comment">## 4. 该SQL查询未使用分区索引</span></span><br><span class="line">2020.05.03 22:31:49.042986 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): MinMax index condition: unknown</span><br><span class="line"><span class="comment">## 5. 该查询扫描了1个分区目录，共1092个MarkRange（分区目录和MarkRange在MergeTree中的意义还在理解中，后续在MergeTree引擎中详细描述）</span></span><br><span class="line">2020.05.03 22:31:49.043021 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): Selected 1 parts by date, 1 parts by key, 1092 marks to <span class="built_in">read</span> from 1 ranges</span><br><span class="line"><span class="comment">## 6. 全表扫描，共8873898条数据，共使用20个stream来进行查询处理数据</span></span><br><span class="line">2020.05.03 22:31:49.043381 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Trace&gt; datasets.hits_v1 (SelectExecutor): Reading approx. 8873898 rows with 20 streams</span><br><span class="line">2020.05.03 22:31:49.044209 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Trace&gt; InterpreterSelectQuery: FetchColumns -&gt; Complete</span><br><span class="line">2020.05.03 22:31:49.045627 [ 100 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Trace&gt; AggregatingTransform: Aggregating</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="comment">## 7. 每个stream查询的行数，使用时间等信息</span></span><br><span class="line">2020.05.03 22:31:49.050780 [ 100 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Trace&gt; AggregatingTransform: Aggregated. 572078 to 5872 rows (from 2.182 MiB) <span class="keyword">in</span> 0.006 sec. (88841051.020 rows/sec., 338.902 MiB/sec.)</span><br><span class="line">2020.05.03 22:31:49.050814 [ 193 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Trace&gt; AggregatingTransform: Aggregated. 516096 to 7617 rows (from 1.969 MiB) <span class="keyword">in</span> 0.006 sec. (80547357.953 rows/sec., 307.264 MiB/sec.)</span><br><span class="line">2020.05.03 22:31:49.051022 [ 191 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Trace&gt; AggregatingTransform: Aggregated. 450560 to 8195 rows (from 1.719 MiB) <span class="keyword">in</span> 0.007 sec. (68053391.462 rows/sec., 259.603 MiB/sec.)</span><br><span class="line"><span class="comment">## 8. 某一个stream进行数据merge操作</span></span><br><span class="line">2020.05.03 22:31:49.051046 [ 191 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Trace&gt; Aggregator: Merging aggregated data</span><br><span class="line"><span class="comment">## 9. 共读取了8873898条数据，共33.85M</span></span><br><span class="line">2020.05.03 22:31:49.066350 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Information&gt; executeQuery: Read 8873898 rows, 33.85 MiB <span class="keyword">in</span> 0.024 sec., 368641453 rows/sec., 1.37 GiB/sec.</span><br><span class="line">2020.05.03 22:31:49.066415 [ 81 ] &#123;d06708d7-2f0c-489f-96fe-e42012f641f0&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (<span class="keyword">for</span> query): 0.00 B.</span><br><span class="line"><span class="comment">## 10. 查询共消耗了0.00B内存</span></span><br><span class="line">2020.05.03 22:31:49.066786 [ 81 ] &#123;&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (total): 0.00 B.</span><br><span class="line"><span class="comment">## 11. 查询共使用了0.025s</span></span><br><span class="line">2020.05.03 22:31:49.066814 [ 81 ] &#123;&#125; &lt;Information&gt; TCPHandler: Processed <span class="keyword">in</span> 0.025 sec.</span><br></pre></td></tr></table></figure><h4 id="3-使用主键索引"><a href="#3-使用主键索引" class="headerlink" title="3. 使用主键索引"></a>3. 使用主键索引</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SQL:</span></span><br><span class="line">clickhouse-server_1 :) SELECT WatchID FROM hits_v1 WHERE CounterID = 67141</span><br><span class="line"></span><br><span class="line">SELECT WatchID</span><br><span class="line">FROM hits_v1</span><br><span class="line">WHERE CounterID = 67141</span><br><span class="line"></span><br><span class="line">┌─────────────WatchID─┐</span><br><span class="line">│ 9092821867385297764 │</span><br><span class="line">│ 6698385316098085730 │</span><br><span class="line">│ 8281386980251669809 │</span><br><span class="line">│ 7804373457861079090 │</span><br><span class="line">│ 5352419935083292124 │</span><br><span class="line">│ 7522442961486322437 │</span><br><span class="line">│ 4926733399374529578 │</span><br><span class="line">│ 8651569660825010330 │</span><br><span class="line">│ 7777215115402859170 │</span><br><span class="line">│ 5488491440763342147 │</span><br><span class="line">│ 7016898938173798841 │</span><br><span class="line">│ 7512073271455311672 │</span><br><span class="line">│ 7675183452718991621 │</span><br><span class="line">│ 7698094942612287474 │</span><br><span class="line">│ 7229580476946423672 │</span><br><span class="line">│ 8265472689024610766 │</span><br><span class="line">│ 7397061429050334296 │</span><br><span class="line">│ 5642502882079177996 │</span><br><span class="line">│ 5521967617262710331 │</span><br><span class="line">│ 6045376808846148744 │</span><br><span class="line">│ 5223813301270698276 │</span><br><span class="line">│ 5891294304736742075 │</span><br><span class="line">│ 7473702977877450342 │</span><br><span class="line">│ 7131227524298036078 │</span><br><span class="line">│ 6397036526472438783 │</span><br><span class="line">│ 5452801867475832050 │</span><br><span class="line">│ 8203620973862900075 │</span><br><span class="line">│ 8228211160680219393 │</span><br><span class="line">│ 5669672267661574263 │</span><br><span class="line">│ 6447542723619820343 │</span><br><span class="line">│ 5609776647750491151 │</span><br><span class="line">│ 5937976217944527938 │</span><br><span class="line">│ 8559139126342788142 │</span><br><span class="line">│ 6731577587255153490 │</span><br><span class="line">│ 7541590813574755789 │</span><br><span class="line">│ 6736741087826610411 │</span><br><span class="line">│ 5750208933466385975 │</span><br><span class="line">│ 6501641543222310031 │</span><br><span class="line">│ 6817897199087131799 │</span><br><span class="line">│ 8775895600472212626 │</span><br><span class="line">│ 7276707177012917444 │</span><br><span class="line">│ 7841417239216625313 │</span><br><span class="line">│ 6708893161493789316 │</span><br><span class="line">│ 5161987475887808662 │</span><br><span class="line">│ 5167052428932424884 │</span><br><span class="line">│ 8512404755681004329 │</span><br><span class="line">│ 5407707620324494582 │</span><br><span class="line">│ 7664508369041326595 │</span><br><span class="line">│ 6437220034025745400 │</span><br><span class="line">│ 5074053444698312956 │</span><br><span class="line">│ 5698931552063656743 │</span><br><span class="line">│ 8826145146896127905 │</span><br><span class="line">└─────────────────────┘</span><br><span class="line"></span><br><span class="line">52 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.003 sec. Processed 8.19 thousand rows, 98.30 KB (2.77 million rows/s., 33.19 MB/s.) </span><br><span class="line"></span><br><span class="line"><span class="comment"># log</span></span><br><span class="line">2020.05.03 22:58:53.011895 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Debug&gt; executeQuery: (from 127.0.0.1:50236) SELECT WatchID FROM hits_v1 WHERE CounterID = 67141</span><br><span class="line">2020.05.03 22:58:53.012824 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Trace&gt; AccessRightsContext (default): Access granted: SELECT(WatchID, CounterID) ON datasets.hits_v1</span><br><span class="line"><span class="comment">## 可以看到该条查询使用了主键索引</span></span><br><span class="line">2020.05.03 22:58:53.012985 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): Key condition: (column 0 <span class="keyword">in</span> [67141, 67141])</span><br><span class="line">2020.05.03 22:58:53.013000 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): MinMax index condition: unknown</span><br><span class="line">2020.05.03 22:58:53.013032 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): Selected 1 parts by date, 1 parts by key, 1 marks to <span class="built_in">read</span> from 1 ranges</span><br><span class="line">2020.05.03 22:58:53.013210 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Trace&gt; datasets.hits_v1 (SelectExecutor): Reading approx. 8192 rows with 1 streams</span><br><span class="line">2020.05.03 22:58:53.013291 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Trace&gt; InterpreterSelectQuery: FetchColumns -&gt; Complete</span><br><span class="line"><span class="comment">## 一共查询了8192行，共96KB</span></span><br><span class="line">2020.05.03 22:58:53.013902 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Information&gt; executeQuery: Read 8192 rows, 96.00 KiB <span class="keyword">in</span> 0.002 sec., 4226200 rows/sec., 48.37 MiB/sec.</span><br><span class="line">2020.05.03 22:58:53.013964 [ 82 ] &#123;55122f0e-83a7-454f-abed-870934d0f0a4&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (<span class="keyword">for</span> query): 0.00 B.</span><br><span class="line">2020.05.03 22:58:53.014059 [ 82 ] &#123;&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (total): 0.00 B.</span><br><span class="line"><span class="comment">## 查询一共花费了0.002s</span></span><br><span class="line">2020.05.03 22:58:53.014082 [ 82 ] &#123;&#125; &lt;Information&gt; TCPHandler: Processed <span class="keyword">in</span> 0.002 sec.</span><br></pre></td></tr></table></figure><h3 id="3、写入语句测试"><a href="#3、写入语句测试" class="headerlink" title="3、写入语句测试"></a>3、写入语句测试</h3><p>​        这里建立一张临时表，并插入一部分数据，结合log查看列数据库的写入逻辑，clickhouse官方目前未提供SQL查询及写入逻辑流程，并且基于不同的引擎，其写入逻辑有所不同，之后会在不同引擎的测试中对写入逻辑及日志进行详细描述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立临时表：</span></span><br><span class="line"><span class="comment">## SQL:</span></span><br><span class="line">clickhouse-server_1 :) CREATE TABLE mixed_granularity_table (`WatchID` UInt64, `JavaEnable` UInt8, `Title` String, `GoodEvent` Int16, `EventTime` DateTime, `EventDate` Date, `CounterID` UInt32, `ClientIP` UInt32, `ClientIP6` FixedString(16), `RegionID` UInt32, `UserID` UInt64, `CounterClass` Int8, `OS` UInt8, `UserAgent` UInt8, `URL` String, `Referer` String, `URLDomain` String, `RefererDomain` String, `Refresh` UInt8, `IsRobot` UInt8, `RefererCategories` Array(UInt16), `URLCategories` Array(UInt16), `URLRegions` Array(UInt32), `RefererRegions` Array(UInt32), `ResolutionWidth` UInt16, `ResolutionHeight` UInt16, `ResolutionDepth` UInt8, `FlashMajor` UInt8, `FlashMinor` UInt8, `FlashMinor2` String, `NetMajor` UInt8, `NetMinor` UInt8, `UserAgentMajor` UInt16, `UserAgentMinor` FixedString(2), `CookieEnable` UInt8, `JavascriptEnable` UInt8, `IsMobile` UInt8, `MobilePhone` UInt8, `MobilePhoneModel` String, `Params` String, `IPNetworkID` UInt32, `TraficSourceID` Int8, `SearchEngineID` UInt16, `SearchPhrase` String, `AdvEngineID` UInt8, `IsArtifical` UInt8, `WindowClientWidth` UInt16, `WindowClientHeight` UInt16, `ClientTimeZone` Int16, `ClientEventTime` DateTime, `SilverlightVersion1` UInt8, `SilverlightVersion2` UInt8, `SilverlightVersion3` UInt32, `SilverlightVersion4` UInt16, `PageCharset` String, `CodeVersion` UInt32, `IsLink` UInt8, `IsDownload` UInt8, `IsNotBounce` UInt8, `FUniqID` UInt64, `HID` UInt32, `IsOldCounter` UInt8, `IsEvent` UInt8, `IsParameter` UInt8, `DontCountHits` UInt8, `WithHash` UInt8, `HitColor` FixedString(1), `UTCEventTime` DateTime, `Age` UInt8, `Sex` UInt8, `Income` UInt8, `Interests` UInt16, `Robotness` UInt8, `GeneralInterests` Array(UInt16), `RemoteIP` UInt32, `RemoteIP6` FixedString(16), `WindowName` Int32, `OpenerName` Int32, `HistoryLength` Int16, `BrowserLanguage` FixedString(2), `BrowserCountry` FixedString(2), `SocialNetwork` String, `SocialAction` String, `HTTPError` UInt16, `SendTiming` Int32, `DNSTiming` Int32, `ConnectTiming` Int32, `ResponseStartTiming` Int32, `ResponseEndTiming` Int32, `FetchTiming` Int32, `RedirectTiming` Int32, `DOMInteractiveTiming` Int32, `DOMContentLoadedTiming` Int32, `DOMCompleteTiming` Int32, `LoadEventStartTiming` Int32, `LoadEventEndTiming` Int32, `NSToDOMContentLoadedTiming` Int32, `FirstPaintTiming` Int32, `RedirectCount` Int8, `SocialSourceNetworkID` UInt8, `SocialSourcePage` String, `ParamPrice` Int64, `ParamOrderID` String, `ParamCurrency` FixedString(3), `ParamCurrencyID` UInt16, `GoalsReached` Array(UInt32), `OpenstatServiceName` String, `OpenstatCampaignID` String, `OpenstatAdID` String, `OpenstatSourceID` String, `UTMSource` String, `UTMMedium` String, `UTMCampaign` String, `UTMContent` String, `UTMTerm` String, `FromTag` String, `HasGCLID` UInt8, `RefererHash` UInt64, `URLHash` UInt64, `CLID` UInt32, `YCLID` UInt64, `ShareService` String, `ShareURL` String, `ShareTitle` String, `ParsedParams.Key1` Array(String), `ParsedParams.Key2` Array(String), `ParsedParams.Key3` Array(String), `ParsedParams.Key4` Array(String), `ParsedParams.Key5` Array(String), `ParsedParams.ValueDouble` Array(Float64), `IslandID` FixedString(16), `RequestNum` UInt32, `RequestTry` UInt8) ENGINE = MergeTree() PARTITION BY toYYYYMM(EventDate) ORDER BY (CounterID, EventDate, intHash32(UserID)) SAMPLE BY intHash32(UserID) SETTINGS index_granularity=8192, enable_mixed_granularity_parts=1; -- same with hits, but enabled mixed granularity</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Ok.</span><br><span class="line"></span><br><span class="line">0 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.008 sec. </span><br><span class="line"><span class="comment">## log</span></span><br><span class="line"><span class="comment">### 1. 检查建表语句</span></span><br><span class="line">2020.05.03 23:06:08.921921 [ 82 ] &#123;0db543f9-58b2-4765-af63-a5f881246d41&#125; &lt;Debug&gt; executeQuery: (from 127.0.0.1:50236) CREATE TABLE mixed_granularity_table (`WatchID` UInt64, `JavaEnable` UInt8, `Title` String, `GoodEvent` Int16, `EventTime` DateTime, `EventDate` Date, `CounterID` UInt32, `ClientIP` UInt32, `ClientIP6` FixedString(16), `RegionID` UInt32, `UserID` UInt64, `CounterClass` Int8, `OS` UInt8, `UserAgent` UInt8, `URL` String, `Referer` String, `URLDomain` String, `RefererDomain` String, `Refresh` UInt8, `IsRobot` UInt8, `RefererCategories` Array(UInt16), `URLCategories` Array(UInt16), `URLRegions` Array(UInt32), `RefererRegions` Array(UInt32), `ResolutionWidth` UInt16, `ResolutionHeight` UInt16, `ResolutionDepth` UInt8, `FlashMajor` UInt8, `FlashMinor` UInt8, `FlashMinor2` String, `NetMajor` UInt8, `NetMinor` UInt8, `UserAgentMajor` UInt16, `UserAgentMinor` FixedString(2), `CookieEnable` UInt8, `JavascriptEnable` UInt8, `IsMobile` UInt8, `MobilePhone` UInt8, `MobilePhoneModel` String, `Params` String, `IPNetworkID` UInt32, `TraficSourceID` Int8, `SearchEngineID` UInt16, `SearchPhrase` String, `AdvEngineID` UInt8, `IsArtifical` UInt8, `WindowClientWidth` UInt16, `WindowClientHeight` UInt16, `ClientTimeZone` Int16, `ClientEventTime` DateTime, `SilverlightVersion1` UInt8, `SilverlightVersion2` UInt8, `SilverlightVersion3` UInt32, `SilverlightVersion4` UInt16, `PageCharset` String, `CodeVersion` UInt32, `IsLink` UInt8, `IsDownload` UInt8, `IsNotBounce` UInt8, `FUniqID` UInt64, `HID` UInt32, `IsOldCounter` UInt8, `IsEvent` UInt8, `IsParameter` UInt8, `DontCountHits` UInt8, `WithHash` UInt8, `HitColor` FixedString(1), `UTCEventTime` DateTime, `Age` UInt8, `Sex` UInt8, `Income` UInt8, `Interests` UInt16, `Robotness` UInt8, `GeneralInterests` Array(UInt16), `RemoteIP` UInt32, `RemoteIP6` FixedString(16), `WindowName` Int32, `OpenerName` Int32, `HistoryLength` Int16, `BrowserLanguage` FixedString(2), `BrowserCountry` FixedString(2), `SocialNetwork` String, `SocialAction` String, `HTTPError` UInt16, `SendTiming` Int32, `DNSTiming` Int32, `ConnectTiming` Int32, `ResponseStartTiming` Int32, `ResponseEndTiming` Int32, `FetchTiming` Int32, `RedirectTiming` Int32, `DOMInteractiveTiming` Int32, `DOMContentLoadedTiming` Int32, `DOMCompleteTiming` Int32, `LoadEventStartTiming` Int32, `LoadEventEndTiming` Int32, `NSToDOMContentLoadedTiming` Int32, `FirstPaintTiming` Int32, `RedirectCount` Int8, `SocialSourceNetworkID` UInt8, `SocialSourcePage` String, `ParamPrice` Int64, `ParamOrderID` String, `ParamCurrency` FixedString(3), `ParamCurrencyID` UInt16, `GoalsReached` Array(UInt32), `OpenstatServiceName` String, `OpenstatCampaignID` String, `OpenstatAdID` String, `OpenstatSourceID` String, `UTMSource` String, `UTMMedium` String, `UTMCampaign` String, `UTMContent` String, `UTMTerm` String, `FromTag` String, `HasGCLID` UInt8, `RefererHash` UInt64, `URLHash` UInt64, `CLID` UInt32, `YCLID` UInt64, `ShareService` String, `ShareURL` String, `ShareTitle` String, `ParsedParams.Key1` Array(String), `ParsedParams.Key2` Array(String), `ParsedParams.Key3` Array(String), `ParsedParams.Key4` Array(String), `ParsedParams.Key5` Array(String), `ParsedParams.ValueDouble` Array(Float64), `IslandID` FixedString(16), `RequestNum` UInt32, `RequestTry` UInt8) ENGINE = MergeTree() PARTITION BY toYYYYMM(EventDate) ORDER BY (CounterID, EventDate, intHash32(UserID)) SAMPLE BY intHash32(UserID) SETTINGS index_granularity = 8192, enable_mixed_granularity_parts = 1</span><br><span class="line"><span class="comment">### 2. 权限检查</span></span><br><span class="line">2020.05.03 23:06:08.922323 [ 82 ] &#123;0db543f9-58b2-4765-af63-a5f881246d41&#125; &lt;Trace&gt; AccessRightsContext (default): Access granted: CREATE TABLE ON datasets.mixed_granularity_table</span><br><span class="line">2020.05.03 23:06:08.925036 [ 82 ] &#123;0db543f9-58b2-4765-af63-a5f881246d41&#125; &lt;Debug&gt; datasets.mixed_granularity_table: Loading data parts</span><br><span class="line">2020.05.03 23:06:08.925135 [ 82 ] &#123;0db543f9-58b2-4765-af63-a5f881246d41&#125; &lt;Debug&gt; datasets.mixed_granularity_table: Loaded data parts (0 items)</span><br><span class="line">2020.05.03 23:06:08.925992 [ 82 ] &#123;0db543f9-58b2-4765-af63-a5f881246d41&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (<span class="keyword">for</span> query): 0.00 B.</span><br><span class="line">2020.05.03 23:06:08.926057 [ 82 ] &#123;&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (total): 0.00 B.</span><br><span class="line">2020.05.03 23:06:08.926089 [ 82 ] &#123;&#125; &lt;Information&gt; TCPHandler: Processed <span class="keyword">in</span> 0.006 sec.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据：</span></span><br><span class="line"><span class="comment">## SQL:</span></span><br><span class="line">clickhouse-server_1 :) INSERT INTO mixed_granularity_table SELECT * FROM hits_v1 LIMIT 10;</span><br><span class="line"></span><br><span class="line">INSERT INTO mixed_granularity_table SELECT *</span><br><span class="line">FROM hits_v1</span><br><span class="line">LIMIT 10</span><br><span class="line"></span><br><span class="line">↖ Progress: 10.00 rows, 10.85 KB (23.92 rows/s., 25.95 KB/s.)  0%Ok.</span><br><span class="line"></span><br><span class="line">0 rows <span class="keyword">in</span> <span class="built_in">set</span>. Elapsed: 0.418 sec. </span><br><span class="line"><span class="comment">## log:</span></span><br><span class="line">2020.05.03 23:09:53.387837 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Debug&gt; executeQuery: (from 127.0.0.1:50236) INSERT INTO mixed_granularity_table SELECT * FROM hits_v1 LIMIT 10</span><br><span class="line"><span class="comment">### 需要进行两次权限检查，对新表mixed_granularity_table的insert权限以及对hits_v1的select权限</span></span><br><span class="line">2020.05.03 23:09:53.388113 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Trace&gt; AccessRightsContext (default): Access granted: INSERT(WatchID, JavaEnable, ..., RequestTry) ON datasets.mixed_granularity_table</span><br><span class="line">2020.05.03 23:09:53.389910 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Trace&gt; AccessRightsContext (default): Access granted: SELECT(WatchID, JavaEnable, ..., RequestTry) ON datasets.hits_v1</span><br><span class="line">2020.05.03 23:09:53.390381 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): Key condition: unknown</span><br><span class="line">2020.05.03 23:09:53.390396 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): MinMax index condition: unknown</span><br><span class="line">2020.05.03 23:09:53.390421 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Debug&gt; datasets.hits_v1 (SelectExecutor): Selected 1 parts by date, 1 parts by key, 1092 marks to <span class="built_in">read</span> from 1 ranges</span><br><span class="line">2020.05.03 23:09:53.390615 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Trace&gt; MergeTreeSelectProcessor: Reading 1 ranges from part 201403_1_32_2, approx. 8873898 rows starting from 0</span><br><span class="line">2020.05.03 23:09:53.390711 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Trace&gt; InterpreterSelectQuery: FetchColumns -&gt; Complete</span><br><span class="line">2020.05.03 23:09:53.391523 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Debug&gt; executeQuery: Query pipeline:</span><br><span class="line">NullAndDoCopy</span><br><span class="line"> Converting</span><br><span class="line">  Limit</span><br><span class="line">   Expression</span><br><span class="line">    Expression</span><br><span class="line">     TreeExecutor</span><br><span class="line"></span><br><span class="line">2020.05.03 23:09:53.791641 [ 102 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Debug&gt; DiskLocal: Reserving 1.00 MiB on disk `default`, having unreserved 3.44 TiB.</span><br><span class="line">2020.05.03 23:09:53.804394 [ 102 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Trace&gt; datasets.mixed_granularity_table: Renaming temporary part tmp_insert_201403_1_1_0 to 201403_1_1_0.</span><br><span class="line">2020.05.03 23:09:53.804871 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Information&gt; executeQuery: Read 10 rows, 10.59 KiB <span class="keyword">in</span> 0.417 sec., 23 rows/sec., 25.40 KiB/sec.</span><br><span class="line">2020.05.03 23:09:53.804923 [ 82 ] &#123;321f3cb7-467a-4744-8371-29d536f78908&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (<span class="keyword">for</span> query): 263.95 MiB.</span><br><span class="line">2020.05.03 23:09:53.806135 [ 82 ] &#123;&#125; &lt;Debug&gt; MemoryTracker: Peak memory usage (total): 263.95 MiB.</span><br><span class="line">2020.05.03 23:09:53.806169 [ 82 ] &#123;&#125; &lt;Information&gt; TCPHandler: Processed <span class="keyword">in</span> 0.419 sec.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、行式存储&quot;&gt;&lt;a href=&quot;#一、行式存储&quot; class=&quot;headerlink&quot; title=&quot;一、行式存储&quot;&gt;&lt;/a&gt;一、行式存储&lt;/h2&gt;&lt;p&gt;​        一般的事务型数据库(OLTP)基本会增删改查同一行数据，故大多使用了行式存储，所有数据按列
      
    
    </summary>
    
    
    
      <category term="data" scheme="https://schnappi618.github.io/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>harbor配置https</title>
    <link href="https://schnappi618.github.io/2020/04/20/harbor/harbor%E9%85%8D%E7%BD%AEhttps/"/>
    <id>https://schnappi618.github.io/2020/04/20/harbor/harbor%E9%85%8D%E7%BD%AEhttps/</id>
    <published>2020-04-20T09:44:46.000Z</published>
    <updated>2020-07-12T12:12:17.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li>参考网页：<a href="https://goharbor.io/docs/1.10/install-config/configure-https/" target="_blank" rel="noopener">harbor配置https官方文档</a></li></ul><p>​        在前面<a href="https://schnappi618.github.io/2020/03/28/harbor%E6%90%AD%E5%BB%BAdocker%E7%A7%81%E6%9C%89%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/">harbor搭建docker私有镜像仓库</a>中使用了默认的http端口，但生产环境中并不提倡使用不安全的http服务，建议使用https保证安全性，这里根据官方推荐的openssl方法来自签证书，但浏览器并不认可自签证书的安全性，所以浏览器需要添加颁发的证书到浏览器中。同时，也可使用官方推荐的ACME获取免费的SSL证书。</p><h2 id="一、自签证书"><a href="#一、自签证书" class="headerlink" title="一、自签证书"></a>一、自签证书</h2><h3 id="1、生成CA证书"><a href="#1、生成CA证书" class="headerlink" title="1、生成CA证书"></a>1、生成CA证书</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mkdir /Users/bulubulu/docker/cert<span class="comment"># 创建一个放置证书相关的目录，并使用cd进入该目录</span></span><br><span class="line"><span class="comment">## 1. 生成CA证书私钥</span></span><br><span class="line">openssl genrsa -out ca.key 4096</span><br><span class="line"><span class="comment">## 2. 生成CA证书，可调整 -subj 选项来表明域名名称等信息</span></span><br><span class="line">openssl req -x509 -new -nodes -sha512 -days 3650 \</span><br><span class="line"> -subj <span class="string">"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=harbor.test.com"</span> \</span><br><span class="line"> -key ca.key \</span><br><span class="line"> -out ca.crt</span><br></pre></td></tr></table></figure><h3 id="2、生成服务器证书"><a href="#2、生成服务器证书" class="headerlink" title="2、生成服务器证书"></a>2、生成服务器证书</h3><p>​        认证证书通常包含证书请求<code>.csr</code>文件、签名证书<code>.crt</code>文件及私钥<code>.key</code>文件，我这里harbor配置的hostname是harbor.test.com，所以最终需要生成<code>harbor.test.com.crt、harbor.test.com.csr、harbor.test.com.key</code>三个文件。</p><ul><li>key：证书私钥，一般利用rsa等算法生成</li><li>csr：证书请求文件，利用证书私钥生成证书请求文件，该文件包含了服务器和地址等信息，申请人将该文件提交给CA机构，CA机构会根据该文件所携带的私钥信息来进行签名生成证书</li><li>crt：证书文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1. 生成私钥</span></span><br><span class="line">openssl genrsa -out harbor.test.com.key 4096</span><br><span class="line"><span class="comment">## 2. 生成csr文件</span></span><br><span class="line">openssl req -sha512 -new \</span><br><span class="line">    -subj <span class="string">"/C=CN/ST=Beijing/L=Beijing/O=example/OU=Personal/CN=harbor.test.com"</span> \</span><br><span class="line">    -key harbor.test.com.key \</span><br><span class="line">    -out harbor.test.com.csr</span><br><span class="line"><span class="comment">## 3. 生成ssl匹配多域名文，例如既想使用域名又需要通过127.0.0.1本地地址登陆测试，可使用subjectAltName参数来进行配置</span></span><br><span class="line">cat &gt; v3.ext &lt;&lt;-EOF</span><br><span class="line">authorityKeyIdentifier=keyid,issuer</span><br><span class="line">basicConstraints=CA:FALSE</span><br><span class="line">keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment</span><br><span class="line">extendedKeyUsage = serverAuth</span><br><span class="line">subjectAltName = @alt_names</span><br><span class="line"></span><br><span class="line">[alt_names]</span><br><span class="line">DNS.1=harbor.test.com</span><br><span class="line">DNS.2=127.0.0.1</span><br><span class="line">EOF</span><br><span class="line"><span class="comment">## 4. 根据v3.ext及csr文件请求生成crt证书文件</span></span><br><span class="line">openssl x509 -req -sha512 -days 3650 \</span><br><span class="line">    -extfile v3.ext \</span><br><span class="line">    -CA ca.crt -CAkey ca.key -CAcreateserial \</span><br><span class="line">    -<span class="keyword">in</span> harbor.test.com.csr \</span><br><span class="line">    -out harbor.test.com.crt</span><br></pre></td></tr></table></figure><h3 id="3、harbor配置修改"><a href="#3、harbor配置修改" class="headerlink" title="3、harbor配置修改"></a>3、harbor配置修改</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">vim</span> <span class="string">harbor.yml</span></span><br><span class="line"><span class="attr">hostname:</span> <span class="string">harbor.test.com</span></span><br><span class="line"><span class="comment"># https related config</span></span><br><span class="line"><span class="attr">https:</span></span><br><span class="line">  <span class="comment"># https port for harbor, default is 443</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">  <span class="comment"># The path of cert and key files for nginx</span></span><br><span class="line">  <span class="attr">certificate:</span> <span class="string">/Users/bulubulu/docker/cert/harbor.test.com.crt</span></span><br><span class="line">  <span class="attr">private_key:</span> <span class="string">/Users/bulubulu/docker/cert/harbor.test.com.key</span></span><br></pre></td></tr></table></figure><h3 id="4、harbor重新导入配置并启动"><a href="#4、harbor重新导入配置并启动" class="headerlink" title="4、harbor重新导入配置并启动"></a>4、harbor重新导入配置并启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 在harbor安装目录下执行以下命令重新启动</span></span><br><span class="line">docker-compose down -v</span><br><span class="line">./prepare</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="5、浏览器访问测试"><a href="#5、浏览器访问测试" class="headerlink" title="5、浏览器访问测试"></a>5、浏览器访问测试</h3><p>​        在浏览器通过所设置域名及ip分别进行测试</p><p><img src="/2020/04/20/harbor/harbor%E9%85%8D%E7%BD%AEhttps/3.png" alt="访问harbor.test.com"></p><p><img src="/2020/04/20/harbor/harbor%E9%85%8D%E7%BD%AEhttps/2.png" alt="访问127.0.0.1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;参考网页：&lt;a href=&quot;https://goharbor.io/docs/1.10/install-config/configure-https/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;harbor配置https官方文档&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="harbor" scheme="https://schnappi618.github.io/categories/harbor/"/>
    
    
      <category term="harbor" scheme="https://schnappi618.github.io/tags/harbor/"/>
    
  </entry>
  
</feed>
