<!DOCTYPE html>
<html lang="zh">
<head>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    <title>
        MySQL优化之理解查询计划 | 国家一级保护废物
    </title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <link rel="shortcut icon" href="/images/favicon.png">
    
    
<link rel="stylesheet" href="/css/style.css">

    <script id="hexo-configurations">
    let CONFIG = {"hostname":"schnappi618.github.io","root":"/","localsearch":{"enable":true,"trigger":"auto","unescape":false,"preload":false},"themeInfo":{"name":"ILS","version":"1.1.2","author":"XPoet","repository":"https://github.com/XPoet/hexo-theme-ils"},"path":"search.json"};
  </script>
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="国家一级保护废物" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="page-template">
    <div class="page-top">
        <header class="header-wrapper">

    <div class="header-progress"></div>

    <div class="header-content">

        <a class="logo-title" href="/">
            国家一级保护废物
        </a>

        <ul class="menu-list">
            
                <li class="menu-item">
                    <a class=""
                       href="/"
                    >
                        首页
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/archives"
                    >
                        归档
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/links"
                    >
                        友链
                    </a>
                </li>
            
                <li class="menu-item">
                    <a class=""
                       href="/about"
                    >
                        关于
                    </a>
                </li>
            
        </ul>

        <div class="menu-bar">
            <div class="menu-bar-middle"></div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/links">友链</a>
                </li>
            
                <li class="drawer-menu-item">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


    </div>

    <div class="page-middle ">

        <main class="main-content normal-code-theme">

            <div class="main-content-left">
                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <h3><a class="title-hover-animation">MySQL优化之理解查询计划</a></h3>
        </div>

        <div class="meta-info">
            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa fa-calendar-o"></i> 2021-07-27 10:47:00
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fa fa-folder"></i>
            <ul>
                
                    <li>
                        <a href="/categories/MySQL/">MySQL</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa fa-tags"></i>
            <ul>
                
                    <li>
                        <a href="/tags/MySQL/">MySQL</a>
                    </li>
                
                    <li>
                        | <a href="/tags/Optimization/">Optimization</a>
                    </li>
                
                    <li>
                        | <a href="/tags/EXPLAIN/">EXPLAIN</a>
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>
        </div>

        <div class="article-content markdown-body">
            <p>要进行数据库 SQL 优化必须先理解一条 SQL 具体是怎么执行的。MySQL 提供了 EXPLAIN 来描述优化器处理 SQL 的规则以及流程。本文会详细解释 EXPLAIN 各字段的含义以及不同结果所代表的意义，从而帮助理解查询计划，为 SQL 优化做基础。</p>
<h3 id="一、总览图"><a href="#一、总览图" class="headerlink" title="一、总览图"></a>一、总览图</h3><p><img src="/2021/07/27/DB/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/MySQL%20EXPLAIN.svg"></p>
<h3 id="二、EXPLAIN-概述"><a href="#二、EXPLAIN-概述" class="headerlink" title="二、EXPLAIN 概述"></a>二、EXPLAIN 概述</h3><p>EXPLAIN 中会解释 MySQL 是如何处理语句，包括表的连接方式以及处理顺序等信息。从 MySQL 5.6.3版本开始，EXPLAIN 可以分析SELECT、DELETE、INSERT、REPLACE 和 UPDATE 语句，在这之前，仅可以分析 SELECT 语句。</p>
<p>EXPLAIN 通常会跟具体语句来进行解析查看，也可以直接查看连接执行 SQL 情况。eg：<code>EXPLAIN for connection 403326;</code></p>
<p><code>Note: EXPLAIN tb_name;也可用来查看对应表中列信息，等同于SHOW COLUMNS FROM tb_name;</code></p>
<h3 id="三、EXPLAIN-输出格式"><a href="#三、EXPLAIN-输出格式" class="headerlink" title="三、EXPLAIN 输出格式"></a>三、EXPLAIN 输出格式</h3><h4 id="1、EXPLAIN-输出列"><a href="#1、EXPLAIN-输出列" class="headerlink" title="1、EXPLAIN 输出列"></a>1、EXPLAIN 输出列</h4><table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>json 名称</strong></th>
<th><strong>意义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select_id</td>
<td>表 id 号</td>
</tr>
<tr>
<td>select_type</td>
<td>None</td>
<td>select 查询类型</td>
</tr>
<tr>
<td>table</td>
<td>table_name</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>partitions</td>
<td>匹配的分区</td>
</tr>
<tr>
<td>type</td>
<td>access_type</td>
<td>连接类型</td>
</tr>
<tr>
<td>possible_keys</td>
<td>possible_keys</td>
<td>可能的索引选择</td>
</tr>
<tr>
<td>key</td>
<td>key</td>
<td>实际选择的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>key_length</td>
<td>所选key的长度</td>
</tr>
<tr>
<td>ref</td>
<td>ref</td>
<td>与索引比较的列</td>
</tr>
<tr>
<td>rows</td>
<td>rows</td>
<td>估计需要扫描的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>filtered</td>
<td>按表条件过滤的行的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>None</td>
<td>附加信息</td>
</tr>
</tbody></table>
<h4 id="2、各列详解"><a href="#2、各列详解" class="headerlink" title="2、各列详解"></a>2、各列详解</h4><p>以下 SQL 示范数据均来自于官方提供的 employees 库，可<a href="https://dev.mysql.com/doc/employee/en/employees-installation.html" target="_blank" rel="noopener">点击</a>下载测试数据</p>
<h5 id="2-1-id-JSON-name-select-id"><a href="#2-1-id-JSON-name-select-id" class="headerlink" title="2.1 id(JSON name: select_id)"></a>2.1 id(JSON name: select_id)</h5><p>一般查询语句都以 SELECT 关键字开头，查询中每出现一个 SELECT 关键字，MySQL就会为其分配一个唯一的 id 值。这个值就是 EXPLAIN 结果的第一列。例如下面的简单查询只有一个 SELECT 关键字，所以 EXPLAIN 的结果就只有 id 为 1 的一条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from departments where dept_no = 'd009';</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table       | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | departments | NULL       | const | PRIMARY       | PRIMARY | 12      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>对于连接查询来说，一个 SELECT 语句之后的 FROM 可能会有多个表，在执行计划中，每张表都会有一条记录，但这些记录的 id 号是相同的。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from dept_manager inner join departments using(dept_no);</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+-----------+---------+-------------------------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys | key       | key_len | ref                           | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+-----------+---------+-------------------------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | departments  | NULL       | index | PRIMARY       | dept_name | 122     | NULL                          |    9 |   100.00 | Using index |</span><br><span class="line">|  1 | SIMPLE      | dept_manager | NULL       | ref   | dept_no       | dept_no   | 12      | employees.departments.dept_no |    2 |   100.00 | NULL        |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+-----------+---------+-------------------------------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>在上述<code> id 相同的情况下，出现在前面的表会先被执行</code>，这张表被称为驱动表，后面的表叫做被驱动表。所以从上面的结果来看，优化器打算让 departments 表做为驱动表，让 dept_manager 表做为被驱动表。</p>
<p>对于包含子查询的语句可能会涉及到多个 SELECT 关键字，所以在包含子查询的查询执行计划中，每个 SELECT 关键字都会对应一个独立的 id 号。<code>在多个 id 值的情况下，id 值越大的会先执行</code>。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from dept_manager where dept_no in (select dept_no from departments where dept_no &lt; 'd015') or from_date &lt; '2000-01-01';</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">|  1 | PRIMARY     | dept_manager | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |   24 |   100.00 | Using where              |</span><br><span class="line">|  2 | SUBQUERY    | departments  | NULL       | range | PRIMARY       | PRIMARY | 12      | NULL |    9 |   100.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+------+------+----------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>但有时 MySQL 会将 in 子查询重写为连接查询，可通过 EXPLAIN 的 id 是否相同以及 show warnings 的结果来了解是否进行了重写。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from dept_manager where dept_no in (select dept_no from departments where dept_no &lt; 'd015');</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+-------------------------------+------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table        | partitions | type  | possible_keys | key     | key_len | ref                           | rows | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+-------------------------------+------+----------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | departments  | NULL       | range | PRIMARY       | PRIMARY | 12      | NULL                          |    9 |   100.00 | Using where; Using index |</span><br><span class="line">|  1 | SIMPLE      | dept_manager | NULL       | ref   | dept_no       | dept_no | 12      | employees.departments.dept_no |    2 |   100.00 | NULL                     |</span><br><span class="line">+<span class="comment">----+-------------+--------------+------------+-------+---------------+---------+---------+-------------------------------+------+----------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`emp_no`</span> <span class="keyword">AS</span> <span class="string">`emp_no`</span>,<span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`dept_no`</span> <span class="keyword">AS</span> <span class="string">`dept_no`</span>,<span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`from_date`</span> <span class="keyword">AS</span> <span class="string">`from_date`</span>,<span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`to_date`</span> <span class="keyword">AS</span> <span class="string">`to_date`</span> <span class="keyword">from</span> <span class="string">`employees`</span>.<span class="string">`departments`</span> <span class="keyword">join</span> <span class="string">`employees`</span>.<span class="string">`dept_manager`</span> <span class="keyword">where</span> ((<span class="string">`employees`</span>.<span class="string">`dept_manager`</span>.<span class="string">`dept_no`</span> = <span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_no`</span>) <span class="keyword">and</span> (<span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_no`</span> &lt; <span class="string">'d015'</span>))</span><br></pre></td></tr></table></figure>

<p>可以看到，上述虽然 SQL 中包含了子查询，但两条记录 id 都为1，并且可以看到 SQL 被写为了连接查询。</p>
<h5 id="2-2-select-type"><a href="#2-2-select-type" class="headerlink" title="2.2 select_type"></a>2.2 select_type</h5><p>MySQL 为每个 SELECT 子查询都定义了 select_type 的属性，根据这个属性就可以快速知道该子查询在整体查询中扮演的角色。</p>
<p>常见的类型如下：</p>
<ul>
<li>SIMPLE<ul>
<li>查询中不包含子查询或者 UNION 查询的都属于 SIMPLE 类型。单表查询和连接查询都属于该类型</li>
</ul>
</li>
<li>PRIMARY<ul>
<li>对于包含 UNION、子查询等 SQL 来说，它是由小查询组成。其中最左边或最外层的查询会被标记为 PRIMARY 类型</li>
</ul>
</li>
<li>UNION<ul>
<li>对于包含 UNION、UNION ALL 的查询，除了最左边的查询，其余的小查询均被标记为 UNION 类型</li>
</ul>
</li>
<li>UNION RESULT<ul>
<li>对于 UNION 查询来说，MySQL 会在内部创建一个临时表并对结果进行去重操作。针对该临时表的查询操作会被标记为 UNION RESULT类型</li>
</ul>
</li>
<li>SUBQUERY<ul>
<li>包含子查询的查询语句不能转换为半连接(semi-join)的形式，并且该查询是不相关子查询，查询优化器会将该子查询物化。此时子查询对应的第一个 SELECT 关键字的查询则被标记为 SUBQUERY</li>
<li>非相关子查询是独立于外部查询的子查询，子查询总共执行一次，执行完毕后将值传递给外部查询</li>
<li>相关子查询的执行依赖于外部查询的数据，外部查询执行一行，子查询就执行一次</li>
<li>非相关子查询比相关子查询效率高</li>
</ul>
</li>
<li>DEPENDENT SUBQUERY<ul>
<li>包含子查询的查询语句不能转换为半连接(semi-join)的形式，并且该查询是相关子查询。该子查询的第一个 SELECT 关键字对应的类型则为 DENENDENT SUBQUERY。该子查询可能会被执行多次</li>
</ul>
</li>
<li>DERIVED<ul>
<li>采用物化子查询的方式执行的包含派生表的查询。该派生表对应子查询的类型为 DERIVED</li>
</ul>
</li>
<li>MATERIALIZED<ul>
<li>对于包含子查询的 SQL，优化器选择将子查询物化之后和外层查询进行连接查询时，该子查询对应的类型为 MATERIALIZED</li>
</ul>
</li>
</ul>
<h5 id="2-3-table-JSON-name-table-name"><a href="#2-3-table-JSON-name-table-name" class="headerlink" title="2.3 table(JSON name: table_name)"></a>2.3 table(JSON name: table_name)</h5><p>每行所涉及的表的名称。有以下一些特殊的值：</p>
<ul>
<li>&lt;unionM, N&gt;：EXPLAIN 结果中 id 为 M 和 N 的两条记录结果并集的临时表，一般用于 UNION 去重</li>
<li>&lt;derivedN&gt;：EXPLAIN 结果中 id 为 N 的行的派生表结果。派生表一般指 FROM 子句中的子查询</li>
<li>&lt;subqueryN&gt;：EXPLAIN 结果中对 id 为 N 的行的物化子查询的结果</li>
</ul>
<h5 id="2-4-partitions-JSON-name-partitions"><a href="#2-4-partitions-JSON-name-partitions" class="headerlink" title="2.4 partitions(JSON name: partitions)"></a>2.4 partitions(JSON name: partitions)</h5><p>分区表中查询匹配记录的分区。未使用分区表该值为 NULL</p>
<h5 id="2-5-type-JSON-name-access-type"><a href="#2-5-type-JSON-name-access-type" class="headerlink" title="2.5 type(JSON name: access_type)"></a>2.5 type(JSON name: access_type)</h5><p>表示 MySQL 对某个表的访问方法。完整的访问方法包含：NULL、system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、index_subquery、range、index、ALL。常见访问方式如下：</p>
<ul>
<li><p>NULL</p>
<p>MySQL 不用访问索引或表就可以获得结果。例如：<code>SELECT sysdate();</code></p>
</li>
<li><p>system</p>
<p>表中只有一条记录并且存储引擎的统计信息是准确的。例如使用了 MyISAM 引擎的表的统计信息是准确的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一张测试表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_aoe`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'name'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'aoe'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入一条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_aoe(<span class="keyword">id</span>, <span class="keyword">name</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'aaa'</span>);</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t_aoe;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | t_aoe | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">`employees`</span>.<span class="string">`t_aoe`</span>.<span class="string">`id`</span> <span class="keyword">AS</span> <span class="string">`id`</span>,<span class="string">`employees`</span>.<span class="string">`t_aoe`</span>.<span class="string">`name`</span> <span class="keyword">AS</span> <span class="string">`name`</span> <span class="keyword">from</span> <span class="string">`employees`</span>.<span class="string">`t_aoe`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 引擎改为 MyISAM 引擎</span></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">alter</span> <span class="keyword">table</span> t_aoe <span class="keyword">engine</span> = MyISAM;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line">Records: 1  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t_aoe;      </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | t_aoe | NULL       | system | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+--------+---------------+------+---------+------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">'1'</span> <span class="keyword">AS</span> <span class="string">`id`</span>,<span class="string">'aaa'</span> <span class="keyword">AS</span> <span class="string">`name`</span> <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p>可以看到当存储引擎是 MyISAM 统计信息准确并且表中只有一条记录时，type 为 system，而为 InnoDB 这类估算的统计信息时，type 为 ALL。</p>
</li>
<li><p>const</p>
<p>根据主键或唯一索引与常量进行等值比较时，会使用 const 访问方式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;explain select * from departments where dept_no = 'd009';</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table       | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | departments | NULL       | const | PRIMARY       | PRIMARY | 12      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">'d009'</span> <span class="keyword">AS</span> <span class="string">`dept_no`</span>,<span class="string">'Customer Service'</span> <span class="keyword">AS</span> <span class="string">`dept_name`</span> <span class="keyword">from</span> <span class="string">`employees`</span>.<span class="string">`departments`</span> <span class="keyword">where</span> (<span class="string">'d009'</span> = <span class="string">'d009'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>eq_ref</p>
<p>进行连表查询时，被驱动表是通过主键或折唯一索引的方式来进行访问，则会使用 eq_ref 这种访问方式。如果主键或唯一索引是联合索引，则所有字段都必须是等值比较。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from departments inner join dept_emp on departments.dept_no = dept_emp.dept_no and dept_emp.emp_no = 1; </span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+--------+-----------------+---------+---------+----------------------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table       | partitions | type   | possible_keys   | key     | key_len | ref                        | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+--------+-----------------+---------+---------+----------------------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | dept_emp    | NULL       | ref    | PRIMARY,dept_no | PRIMARY | 4       | const                      |    1 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | departments | NULL       | eq_ref | PRIMARY         | PRIMARY | 12      | employees.dept_emp.dept_no |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------------+------------+--------+-----------------+---------+---------+----------------------------+------+----------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Note (Code <span class="number">1003</span>): <span class="comment">/* select#1 */</span> <span class="keyword">select</span> <span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_no`</span> <span class="keyword">AS</span> <span class="string">`dept_no`</span>,<span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_name`</span> <span class="keyword">AS</span> <span class="string">`dept_name`</span>,<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`emp_no`</span> <span class="keyword">AS</span> <span class="string">`emp_no`</span>,<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`dept_no`</span> <span class="keyword">AS</span> <span class="string">`dept_no`</span>,<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`from_date`</span> <span class="keyword">AS</span> <span class="string">`from_date`</span>,<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`to_date`</span> <span class="keyword">AS</span> <span class="string">`to_date`</span> <span class="keyword">from</span> <span class="string">`employees`</span>.<span class="string">`departments`</span> <span class="keyword">join</span> <span class="string">`employees`</span>.<span class="string">`dept_emp`</span> <span class="keyword">where</span> ((<span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`emp_no`</span> = <span class="number">1</span>) <span class="keyword">and</span> (<span class="string">`employees`</span>.<span class="string">`departments`</span>.<span class="string">`dept_no`</span> = <span class="string">`employees`</span>.<span class="string">`dept_emp`</span>.<span class="string">`dept_no`</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>ref</p>
<p>通过普通的二级索引与常量进行等值匹配时来访问某个表。</p>
</li>
<li><p>ref_or_null</p>
<p>和 ref 类似，只不过索引列的值可以为 NULL，则可能使用 ref_or_null 访问方式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t1 表结构如下，并且已经写入部分数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`salary`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`type`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`iState`</span> <span class="built_in">varchar</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">  <span class="string">`col`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'col'</span>,</span><br><span class="line">  <span class="string">`col2`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'col2'</span>,</span><br><span class="line">  <span class="string">`col27`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'col4'</span>,</span><br><span class="line">  <span class="string">`col100`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'这里是该列的注释内容'</span>,</span><br><span class="line">  <span class="string">`col3`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'col3'</span>,</span><br><span class="line">  <span class="string">`col5`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'col5'</span>,</span><br><span class="line">  <span class="string">`col6`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'col6'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_emp_no`</span> (<span class="string">`emp_no`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_salary`</span> (<span class="string">`salary`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`idx_col2`</span> (<span class="string">`col2`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">11376198</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where col2 = 'lcl' or col2 is null;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+---------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows    | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+---------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref_or_null | idx_col2      | idx_col2 | 99      | const | 5523271 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+---------------+----------+---------+-------+---------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>index_merge</p>
<p>在有些 SQL 中，一个查询可能会使用到多个二级索引，这种优化的方式被称为索引合并，但索引合并有时不一定比全表查询快。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from t1 where emp_no = 10000 or salary = 2000;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+-------------------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra                                           |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+-------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index_merge | idx_emp_no,idx_salary | idx_emp_no,idx_salary | 4,4     | NULL |    2 |   100.00 | Using union(idx_emp_no,idx_salary); Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------------+-----------------------+-----------------------+---------+------+------+----------+-------------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>unique_subquery</p>
<p>这是针对一些包含 IN 的子查询的 SQL 语句，如果优化器将 IN 改写为 EXISTS 子查询，而且子查询可以用到主键或唯一索引进行匹配，该子查询会为 unique_subquery 类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- IN 子句中类似于以下格式</span></span><br><span class="line">  value IN (<span class="keyword">SELECT</span> primary_key <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> emp_no <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> t1.id &gt; <span class="number">10000</span>) <span class="keyword">or</span> birth_date &gt; <span class="string">'1990-01-01'</span>;           </span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+-----------------+---------------+---------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">| id | select_type        | table     | partitions | type            | possible_keys | key     | key_len | ref  | rows   | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+-----------------+---------------+---------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">|  1 | PRIMARY            | employees | NULL       | ALL             | NULL          | NULL    | NULL    | NULL | 299478 |   100.00 | Using where              |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | t1        | NULL       | unique_subquery | PRIMARY       | PRIMARY | 8       | func |      1 |   100.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+-----------------+---------------+---------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>index_subquery</p>
<p>和unique_subquery类似，只不过子查询使用的是普通索引</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">value IN (<span class="keyword">SELECT</span> key_column <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> some_expr)</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">where</span> emp_no <span class="keyword">in</span> (<span class="keyword">select</span> emp_no <span class="keyword">from</span> t1 <span class="keyword">where</span> t1.emp_no &gt; <span class="number">10000</span>) <span class="keyword">or</span> birth_date &gt; <span class="string">'1990-01-01'</span>; </span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+----------------+---------------+------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">| id | select_type        | table     | partitions | type           | possible_keys | key        | key_len | ref  | rows   | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+----------------+---------------+------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">|  1 | PRIMARY            | employees | NULL       | ALL            | NULL          | NULL       | NULL    | NULL | 299478 |   100.00 | Using where              |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | t1        | NULL       | index_subquery | idx_emp_no    | idx_emp_no | 4       | func |     29 |   100.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+--------------------+-----------+------------+----------------+---------------+------------+---------+------+--------+----------+--------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>range</p>
<p>使用索引查询记录，并且返回在给定范围内的结果。key 字段会表明使用的索引，key_len 表示用的的索引中最长字段的长度。</p>
<p>range 在一个索引列和常量进行一些比较操作时比较常见。例如：=、&lt;&gt;、&gt;、≥、&lt;、≤、IS NULL、&lt;=&gt;、BETWEEN、IN() 等</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一般为以下格式有可能为range类型</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">BETWEEN</span> <span class="number">10</span> <span class="keyword">and</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_column <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> key_part1 = <span class="number">10</span> <span class="keyword">AND</span> key_part2 <span class="keyword">IN</span> (<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 例子：</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where emp_no between 10000 and 20000;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+--------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows   | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+--------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_emp_no    | idx_emp_no | 4       | NULL | 792594 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+--------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> emp_no <span class="keyword">in</span> (<span class="number">10000</span>,<span class="number">10010</span>,<span class="number">10020</span>); </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_emp_no    | idx_emp_no | 4       | NULL |   34 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> titles <span class="keyword">where</span> emp_no = <span class="number">10000</span> <span class="keyword">and</span> title <span class="keyword">in</span> (<span class="string">'Senior Engineer'</span>, <span class="string">'Staff'</span>, <span class="string">'Engineer'</span>);</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | range | PRIMARY       | PRIMARY | 156     | NULL |    3 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>index</p>
<p>可以使用覆盖索引，但需要扫描全部的索引记录。一般用于以下两种情况：</p>
<ul>
<li>如果是覆盖索引，可以满足所有需要的数据，也就是说查询列都为索引中的字段。这种情况下只需要扫描索引树即可，Extra 列会显示 Using index. 索引扫描一般比 ALL 全表扫描快一些，因为索引大小通常都小于表数据。</li>
<li>全表扫描是使用从索引中读取的记录(以索引的顺序)查找数据记录。Extra 列不显示 Using index。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select col2 from t1 where col2 = 2000; </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+----------+----------+--------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows     | filtered | Extra                    |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+----------+----------+--------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | index | idx_col2      | idx_col2 | 99      | NULL | 11046540 |    10.00 | Using where; Using index |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+----------+----------+--------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">3</span> <span class="keyword">warnings</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>ALL</p>
<p>全表扫描。对前表中的每个行组合进行全表扫描。如果该表是驱动表并且未标记为 const，那么性能通常会很慢。一般可以通过添加索引避免全表扫描。</p>
</li>
</ul>
<h5 id="2-6-possible-keys-JSON-name-possible-keys"><a href="#2-6-possible-keys-JSON-name-possible-keys" class="headerlink" title="2.6 possible_keys(JSON name: possible_keys)"></a>2.6 possible_keys(JSON name: possible_keys)</h5><p>possible_keys 列显示了 MySQL 在查找记录时可能使用到的索引，这个值并不是越多越好，可能使用的索引越多，查询优化器计算查询成本就需要花费更多的时间，可以尽量删除那些不使用的索引。</p>
<p>如果这列为 NULL (JSON 格式中为 undefined)，说明这个查询没有可用的索引。这种情况可以检查 where 子句中使用的列，查看是否可以创建合适的索引，改进查询性能。</p>
<h5 id="2-7-key-JSON-name-key"><a href="#2-7-key-JSON-name-key" class="headerlink" title="2.7 key(JSON name: key)"></a>2.7 key(JSON name: key)</h5><p>key 列显示了 MySQL 在查询过程中实际使用到的索引。如果 MySQL 决定使用 possible_keys 中列出的索引，则会在 key 中显示。当使用到了覆盖索引，则只会在 key 列中显示。如果为 NULL 的话则表示没有找到合适的索引。想要强制使用或忽略在 possible_keys 中列出的某个索引，可以使用 FORCE INDEX、USE INDEX 或者 IGNORE INDEX。</p>
<h5 id="2-8-key-len-JSON-name-key-length"><a href="#2-8-key-len-JSON-name-key-length" class="headerlink" title="2.8 key_len(JSON name: key_length)"></a>2.8 key_len(JSON name: key_length)</h5><p>key_len 表示了当优化器决定使用哪个索引执行查询时，索引记录的最大长度。它由以下三部分组成：</p>
<ul>
<li>对于使用固定长度的索引来说，实际占用的存储空间最大长度就是一个固定值。但对于指定了字符集的变长类型的索引列来说，为该变长类型的最大长度。例如：某个索引列的类型是 varchar(100)，使用了 utf8 字符集，那么该列实际占用的最大存储空间是 <code>100 * 3 = 300</code>个字节</li>
<li>如果该索引列可以存储 NULL 值，则 key_len 比不可以存储 NULL 值是多 1 个字节</li>
<li>对于变长字段来说，都会提供 2 个字节的空间来存储变长列的实际长度</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id为bigint类型，且为 NOT NULL不允许存储NULL值，可看到 key_len 为 8</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where id = 1000;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | const | PRIMARY       | PRIMARY | 8       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- col2 为 varchar(32)，默认值为NULL，字符集为 utf8，key_len = 32 * 3 + 1 + 2 = 99</span></span><br><span class="line">(dba:<span class="number">5011</span>)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> col2 = <span class="string">'test'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_col2      | idx_col2 | 99      | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>在 InnoDB 中，存储变长字段的长度为 1～2 个字节，EXPLAIN 直接使用了 2 字节来表示，是由于 MySQL EXPLAIN 并不会真实去引擎层执行查询，而是属于 Server 层的功能，更主要是让人们可以<strong>准确的知道联合索引情况下实际到底是用了几个索引字段</strong>。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 以官方提供的 employees 测试库中的 titles 表为例</span></span><br><span class="line"><span class="comment">-- 在 titles 表中，存在一个联合主键：PRIMARY KEY (`emp_no`,`title`,`from_date`)，表结构如下：</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`titles`</span> (</span><br><span class="line">  <span class="string">`emp_no`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`title`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`from_date`</span> <span class="built_in">date</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`to_date`</span> <span class="built_in">date</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>,<span class="string">`title`</span>,<span class="string">`from_date`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`titles_ibfk_1`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`emp_no`</span>) <span class="keyword">REFERENCES</span> <span class="string">`_employees_old`</span> (<span class="string">`emp_no`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- emp_no 为 int 类型，且不可以为 NULL，所以只使用 emp_no 索引列，此时 key_len = 4</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from titles where emp_no = 10000;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 emp_no 和 title 列联合进行查询，emp_no 占用 4 字节，对应 key_len1 = 4</span></span><br><span class="line"><span class="comment">-- title 为 varchar(50)，是变长字段，字符集为 utf8，不可以为 NULL，所以对应 key_len2 = 50 * 3 + 2 = 152</span></span><br><span class="line"><span class="comment">-- 最终的 key_len = key_len1 + key_len2 = 156</span></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> titles <span class="keyword">where</span> emp_no = <span class="number">10000</span> <span class="keyword">and</span> title = <span class="string">'engines'</span>;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref         | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 156     | const,const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="2-9-ref-JSON-name-ref"><a href="#2-9-ref-JSON-name-ref" class="headerlink" title="2.9 ref(JSON name: ref)"></a>2.9 ref(JSON name: ref)</h5><p>当 type 为 const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery ，使用索引列等值匹配的条件来进行查询时，ref 列表示和索引字段进行匹配的内容类型。一般为一个常数或某个字段列。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- ref 为 const，表示和索引列 emp_no 进行比较的是一个常数</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from titles where emp_no = 10000;</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">| id | select_type | table  | partitions | type | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | titles | NULL       | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+--------+------------+------+---------------+---------+---------+-------+------+----------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ref 为 employees.employees.emp_no，说明和 t1 表 idx_emp_no 索引字段匹配查找的条件是 employees 库 employees 表的 emp_no 字段列</span></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> employees <span class="keyword">inner</span> <span class="keyword">join</span> t1 <span class="keyword">using</span> (emp_no);</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------------+---------+----------------------------+--------+----------+-------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key        | key_len | ref                        | rows   | filtered | Extra |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------------+---------+----------------------------+--------+----------+-------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | ALL  | PRIMARY       | NULL       | NULL    | NULL                       | 299478 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ref  | idx_emp_no    | idx_emp_no | 4       | employees.employees.emp_no |     29 |   100.00 | NULL  |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------------+---------+----------------------------+--------+----------+-------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h5 id="2-10-rows-JSON-name-rows"><a href="#2-10-rows-JSON-name-rows" class="headerlink" title="2.10 rows(JSON name: rows)"></a>2.10 rows(JSON name: rows)</h5><p>优化器认为的预计使用的行数。对于 InnoDB 索引来说，这是个预估值。如果使用索引来执行查询，仅表示预计扫描的索引记录行数。</p>
<h5 id="2-11-filtered-JSON-name-filtered"><a href="#2-11-filtered-JSON-name-filtered" class="headerlink" title="2.11 filtered(JSON name: filtered)"></a>2.11 filtered(JSON name: filtered)</h5><p>预估被表条件过滤的记录比例。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from t1 where emp_no &lt; 8000 and from_date &gt; '1990-01-01'; </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key        | key_len | ref  | rows | filtered | Extra                              |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_emp_no    | idx_emp_no | 4       | NULL |    9 |    33.33 | Using index condition; Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+------------+---------+------+------+----------+------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>从上面示例可以看出，该条 SQL 使用了 idx_emp_no 索引，MySQL 预计满足 emp_no &lt; 8000 的条数为 9 条，filtered 就表示在这 9 条记录中，有多少记录满足剩余的匹配条件，也就是说优化器预测在这 9 条记录中满足 from_date &gt; ‘1990-01-01’ 这个条件的百分比为 33.33%。</p>
<p>这个参数主要是针对于连表查询，可以大概知道对被驱动表的查询次数。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from employees inner join t1 on employees.emp_no = t1.id where t1.col2 = 'test'; </span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+------------------+----------+---------+-----------------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type   | possible_keys    | key      | key_len | ref             | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+------------------+----------+---------+-----------------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ref    | PRIMARY,idx_col2 | idx_col2 | 99      | const           |   90 |   100.00 | NULL        |</span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | eq_ref | PRIMARY          | PRIMARY  | 4       | employees.t1.id |    1 |   100.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+------------------+----------+---------+-----------------+------+----------+-------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>从上述执行计划可以看到，MySQL 是准备将 t1 表做为驱动表，employees 表做为被驱动表，驱动表 t1 的 rows 为 99，filtered 列为 100%，这表明我们大概需要对被驱动表 employees 执行大约 <code>99 * 100% = 99</code>次查询。</p>
<h5 id="2-12-Extra"><a href="#2-12-Extra" class="headerlink" title="2.12 Extra"></a>2.12 Extra</h5><p>Extra 用来描述一些其余的额外补充信息。完整信息可查看<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html" target="_blank" rel="noopener">官方文档</a>，常见的如下：</p>
<ul>
<li><p>Impossible Where</p>
<p>查询条件永远为 false，会提示该信息</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from t1 where 1 = 2;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra            |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | Impossible WHERE |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using index</p>
<p>表示可以使用覆盖索引的情况</p>
</li>
<li><p>Index Condition Pushdown</p>
<p>在同个索引中，多个索引字段都使用了范围查询时，后面的范围查询无法使用到索引优化查询。早期 MySQL 需要回表找到完整记录后再进行条件判断，再将符合条件的记录加入到结果集中。InnoDB 后面通过在索引中判断符合记录是否符合查询条件，如果这个条件不满足，就不会进入回表流程。由于回表操作是随机 I/O，比较耗时，这样改进省略了一些回表操作，这个优化被称为 Index Condition Pushdown(索引条件下推)。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于 col2条件均为范围查询，第一个条件之后本身第二个条件无法使用索引，但使用索引条件下推优化，省去了部分回表操作</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where col2 &gt; 'a' and col2 like '%test%';  </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | range | idx_col2      | idx_col2 | 99      | NULL |   97 |   100.00 | Using index condition |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using where</p>
<p>当 SQL 中包含 Where 条件无法使用到索引的情况，Extra 列中会出现 Using where 信息。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- col 列无索引，需要进行全表扫描</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from t1 where col = 'test';                     </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 11046540 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- col2 列有索引，并且会走对应索引，col 列无索引</span></span><br><span class="line">(mysql)@[employees]&gt;<span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">where</span> <span class="keyword">col</span> = <span class="string">'test'</span> <span class="keyword">and</span> col2 = <span class="string">'test'</span>;</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ref  | idx_col2      | idx_col2 | 99      | const |   90 |    10.00 | Using where |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using join buffer(Block Nested Loop)</p>
<p>Join 的原理相当于先筛选出驱动表符合条件的记录，再通过连接条件逐条对被驱动表进行筛选，当表数据量比较大并且无法使用到有效索引时，需要不断地对被驱动表进行重复匹配。MySQL 针对这种情况提供了一个 join buffer 的内存空间来提高查询效率。将若干条驱动表的记录装在 join buffer 中，每条被驱动表的记录一次性和 join buffer 中的所有结果做匹配。这种算法也叫做<code>基于块的嵌套循环算法</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from employees inner join t1 on employees.birth_date = t1.from_date;    </span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra                                              |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   299478 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 11046540 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>从上面示例可以看出，使用 employees 表做为驱动表，t1 表做为被驱动表，由于无法使用到索引，使用了 join buffer 减少对 t1 表的访问次数，提高查询效率。在访问 t1 表时，满足驱动表 employees 条件的记录已经确定，所以每次对 t1 表的判断其实是 <code>t1.from_date = 常量</code>，在 Extra 中还会显示 Using where 信息。</p>
</li>
<li><p>Not exists</p>
<p>当使用外连接时，条件中包含被驱动表为 NULL 值的搜索条件，但字段禁止为 NULL 时，会提示 Not exists 附加信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- t1 表的 id 字段为自增主键，不能为 NULL</span></span><br><span class="line">(mysql)@[employees]&gt;explain select * from employees left join t1 on employees.birth_date = t1.from_date where t1.id is NULL;  </span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra                                                          |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   299478 |   100.00 | NULL                                                           |</span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 11046540 |    10.00 | Using where; Not exists; Using join buffer (Block Nested Loop) |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+------+---------------+------+---------+------+----------+----------+----------------------------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Using filesort</p>
<p>排序操作无法使用到索引时，只能在内存或磁盘中进行排序，在内存或磁盘上进行排序的操作统称为 filesort。如果查询数据量比较大，并且需要使用 filesort 排序，一般性能是比较低的，需要尽量为排序字段添加索引避免 filesort。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(mysql)@[employees]&gt;explain select * from employees inner join t1 on employees.emp_no = t1.emp_no order by t1.from_date limit 5;</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+---------------+---------+---------+---------------------+----------+----------+----------------+</span></span><br><span class="line">| id | select_type | table     | partitions | type   | possible_keys | key     | key_len | ref                 | rows     | filtered | Extra          |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+---------------+---------+---------+---------------------+----------+----------+----------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1        | NULL       | ALL    | idx_emp_no    | NULL    | NULL    | NULL                | 11046540 |   100.00 | Using filesort |</span><br><span class="line">|  1 | SIMPLE      | employees | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | employees.t1.emp_no |        1 |   100.00 | NULL           |</span><br><span class="line">+<span class="comment">----+-------------+-----------+------------+--------+---------------+---------+---------+---------------------+----------+----------+----------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><img src="/2021/07/27/DB/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/filesort_1.jpg"></p>
<p><img src="/2021/07/27/DB/MySQL%E4%BC%98%E5%8C%96%E4%B9%8B%E7%90%86%E8%A7%A3%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92/filesort_2.jpg"></p>
<p>可以看出，通过索引字段排序和使用 filesort 排序查询效率差异非常大。</p>
</li>
<li><p>Using temporary</p>
<p>对于一些包含 distinct、group by、union 等子句的查询，如果不能使用索引来进行查询，MySQL 会借助临时表来完成查询、去重、排序等功能。如果查询过程中使用到了临时表，则会提示 Using temporary 信息。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- col列不是 t1 表的索引字段</span></span><br><span class="line">(mysql)@[employees]&gt;explain select col from t1 group by col;  </span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+---------------------------------+</span></span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows     | filtered | Extra                           |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+---------------------------------+</span></span><br><span class="line">|  1 | SIMPLE      | t1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 11046540 |   100.00 | Using temporary; Using filesort |</span><br><span class="line">+<span class="comment">----+-------------+-------+------------+------+---------------+------+---------+------+----------+----------+---------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span>, <span class="number">1</span> <span class="keyword">warning</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看出，上述 Extra 列不仅出现了 Using temporary，还出现了 Using filesort。这是由于在 MySQL 中，group by 查询会默认添加上 order by 子句，如果不想进行排序，需要我们显式添加 <code>order by NULL</code>子句，避免查询时排序产生的成本。建立和维护临时表的成本非常大，对 SQL 执行效率有比较大的影响，尽量通过索引来替换掉临时表的使用。</p>
</li>
</ul>
<hr>
<p><strong>参考 《MySQL 是怎样运行的：从根儿上理解 MySQL》 作者:小孩子4919</strong></p>
<p><strong>参考 《MySQL 官方文档</strong>》</p>

        </div>

        <div class="article-nav">
            
            
                <div class="article-next">
                    <a class="next btn"
                       rel="next"
                       href="/2021/04/08/DB/MySQL%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D/"
                    >
                        <span class="post-nav-title-item">MySQL备份恢复</span><span class="post-nav-item">下一篇</span> <i class="fa fa-chevron-right"></i>
                    </a>
                </div>
            
        </div>

        <div class="comment-container">
            <div class="comments-container">
    
</div>
        </div>
    </div>
</div>

    <div class="article-toc-container fade-in-down-animation">
        <div class="article-toc">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、总览图"><span class="nav-text">一、总览图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、EXPLAIN-概述"><span class="nav-text">二、EXPLAIN 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、EXPLAIN-输出格式"><span class="nav-text">三、EXPLAIN 输出格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、EXPLAIN-输出列"><span class="nav-text">1、EXPLAIN 输出列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、各列详解"><span class="nav-text">2、各列详解</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-1-id-JSON-name-select-id"><span class="nav-text">2.1 id(JSON name: select_id)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-select-type"><span class="nav-text">2.2 select_type</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-table-JSON-name-table-name"><span class="nav-text">2.3 table(JSON name: table_name)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-partitions-JSON-name-partitions"><span class="nav-text">2.4 partitions(JSON name: partitions)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-type-JSON-name-access-type"><span class="nav-text">2.5 type(JSON name: access_type)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-possible-keys-JSON-name-possible-keys"><span class="nav-text">2.6 possible_keys(JSON name: possible_keys)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-7-key-JSON-name-key"><span class="nav-text">2.7 key(JSON name: key)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-key-len-JSON-name-key-length"><span class="nav-text">2.8 key_len(JSON name: key_length)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-ref-JSON-name-ref"><span class="nav-text">2.9 ref(JSON name: ref)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-10-rows-JSON-name-rows"><span class="nav-text">2.10 rows(JSON name: rows)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-11-filtered-JSON-name-filtered"><span class="nav-text">2.11 filtered(JSON name: filtered)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-12-Extra"><span class="nav-text">2.12 Extra</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </div>
    </div>


                

            </div>

            

        </main>

        <div class="sidebar-tools">
            <div class="tools-container">
    <ul class="tools-list">
        
            <li class="search popup-trigger">
                <i class="fa fa-search"></i>
            </li>
            
<script src="/js/local-search.js"></script>

        
        <li class="mode-toggle">
            <i class="fa fa-moon-o"></i>
        </li>
        
            <li class="rss">
                <a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a>
            </li>
        
    </ul>
</div>

        </div>

        
            <div class="scroll-to-top">
                <ul>
                    <li>
                        <!--<i class="fa fa-caret-up"></i>-->
                        <span class="scroll-percent"></span>
                    </li>
                </ul>
            </div>
        
    </div>

    <div class="page-bottom">
        <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy; 2021 <a href="/">schnappi618</a>
        </div>
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动 | 主题 <a
                    href="https://github.com/XPoet/hexo-theme-ils" target="_blank">ILS v1.1.2</a>
        </div>
        
            <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" style="display: none">
                        访问人数<span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" style="display: none">
                        总访问量<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
    </div>
</footer>

    </div>
</div>

    <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-icon">
            <i class="fa fa-search"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>


<script src="/js/main.js"></script>
<script src="/js/header-shrink.js"></script>
<script src="/js/toggle-mode.js"></script>



    
<script src="/js/scroll-to-top.js"></script>





    
        
<script src="/js/code-copy.js"></script>

    

    
        
<script src="/lib/anime.min.js"></script>
<script src="/js/toc.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    




</body>
</html>